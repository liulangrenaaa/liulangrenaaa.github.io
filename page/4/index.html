<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>liulangren Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="liulangren blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="liulangren blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="liulangren Blog"><meta property="og:url" content="https://liulangrenaaa.github.io/"><meta property="og:site_name" content="liulangren Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liulangrenaaa.github.io/img/og_image.png"><meta property="article:author" content="Su Hui"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liulangrenaaa.github.io"},"headline":"liulangren Blog","image":["https://liulangrenaaa.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Su Hui"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cabdc5b9b70bb83fa919a6ebeb439f93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=PTKX6HMR55" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'PTKX6HMR55');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-30T11:00:00.000Z" title="4/30/2021, 7:00:00 PM">2021-04-30</time>发表</span><span class="level-item"><time dateTime="2021-05-19T08:41:21.380Z" title="5/19/2021, 4:41:21 PM">2021-05-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">11 分钟读完 (大约1612个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/30/schedule/util_est/">util_est</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p><code>struct util_est - Estimation utilization of FAIR tasks</code><br>这是一个评估 <code>fair</code> task的 utilization的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">It&#39;s worth noting that the estimated utilization is tracked only for</span><br><span class="line"> objects of interests, specifically:</span><br><span class="line"></span><br><span class="line">  - Tasks: to better support tasks placement decisions</span><br><span class="line">  - root cfs_rqs: to better support both tasks placement decisions as</span><br><span class="line">                  well as frequencies selection</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Moreover, the PELT utilization of a task can be updated every [ms], thus</span><br><span class="line"> making it a continuously changing value for certain longer running</span><br><span class="line"> tasks. This means that the instantaneous PELT utilization of a RUNNING</span><br><span class="line"> task is not really meaningful to properly support scheduler decisions.</span><br><span class="line"></span><br><span class="line"> For all these reasons, a more stable signal can do a better job of</span><br><span class="line"> representing the expected&#x2F;estimated utilization of a task&#x2F;cfs_rq.</span><br><span class="line"> Such a signal can be easily created on top of PELT by still using it as</span><br><span class="line"> an estimator which produces values to be aggregated on meaningful</span><br><span class="line"> events.</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct util_est - Estimation utilization of FAIR tasks</span><br><span class="line"> * @enqueued: instantaneous estimated utilization of a task&#x2F;cpu -- task的 瞬时的 util</span><br><span class="line"> * @ewma:     the Exponential Weighted Moving Average (EWMA)</span><br><span class="line"> *            utilization of a task                             -- task的 EWMA（移动加权平均） 的 util</span><br><span class="line"> *</span><br><span class="line"> * Support data structure to track an Exponential Weighted Moving Average</span><br><span class="line"> * (EWMA) of a FAIR task&#39;s utilization. New samples are added to the moving</span><br><span class="line"> * average each time a task completes an activation. Sample&#39;s weight is chosen</span><br><span class="line"> * so that the EWMA will be relatively insensitive to transient changes to the</span><br><span class="line"> * task&#39;s workload.</span><br><span class="line"> *</span><br><span class="line"> * The enqueued attribute has a slightly different meaning for tasks and cpus:</span><br><span class="line"> * - task:   the task&#39;s util_avg at last task dequeue time</span><br><span class="line"> * - cfs_rq: the sum of util_est.enqueued for each RUNNABLE task on that CPU</span><br><span class="line"> * Thus, the util_est.enqueued of a task represents the contribution on the</span><br><span class="line"> * estimated utilization of the CPU where that task is currently enqueued.</span><br><span class="line"> *</span><br><span class="line"> * Only for tasks we track a moving average of the past instantaneous</span><br><span class="line"> * estimated utilization. This allows to absorb sporadic drops in utilization</span><br><span class="line"> * of an otherwise almost periodic task.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct util_est &#123;</span><br><span class="line">	unsigned int			enqueued;</span><br><span class="line">	unsigned int			ewma;</span><br><span class="line">#define UTIL_EST_WEIGHT_SHIFT		2</span><br><span class="line">&#125; __attribute__((__aligned__(sizeof(u64))));</span><br></pre></td></tr></table></figure>

<p>当一个 <code>task</code> 完成一次激活（？？enqueue?）的时候，最新的采样会被 加权之后添加到 EWMA中；因为会对 <code>sample</code> 做一个加权，所以 <code>EWMA</code> 对 <code>task workload</code>的瞬时量不会态敏感。</p>
<p><code>.enqueue</code> 这个含义对 <code>task</code> 与 <code>cpu</code> 有些不一样:<br><code>task</code>: 在上次 dequeue时刻，task的 util_avg<br><code>cfs_rq</code>: 在 这个cpu上 所有 <code>RUNNABLE task</code>的 <code>util_est.enqueued</code>之和</p>
<p>我们只对 <code>tasks</code> 跟踪 过去瞬时的 util，不会对 <code>cpu</code>跟踪这个。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><code>util_est</code> 对外部只提供了四个API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline void util_est_enqueue(struct cfs_rq *cfs_rq,</span><br><span class="line">				    struct task_struct *p);</span><br><span class="line"></span><br><span class="line">static inline void util_est_dequeue(struct cfs_rq *cfs_rq,</span><br><span class="line">				    struct task_struct *p);</span><br><span class="line"></span><br><span class="line">static inline void util_est_update(struct cfs_rq *cfs_rq,</span><br><span class="line">				   struct task_struct *p,</span><br><span class="line">				   bool task_sleep);</span><br><span class="line"></span><br><span class="line">static inline void cfs_se_util_change(struct sched_avg *avg);</span><br></pre></td></tr></table></figure>


<p><code>util_est_enqueue</code> <code>util_est_dequeue</code> 都是只在 <code>enqueue_task_fair</code> <code>dequeue_task_fair</code> 中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct cfs_rq *cfs_rq;</span><br><span class="line">	struct sched_entity *se &#x3D; &amp;p-&gt;se;</span><br><span class="line">	int idle_h_nr_running &#x3D; task_has_idle_policy(p);</span><br><span class="line">	int task_new &#x3D; !(flags &amp; ENQUEUE_WAKEUP);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The code below (indirectly) updates schedutil which looks at</span><br><span class="line">	 * the cfs_rq utilization to select a frequency.</span><br><span class="line">	 * Let&#39;s add the task&#39;s estimated utilization to the cfs_rq&#39;s</span><br><span class="line">	 * estimated utilization, before we update schedutil.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	util_est_enqueue(&amp;rq-&gt;cfs, p);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct cfs_rq *cfs_rq;</span><br><span class="line">	struct sched_entity *se &#x3D; &amp;p-&gt;se;</span><br><span class="line">	int task_sleep &#x3D; flags &amp; DEQUEUE_SLEEP;</span><br><span class="line">	int idle_h_nr_running &#x3D; task_has_idle_policy(p);</span><br><span class="line">	bool was_sched_idle &#x3D; sched_idle_rq(rq);</span><br><span class="line"></span><br><span class="line">	util_est_dequeue(&amp;rq-&gt;cfs, p);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">dequeue_throttle:</span><br><span class="line">	util_est_update(&amp;rq-&gt;cfs, p, task_sleep);</span><br><span class="line">	hrtick_update(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>enqueue_task_fair</code> 中调用 <code>util_est_enqueue</code> 时，此时 task-&gt;entity 还未 入队<br><code>dequeue_task_fair</code> 中调用 <code>util_est_dequeue</code> 时，此时 task-&gt;entity 还未 出队</p>
<p>在 <code>enqueue_task_fair</code> <code>dequeue_task_fair</code> 中，会对 <code>entity</code> 进行 <code>enqueue_entity</code> 和 <code>dequeue_entity</code>，两个过程都需要 <code>update_load_avg</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static inline void cfs_se_util_change(struct sched_avg *avg)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int enqueued;</span><br><span class="line"></span><br><span class="line">	if (!sched_feat(UTIL_EST))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Avoid store if the flag has been already set *&#x2F;</span><br><span class="line">	enqueued &#x3D; avg-&gt;util_est.enqueued;</span><br><span class="line">	if (!(enqueued &amp; UTIL_AVG_UNCHANGED))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Reset flag to report util_avg has been updated *&#x2F;</span><br><span class="line">	enqueued &amp;&#x3D; ~UTIL_AVG_UNCHANGED;</span><br><span class="line">	WRITE_ONCE(avg-&gt;util_est.enqueued, enqueued);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __update_load_avg_se(u64 now, struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	if (___update_load_sum(now, &amp;se-&gt;avg, !!se-&gt;on_rq, se_runnable(se),</span><br><span class="line">				cfs_rq-&gt;curr &#x3D;&#x3D; se)) &#123;</span><br><span class="line"></span><br><span class="line">		___update_load_avg(&amp;se-&gt;avg, se_weight(se));</span><br><span class="line">		cfs_se_util_change(&amp;se-&gt;avg);</span><br><span class="line">		trace_pelt_se_tp(se);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void update_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	u64 now &#x3D; cfs_rq_clock_pelt(cfs_rq);</span><br><span class="line">	int decayed;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Track task load average for carrying it to new CPU after migrated, and</span><br><span class="line">	 * track group sched_entity load average for task_h_load calc in migration</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (se-&gt;avg.last_update_time &amp;&amp; !(flags &amp; SKIP_AGE_LOAD))</span><br><span class="line">		__update_load_avg_se(now, cfs_rq, se);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以一个 task <code>enqueue</code> <code>dequeue</code> 两个过程 和 util_est相关的流程是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">enqueue_task_fair</span><br><span class="line">    |</span><br><span class="line">    util_est_enqueue</span><br><span class="line">    |</span><br><span class="line">    enqueue_entity</span><br><span class="line">        |</span><br><span class="line">        update_load_avg</span><br><span class="line">            |</span><br><span class="line">            __update_load_avg_se</span><br><span class="line">                |</span><br><span class="line">                cfs_se_util_change</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">dequeue_task_fair</span><br><span class="line">    |</span><br><span class="line">    util_est_dequeue</span><br><span class="line">    |</span><br><span class="line">    enqueue_entity</span><br><span class="line">        |</span><br><span class="line">        update_load_avg</span><br><span class="line">            |</span><br><span class="line">            __update_load_avg_se</span><br><span class="line">                |</span><br><span class="line">                cfs_se_util_change</span><br><span class="line">    |</span><br><span class="line">    util_est_update</span><br></pre></td></tr></table></figure>

<p>都是先要经过 <code>cfs_se_util_change</code> 然后再经过 <code>dequeue_task_fair</code> 中的<code>util_est_update</code> ，在 <code>util_est_update</code> 中更新 EWMA的值。</p>
<p>内部实现使用了 <code>UTIL_AVG_UNCHANGED</code> 这个变量来同步这两个过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * When a task is dequeued, its estimated utilization should not be update if</span><br><span class="line"> * its util_avg has not been updated at least once.</span><br><span class="line"> * This flag is used to synchronize util_avg updates with util_est updates.</span><br><span class="line"> * We map this information into the LSB bit of the utilization saved at</span><br><span class="line"> * dequeue time (i.e. util_est.dequeued).</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="EWMA是啥？"><a href="#EWMA是啥？" class="headerlink" title="EWMA是啥？"></a>EWMA是啥？</h2><p>参考<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/EWMA">EWMA</a></p>
<p>EWMA - Exponential Weighted Moving Average 指数加权移动平均。</p>
<p>ewma(t) = w *  task_util(p) + (1-w) * ewma(t-1)<br>        = w *  task_util(p) +         ewma(t-1)  - w * ewma(t-1)<br>        = w * (task_util(p) -         ewma(t-1)) +     ewma(t-1)<br>        = w * (      last_ewma_diff            ) +     ewma(t-1)<br>        = w * (last_ewma_diff  +  ewma(t-1) / w)</p>
<p>其中 w = 0.25 = 1 / 4</p>
<p>ewma(t) = (last_ewma_diff + ewma(t-1) &lt;&lt; 2)   &gt;&gt; 2<br>        = (last_ewma_diff + ewma(t-1) &lt;&lt; UTIL_EST_WEIGHT_SHIFT)   &gt;&gt; UTIL_EST_WEIGHT_SHIFT</p>
<p>当前 采样周期只占用到了 (1 / 4) 权重</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>为了更快追踪负载的变化，util_est 作者引入了另一个 feature <code>UTIL_EST_FASTUP</code>, 用来加速 util上升</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sched&#x2F;fair&#x2F;util_est: Implement faster ramp-up EWMA on utilization increases</span><br><span class="line"></span><br><span class="line">The estimated utilization for a task:</span><br><span class="line"></span><br><span class="line">   util_est &#x3D; max(util_avg, est.enqueue, est.ewma)</span><br><span class="line"></span><br><span class="line">is defined based on:</span><br><span class="line"></span><br><span class="line"> - util_avg: the PELT defined utilization</span><br><span class="line"> - est.enqueued: the util_avg at the end of the last activation</span><br><span class="line"> - est.ewma:     a exponential moving average on the est.enqueued samples</span><br><span class="line"></span><br><span class="line">According to this definition, when a task suddenly changes its bandwidth</span><br><span class="line">requirements from small to big, the EWMA will need to collect multiple</span><br><span class="line">samples before converging up to track the new big utilization.</span><br><span class="line"></span><br><span class="line">This slow convergence towards bigger utilization values is not</span><br><span class="line">aligned to the default scheduler behavior, which is to optimize for</span><br><span class="line">performance. Moreover, the est.ewma component fails to compensate for</span><br><span class="line">temporarely utilization drops which spans just few est.enqueued samples.</span><br><span class="line"></span><br><span class="line">To let util_est do a better job in the scenario depicted above, change</span><br><span class="line">its definition by making util_est directly follow upward motion and</span><br><span class="line">only decay the est.ewma on downward.</span><br></pre></td></tr></table></figure>

<p>主要改动是这里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--- a&#x2F;kernel&#x2F;sched&#x2F;fair.c</span><br><span class="line">+++ b&#x2F;kernel&#x2F;sched&#x2F;fair.c</span><br><span class="line">@@ -3768,11 +3768,22 @@ util_est_dequeue(struct cfs_rq *cfs_rq, struct task_struct *p, bool task_sleep)</span><br><span class="line">        if (ue.enqueued &amp; UTIL_AVG_UNCHANGED)</span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">+       &#x2F;*</span><br><span class="line">+        * Reset EWMA on utilization increases, the moving average is used only</span><br><span class="line">+        * to smooth utilization decreases.</span><br><span class="line">+        *&#x2F;</span><br><span class="line">+       ue.enqueued &#x3D; (task_util(p) | UTIL_AVG_UNCHANGED);</span><br><span class="line">+       if (sched_feat(UTIL_EST_FASTUP)) &#123;</span><br><span class="line">+               if (ue.ewma &lt; ue.enqueued) &#123;</span><br><span class="line">+                       ue.ewma &#x3D; ue.enqueued;</span><br><span class="line">+                       goto done;</span><br><span class="line">+               &#125;</span><br><span class="line">+       &#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>
<p>开启 <code>UTIL_EST_FASTUP</code> 之后， 如果检测到 ewma(t-1) &lt; .enqueued 直接用当前的 负载util 替换掉<br>历史负载 ewma.</p>
<p>这样task 在 <code>small_to_big</code> 的时候可以更快的跟踪负载，从而更好地 调频与 升核。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-30T11:00:00.000Z" title="4/30/2021, 7:00:00 PM">2021-04-30</time>发表</span><span class="level-item"><time dateTime="2021-11-16T02:55:19.584Z" title="11/16/2021, 10:55:19 AM">2021-11-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/schedule/">schedule</a></span><span class="level-item">5 分钟读完 (大约729个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/30/schedule/HW/vip_thread/">vip_thread</a></h1><div class="content"><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在手机场景中，总有些进程对用户体验是相对其他进程来说高很多的，比如UI线程等，一旦调度不及时，就会给用户造成手机很卡的感觉，所以我们必须识别处这样的vip进程，然后给予更高的待遇，这是几种可行方案：</p>
<ul>
<li>识别出 vip thread，然后来设置为 rt调度策略</li>
<li>识别出 vip thread, 动态给予很小的nice值，使得运行更多</li>
<li>识别出 vip thread, 修改 vruntime 的值，使得运行更多</li>
<li>识别出 vip thread, 给 cfs 中也添加 类似 rt的硬优先级</li>
</ul>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>识别出 vip thread，然后来设置为 rt调度策略<br>优点：可以快速得到运行<br>缺点：可能会抢占系统中本身的rt进程；但是rt的 thread可以抢占，会导致后面加入的进程反而会强占之前的进程</p>
<h3 id="方案二和三"><a href="#方案二和三" class="headerlink" title="方案二和三"></a>方案二和三</h3><p>识别出 vip thread, 动态给予很小的nice值 or 修改 vruntime的值，使得运行更多<br>优点：可以使得vip thread 运行的更久一点<br>缺点：但是可能延迟较大，不能立刻投入运行</p>
<h3 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h3><p>识别出 vip thread, 给 cfs 中也添加 类似 rt的硬优先级<br>优点：相对于方案一来说，不会抢占系统中原油的 rt 进程；相对于方案二来说，实时性会大大提高<br>缺点：需要自己扩展 cfs调度类</p>
<h2 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h2><p>vip_thread 方案主要分为 <code>识别vip_thread</code> <code>vip_thread 数据结构怎么组织</code> <code>vip_thread怎么调度</code> <code>vip_thread 对资源的依赖</code></p>
<h3 id="识别-vip-thread"><a href="#识别-vip-thread" class="headerlink" title="识别 vip_thread"></a>识别 vip_thread</h3><p>如何识别 <code>vip_thread</code> 是一切的开始，vip_thread 定义是和用户体验及其相关的进程，主要是UI线程，<code>kernel</code> 自身很难感知到，但是 <code>framework</code>层是可以感知到的，直接提供<code>proc</code> 节点出去给framework 来帮助识别 vip_thread</p>
<h3 id="vip-thread-数据结构怎么组织"><a href="#vip-thread-数据结构怎么组织" class="headerlink" title="vip_thread 数据结构怎么组织"></a>vip_thread 数据结构怎么组织</h3><p>被识别成为<code>vip_thread</code> 的进程主要是 ui进程，在安卓中的调度策略都是cfs，所以将 <code>vip_thread</code> 的相关数据结构添加到 <code>cfs_rq</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_HW_VIP_THREAD</span><br><span class="line">	&#x2F;*task list for vip thread*&#x2F;</span><br><span class="line">	struct list_head vip_thread_list;</span><br><span class="line">	int active_vip_balance;</span><br><span class="line">	struct cpu_stop_work vip_balance_work;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>当前为了实现简单，将 vip_thread 以 链表数据结构链接到 <code>vip_thread_list</code> 中，<br><code>active_vip_balance</code> 表明此 rq 是否正在做 vip_thread 的 <code>load_balance</code>，<br><code>vip_balance_work</code> 是 load_balance 的 work结构。</p>
<p>还需要在 <code>struct task_struct</code> 中添加如下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_HW_VIP_THREAD</span><br><span class="line">	int static_vip;</span><br><span class="line">	int vip_depth;</span><br><span class="line">	atomic64_t dynamic_vip;</span><br><span class="line">	struct list_head vip_entry;</span><br><span class="line">	u64 enqueue_time;</span><br><span class="line">	u64 dynamic_vip_start;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>




<h3 id="vip-thread-怎么调度"><a href="#vip-thread-怎么调度" class="headerlink" title="vip_thread 怎么调度"></a>vip_thread 怎么调度</h3><p>参考<a target="_blank" rel="noopener" href="https://consumer.huawei.com/en/opensource/detail/?siteCode=worldwidw?productCode=Smartphones&fileType=openSourceSoftware&pageSize=10">HW_P50_888_Code</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-30T11:00:00.000Z" title="4/30/2021, 7:00:00 PM">2021-04-30</time>发表</span><span class="level-item"><time dateTime="2021-05-18T09:28:05.668Z" title="5/18/2021, 5:28:05 PM">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/QCOM/">QCOM</a></span><span class="level-item">几秒读完 (大约0个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/30/schedule/Qcom%20kernel/core_ctl/">core_ctl</a></h1><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-30T11:00:00.000Z" title="4/30/2021, 7:00:00 PM">2021-04-30</time>发表</span><span class="level-item"><time dateTime="2021-05-18T09:28:05.668Z" title="5/18/2021, 5:28:05 PM">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">1 分钟读完 (大约204个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/30/schedule/fair/">fair</a></h1><div class="content"><h2 id="reweight-entity"><a href="#reweight-entity" class="headerlink" title="reweight_entity"></a>reweight_entity</h2><p>sched_init()-&gt;|<br>              |-&gt;set_load_weight(p, false)<br>sched_fork()-&gt;|</p>
<p>set_user_nice()———&gt;|<br>                         |-&gt;set_load_weight(p, true)-&gt;reweight_task()-&gt;reweight_entity()<br>__setscheduler_params()-&gt;|</p>
<p>只会在 cfs task改变 task nice值 或者 改变调度参数的时候会 调用到 <code>reweight_entity()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se,</span><br><span class="line">			    unsigned long weight, unsigned long runnable)</span><br><span class="line">&#123;</span><br><span class="line">	if (se-&gt;on_rq) &#123;</span><br><span class="line">		&#x2F;* commit outstanding execution time *&#x2F;</span><br><span class="line">		if (cfs_rq-&gt;curr &#x3D;&#x3D; se)</span><br><span class="line">			update_curr(cfs_rq);</span><br><span class="line">		account_entity_dequeue(cfs_rq, se);</span><br><span class="line">		dequeue_runnable_load_avg(cfs_rq, se);</span><br><span class="line">	&#125;</span><br><span class="line">	dequeue_load_avg(cfs_rq, se);</span><br><span class="line"></span><br><span class="line">	se-&gt;runnable_weight &#x3D; runnable;</span><br><span class="line">	update_load_set(&amp;se-&gt;load, weight);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	do &#123;</span><br><span class="line">		u32 divider &#x3D; LOAD_AVG_MAX - 1024 + se-&gt;avg.period_contrib;</span><br><span class="line"></span><br><span class="line">		se-&gt;avg.load_avg &#x3D; div_u64(se_weight(se) * se-&gt;avg.load_sum, divider);</span><br><span class="line">		se-&gt;avg.runnable_load_avg &#x3D;</span><br><span class="line">			div_u64(se_runnable(se) * se-&gt;avg.runnable_load_sum, divider);</span><br><span class="line">	&#125; while (0);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	enqueue_load_avg(cfs_rq, se);</span><br><span class="line">	if (se-&gt;on_rq) &#123;</span><br><span class="line">		account_entity_enqueue(cfs_rq, se);</span><br><span class="line">		enqueue_runnable_load_avg(cfs_rq, se);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于重新计算 load_weight，所以需要 xx_dequeue() and xx_enqueue()。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-28T11:00:00.000Z" title="4/28/2021, 7:00:00 PM">2021-04-28</time>发表</span><span class="level-item"><time dateTime="2021-05-18T09:28:05.664Z" title="5/18/2021, 5:28:05 PM">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/QCOM/">QCOM</a></span><span class="level-item">8 分钟读完 (大约1243个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/28/schedule/Qcom%20kernel/boost/">boost</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p>Scheduler boost 是一个机制：将task放到capacity比自己需求大很多 cpu上的机制，<br>开启 <code>boost</code> 的entity也需要为他结束负责。</p>
<p>boost机制 主要是给上层 or framework层写文件节点的，改变<code>boost机制</code>，是<code>整个系统生效的</code>，并不是针对于某单个thread。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scheduler boost is a mechanism to temporarily place tasks on CPUs</span><br><span class="line">with higher capacity than those where a task would have normally</span><br><span class="line">ended up with their load characteristics. Any entity enabling</span><br><span class="line">boost is responsible for disabling it as well.</span><br></pre></td></tr></table></figure>


<h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h2><h2 id="boost-基本概念"><a href="#boost-基本概念" class="headerlink" title="boost 基本概念"></a>boost 基本概念</h2><p>boost type 分为以下几种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define NO_BOOST 0</span><br><span class="line">#define FULL_THROTTLE_BOOST 1</span><br><span class="line">#define CONSERVATIVE_BOOST 2</span><br><span class="line">#define RESTRAINED_BOOST 3</span><br><span class="line">#define FULL_THROTTLE_BOOST_DISABLE -1</span><br><span class="line">#define CONSERVATIVE_BOOST_DISABLE -2</span><br><span class="line">#define RESTRAINED_BOOST_DISABLE -3</span><br><span class="line">#define MAX_NUM_BOOST_TYPE (RESTRAINED_BOOST+1)</span><br></pre></td></tr></table></figure>

<p>可以通过<code>sched_boost()</code>获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern unsigned int sched_boost_type;</span><br><span class="line">static inline int sched_boost(void)</span><br><span class="line">&#123;</span><br><span class="line">	return sched_boost_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>boost policy 分为以下几种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum sched_boost_policy &#123;</span><br><span class="line">	SCHED_BOOST_NONE,</span><br><span class="line">	SCHED_BOOST_ON_BIG,</span><br><span class="line">	SCHED_BOOST_ON_ALL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>sched_boost_policy()</code>获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern enum sched_boost_policy boost_policy;</span><br><span class="line">static inline enum sched_boost_policy sched_boost_policy(void)</span><br><span class="line">&#123;</span><br><span class="line">	return boost_policy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>每个boost type有相关的<code>enter</code>，<code>exit</code>方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct sched_boost_data &#123;</span><br><span class="line">	int refcount;</span><br><span class="line">	void (*enter)(void);</span><br><span class="line">	void (*exit)(void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct sched_boost_data sched_boosts[] &#x3D; &#123;</span><br><span class="line">	[NO_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_no_boost_nop,</span><br><span class="line">		.exit &#x3D; sched_no_boost_nop,</span><br><span class="line">	&#125;,</span><br><span class="line">	[FULL_THROTTLE_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_full_throttle_boost_enter,</span><br><span class="line">		.exit &#x3D; sched_full_throttle_boost_exit,</span><br><span class="line">	&#125;,</span><br><span class="line">	[CONSERVATIVE_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_conservative_boost_enter,</span><br><span class="line">		.exit &#x3D; sched_conservative_boost_exit,</span><br><span class="line">	&#125;,</span><br><span class="line">	[RESTRAINED_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_restrained_boost_enter,</span><br><span class="line">		.exit &#x3D; sched_restrained_boost_exit,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p>写<code>/proc</code> 文件节点 最后调用到<code>sched_boost_handler()</code>–&gt;<code>_sched_set_boost()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void _sched_set_boost(int type)</span><br><span class="line">&#123;</span><br><span class="line">	if (type &#x3D;&#x3D; 0)</span><br><span class="line">		sched_boost_disable_all();</span><br><span class="line">	else if (type &gt; 0)</span><br><span class="line">		sched_boost_enable(type);</span><br><span class="line">	else</span><br><span class="line">		sched_boost_disable(-type);</span><br><span class="line"></span><br><span class="line">	sched_boost_type &#x3D; sched_effective_boost();</span><br><span class="line">	sysctl_sched_boost &#x3D; sched_boost_type;</span><br><span class="line">	set_boost_policy(sysctl_sched_boost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sched_boost_handler(struct ctl_table *table, int write,</span><br><span class="line">		void __user *buffer, size_t *lenp,</span><br><span class="line">		loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	mutex_lock(&amp;boost_mutex);</span><br><span class="line">	_sched_set_boost(*data);</span><br><span class="line">done:</span><br><span class="line">	mutex_unlock(&amp;boost_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_sched_set_boost(int type) type可能是以下一种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define NO_BOOST 0</span><br><span class="line">#define FULL_THROTTLE_BOOST 1</span><br><span class="line">#define CONSERVATIVE_BOOST 2</span><br><span class="line">#define RESTRAINED_BOOST 3</span><br><span class="line">#define FULL_THROTTLE_BOOST_DISABLE -1</span><br><span class="line">#define CONSERVATIVE_BOOST_DISABLE -2</span><br><span class="line">#define RESTRAINED_BOOST_DISABLE -3</span><br></pre></td></tr></table></figure>
<p>type == NO_BOOST ==&gt; disable all<br>type &gt; NO_BOOST ==&gt; enable one boost<br>type &lt; NO_BOOST ==&gt; disable one boost</p>
<p>sched_boosts 使用了refcount机制，已经开启的boost_type的 <code>refcount &gt; 0</code>，如果使能多个<code>boost type</code>，则哪个值大，生效哪个，可以重复开启某一个type的 boost，由于有refcount，所以也需要多次disable。</p>
<p><code>sched_boost_disable_all()</code>，直接调用所有<code>refcount &gt; 0</code>的 boost type的 <code>.exit()</code>方法，然后 <code>refcount = 0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void sched_boost_disable_all(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; SCHED_BOOST_START; i &lt; SCHED_BOOST_END; i++) &#123;</span><br><span class="line">		if (sched_boosts[i].refcount &gt; 0) &#123;</span><br><span class="line">			sched_boosts[i].exit();</span><br><span class="line">			sched_boosts[i].refcount &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sched_boost_enable()</code> 首先<code>refcount++</code>，最终调用到 <code>.enter()</code>方法然后实现enable。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void sched_boost_enable(int type)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_boost_data *sb &#x3D; &amp;sched_boosts[type];</span><br><span class="line">	int next_boost, prev_boost &#x3D; sched_boost_type;</span><br><span class="line"></span><br><span class="line">	sb-&gt;refcount++;</span><br><span class="line"></span><br><span class="line">	if (sb-&gt;refcount !&#x3D; 1) &#x2F;&#x2F; 如果已经处于这种模式了，那就直接返回</span><br><span class="line">		return;</span><br><span class="line">	next_boost &#x3D; sched_effective_boost();</span><br><span class="line">	if (next_boost &#x3D;&#x3D; prev_boost)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	sched_boosts[prev_boost].exit();</span><br><span class="line">	sched_boosts[next_boost].enter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boost-type实现"><a href="#boost-type实现" class="headerlink" title="boost type实现"></a>boost type实现</h2><p>针对于每种<code>boost type</code>，Q实现了其 <code>struct sched_boost_data</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sched_boost_data &#123;</span><br><span class="line">	int refcount;</span><br><span class="line">	void (*enter)(void);</span><br><span class="line">	void (*exit)(void);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="NO-BOOST"><a href="#NO-BOOST" class="headerlink" title="NO_BOOST"></a>NO_BOOST</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct sched_boost_data sched_boosts[] &#x3D; &#123;</span><br><span class="line">	[NO_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_no_boost_nop,</span><br><span class="line">		.exit &#x3D; sched_no_boost_nop,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sched_no_boost_nop() 就是 nop空函数</p>
<h3 id="FULL-THROTTLE-BOOST"><a href="#FULL-THROTTLE-BOOST" class="headerlink" title="FULL_THROTTLE_BOOST"></a>FULL_THROTTLE_BOOST</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct sched_boost_data sched_boosts[] &#x3D; &#123;</span><br><span class="line">	[FULL_THROTTLE_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_full_throttle_boost_enter,</span><br><span class="line">		.exit &#x3D; sched_full_throttle_boost_exit,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>.enter()</code> <code>.exit()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void sched_full_throttle_boost_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">	core_ctl_set_boost(true); &#x2F;&#x2F; 与 core_ctl强相关，后面再看</span><br><span class="line">	walt_enable_frequency_aggregation(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void sched_full_throttle_boost_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	core_ctl_set_boost(false);</span><br><span class="line">	walt_enable_frequency_aggregation(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSERVATIVE-BOOST"><a href="#CONSERVATIVE-BOOST" class="headerlink" title="CONSERVATIVE_BOOST"></a>CONSERVATIVE_BOOST</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct sched_boost_data sched_boosts[] &#x3D; &#123;</span><br><span class="line">	[CONSERVATIVE_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_conservative_boost_enter,</span><br><span class="line">		.exit &#x3D; sched_conservative_boost_exit,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>.enter()</code> <code>.exit()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void sched_conservative_boost_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">	update_cgroup_boost_settings();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void sched_conservative_boost_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	restore_cgroup_boost_settings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RESTRAINED-BOOST"><a href="#RESTRAINED-BOOST" class="headerlink" title="RESTRAINED_BOOST"></a>RESTRAINED_BOOST</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct sched_boost_data sched_boosts[] &#x3D; &#123;</span><br><span class="line">	[RESTRAINED_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_restrained_boost_enter,</span><br><span class="line">		.exit &#x3D; sched_restrained_boost_exit,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>.enter()</code> <code>.exit()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void sched_restrained_boost_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">	walt_enable_frequency_aggregation(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void sched_restrained_boost_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	walt_enable_frequency_aggregation(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Full throttle： FULL_THROTTLE_BOOST</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、通过core control，将所有cpu都进行unisolation</span><br><span class="line">2、通过freq聚合，将load计算放大。从而触发提升freq，或者迁移等</span><br><span class="line">3、通过设置boost policy&#x3D; SCHED_BOOST_ON_BIG，迁移挑选target cpu时，只会选择大核</span><br><span class="line">最终效果应该尽可能把任务都放在大核运行（除了cpuset中有限制）</span><br></pre></td></tr></table></figure>

<p>Conservative： CONSERVATIVE_BOOST</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、通过更新group boost配置，仅让top-app和foreground组进行task placement boost</span><br><span class="line">2、提高min_task_util的门限，让进行up migrate的条件更苛刻。只有load较大（&gt;1ms）的task，会进行up migrate。</span><br><span class="line">2、同上，更改min_task_util门限后，会提醒系统task与cpu是misfit，需要进行迁移。</span><br><span class="line">3、通过设置boost policy&#x3D; SCHED_BOOST_ON_BIG，迁移挑选target cpu时，只会选择大核</span><br><span class="line">最终效果：top-app和foreground的一些task会迁移到大核运行</span><br></pre></td></tr></table></figure>

<p>Restrained： RESTRAINED_BOOST</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、通过freq聚合，将load计算放大。从而触发提升freq，或者迁移等</span><br><span class="line">load放大后，仍遵循基本EAS。提升freq或者迁移，视情况而定。</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-28T11:00:00.000Z" title="4/28/2021, 7:00:00 PM">2021-04-28</time>发表</span><span class="level-item"><time dateTime="2021-05-18T09:28:05.668Z" title="5/18/2021, 5:28:05 PM">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/QCOM/">QCOM</a></span><span class="level-item">12 分钟读完 (大约1823个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/28/schedule/Qcom%20kernel/walt/">walt</a></h1><div class="content"><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h2><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p>walt (Windows Assisted load tracking–窗口协助负载跟踪算法)，主要是跟踪过去一段时间内 entity，rq的负载，给++调频、预测负载、负载均衡++ 等一些调度行为提供一些参考。</p>
<h2 id="walt-数据结构"><a href="#walt-数据结构" class="headerlink" title="walt 数据结构"></a>walt 数据结构</h2><p><code>struct walt_task_struct</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">struct walt_task_struct &#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * &#39;mark_start&#39; marks the beginning of an event (task waking up, task</span><br><span class="line">	 * starting to execute, task being preempted) within a window</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;sum&#39; represents how runnable a task has been within current</span><br><span class="line">	 * window. It incorporates both running time and wait time and is</span><br><span class="line">	 * frequency scaled.</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;sum_history&#39; keeps track of history of &#39;sum&#39; seen over previous</span><br><span class="line">	 * RAVG_HIST_SIZE windows. Windows where task was entirely sleeping are</span><br><span class="line">	 * ignored.</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;demand&#39; represents maximum sum seen over previous</span><br><span class="line">	 * sysctl_sched_ravg_hist_size windows. &#39;demand&#39; could drive frequency</span><br><span class="line">	 * demand for tasks.</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;curr_window_cpu&#39; represents task&#39;s contribution to cpu busy time on</span><br><span class="line">	 * various CPUs in the current window</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;prev_window_cpu&#39; represents task&#39;s contribution to cpu busy time on</span><br><span class="line">	 * various CPUs in the previous window</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;curr_window&#39; represents the sum of all entries in curr_window_cpu</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;prev_window&#39; represents the sum of all entries in prev_window_cpu</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;pred_demand&#39; represents task&#39;s current predicted cpu busy time</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;busy_buckets&#39; groups historical busy time into different buckets</span><br><span class="line">	 * used for prediction</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;demand_scaled&#39; represents task&#39;s demand scaled to 1024</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	u64				mark_start; &#x2F;&#x2F; beginning of events(task start executing or waking up)</span><br><span class="line">	u32				sum; &#x2F;&#x2F; runnable time within a window</span><br><span class="line">	u32				demand; &#x2F;&#x2F; max sum in past serval(sysctl_sched_ravg_hist_size &#x3D;&#x3D; 5) windows</span><br><span class="line">	u32				coloc_demand;</span><br><span class="line">	u32				sum_history[RAVG_HIST_SIZE_MAX];</span><br><span class="line">	u32				*curr_window_cpu, *prev_window_cpu;</span><br><span class="line">	u32				curr_window, prev_window;</span><br><span class="line">	u32				pred_demand;</span><br><span class="line">	u8				busy_buckets[NUM_BUSY_BUCKETS];</span><br><span class="line">	u16				demand_scaled;</span><br><span class="line">	u16				pred_demand_scaled;</span><br><span class="line">	u64				active_time;</span><br><span class="line">	int				boost;</span><br><span class="line">	bool				wake_up_idle;</span><br><span class="line">	bool				misfit;</span><br><span class="line">	bool				rtg_high_prio;</span><br><span class="line">	u8				low_latency;</span><br><span class="line">	u64				boost_period;</span><br><span class="line">	u64				boost_expires;</span><br><span class="line">	u64				last_sleep_ts;</span><br><span class="line">	u32				init_load_pct;</span><br><span class="line">	u32				unfilter;</span><br><span class="line">	u64				last_wake_ts;</span><br><span class="line">	u64				last_enqueued_ts;</span><br><span class="line">	struct walt_related_thread_group __rcu	*grp;</span><br><span class="line">	struct list_head		grp_list;</span><br><span class="line">	u64				cpu_cycles;</span><br><span class="line">	cpumask_t			cpus_requested;</span><br><span class="line">	bool				iowaited;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct task_struct &#123;</span><br><span class="line">	......</span><br><span class="line">	struct sched_entity		se;</span><br><span class="line">	struct sched_rt_entity		rt;</span><br><span class="line">#ifdef CONFIG_SCHED_WALT</span><br><span class="line">	struct walt_task_struct		wts;</span><br><span class="line">#endif</span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><code>struct walt_rq</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct walt_rq &#123;</span><br><span class="line">	struct task_struct	*push_task;</span><br><span class="line">	struct walt_sched_cluster *cluster;</span><br><span class="line">	struct cpumask		freq_domain_cpumask;</span><br><span class="line">	struct walt_sched_stats walt_stats;</span><br><span class="line"></span><br><span class="line">	u64			window_start;</span><br><span class="line">	u32			prev_window_size;</span><br><span class="line">	unsigned long		walt_flags;</span><br><span class="line"></span><br><span class="line">	u64			avg_irqload;</span><br><span class="line">	u64			last_irq_window;</span><br><span class="line">	u64			prev_irq_time;</span><br><span class="line">	struct task_struct	*ed_task;</span><br><span class="line">	u64			task_exec_scale;</span><br><span class="line">	u64			old_busy_time;</span><br><span class="line">	u64			old_estimated_time;</span><br><span class="line">	u64			curr_runnable_sum;</span><br><span class="line">	u64			prev_runnable_sum;</span><br><span class="line">	u64			nt_curr_runnable_sum;</span><br><span class="line">	u64			nt_prev_runnable_sum;</span><br><span class="line">	u64			cum_window_demand_scaled;</span><br><span class="line">	struct group_cpu_time	grp_time;</span><br><span class="line">	struct load_subtractions load_subs[NUM_TRACKED_WINDOWS];</span><br><span class="line">	DECLARE_BITMAP_ARRAY(top_tasks_bitmap,</span><br><span class="line">			NUM_TRACKED_WINDOWS, NUM_LOAD_INDICES);</span><br><span class="line">	u8			*top_tasks[NUM_TRACKED_WINDOWS];</span><br><span class="line">	u8			curr_table;</span><br><span class="line">	int			prev_top;</span><br><span class="line">	int			curr_top;</span><br><span class="line">	bool			notif_pending;</span><br><span class="line">	bool			high_irqload;</span><br><span class="line">	u64			last_cc_update;</span><br><span class="line">	u64			cycles;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct rq &#123;</span><br><span class="line">#ifdef CONFIG_SCHED_WALT</span><br><span class="line">	struct walt_rq		wrq;</span><br><span class="line">#endif &#x2F;* CONFIG_SCHED_WALT *&#x2F;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










<h2 id="walt-api使用"><a href="#walt-api使用" class="headerlink" title="walt api使用"></a>walt api使用</h2><ol>
<li><p>init</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void walt_sched_init_rq(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	int j;</span><br><span class="line"></span><br><span class="line">	if (cpu_of(rq) &#x3D;&#x3D; 0)</span><br><span class="line">		walt_init_once();</span><br><span class="line"></span><br><span class="line">	cpumask_set_cpu(cpu_of(rq), &amp;rq-&gt;wrq.freq_domain_cpumask);</span><br><span class="line"></span><br><span class="line">	rq-&gt;wrq.walt_stats.cumulative_runnable_avg_scaled &#x3D; 0;</span><br><span class="line">	rq-&gt;wrq.prev_window_size &#x3D; sched_ravg_window;</span><br><span class="line">	rq-&gt;wrq.window_start &#x3D; 0;</span><br><span class="line">	rq-&gt;wrq.walt_stats.nr_big_tasks &#x3D; 0;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __init sched_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">	for_each_possible_cpu(i) &#123;</span><br><span class="line">		struct rq *rq;</span><br><span class="line"> 		walt_sched_init_rq(rq);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>set_start()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void set_window_start(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	static int sync_cpu_available;</span><br><span class="line"></span><br><span class="line">	if (likely(rq-&gt;wrq.window_start))</span><br><span class="line">		return;</span><br><span class="line">	if (!sync_cpu_available) &#123;</span><br><span class="line">		rq-&gt;wrq.window_start &#x3D; 1;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>‘</p>
</li>
<li><p>a</p>
</li>
<li></li>
</ol>
<h3 id="WALT-TIME"><a href="#WALT-TIME" class="headerlink" title="WALT TIME"></a>WALT TIME</h3><p>由于存在多个cluster，不同 cluster的频率 和架构都不一样，所以同一 task在不同 cluster上运行，<br>需要的时间是不一样的。为了更好衡量一个 task的负载或者需求，我们必须考虑 cpu freq 和 ipc的差异，<br>所以需要将不同cpu 上运行的task时间 归一化 到同一个度量尺子上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; delta 是 task实际 运行时间</span><br><span class="line">&#x2F;&#x2F; task_exec_scale 是task 执行时间的 刻度，每次在 update_task_rq_cpu_cycles 中更新</span><br><span class="line">static inline u64 scale_exec_time(u64 delta, struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	return (delta * rq-&gt;wrq.task_exec_scale) &gt;&gt; 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned long topology_get_cpu_scale(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	return per_cpu(cpu_scale, cpu);</span><br><span class="line">&#125;</span><br><span class="line">#define arch_scale_cpu_capacity topology_get_cpu_scale</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">update_task_rq_cpu_cycles(struct task_struct *p, struct rq *rq, int event,</span><br><span class="line">			  u64 wallclock, u64 irqtime)</span><br><span class="line">&#123;</span><br><span class="line">      rq-&gt;wrq.task_exec_scale &#x3D; DIV64_U64_ROUNDUP(cpu_cur_freq(cpu) *</span><br><span class="line">         	arch_scale_cpu_capacity(cpu),</span><br><span class="line">         	rq-&gt;wrq.cluster-&gt;max_possible_freq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>        cur_freq</code></pre>
<p>task_exec_scale  =    ———— * scale_capacity<br>            max_freq</p>
<pre><code>            cur_freq</code></pre>
<p>scale_exec_time  =  delta *   ———— * scale_capacity<br>                max_freq</p>
<p><code>scale_capacity</code> 是driver 初始化的时候设置的。</p>
<h3 id="WALT-update"><a href="#WALT-update" class="headerlink" title="WALT update"></a>WALT update</h3><p><code>walt_update_task_ravg()</code> 是 walt的最主要输入，在各种<code>event</code> 下更新负载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">enum task_event &#123;</span><br><span class="line">	PUT_PREV_TASK   &#x3D; 0,</span><br><span class="line">	PICK_NEXT_TASK  &#x3D; 1,</span><br><span class="line">	TASK_WAKE       &#x3D; 2,</span><br><span class="line">	TASK_MIGRATE    &#x3D; 3,</span><br><span class="line">	TASK_UPDATE     &#x3D; 4,</span><br><span class="line">	IRQ_UPDATE      &#x3D; 5,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* Reflect task activity on its demand and cpu&#39;s busy time statistics *&#x2F;</span><br><span class="line">void walt_update_task_ravg(struct task_struct *p, struct rq *rq, int event,</span><br><span class="line">						u64 wallclock, u64 irqtime)</span><br><span class="line">&#123;</span><br><span class="line">	u64 old_window_start;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; rq没有初始化 or task的 mark_start 与 wallclock相等&#x3D;&#x3D;&gt;刚刚才更新过</span><br><span class="line">	if (!rq-&gt;wrq.window_start || p-&gt;wts.mark_start &#x3D;&#x3D; wallclock)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	old_window_start &#x3D; update_window_start(rq, wallclock, event); &#x2F;&#x2F; 更新 rq-&gt;wrq.window_start，方便后面计算</span><br><span class="line"></span><br><span class="line">	if (!p-&gt;wts.mark_start) &#123;</span><br><span class="line">		update_task_cpu_cycles(p, cpu_of(rq), wallclock);</span><br><span class="line">		goto done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	update_task_rq_cpu_cycles(p, rq, event, wallclock, irqtime); &#x2F;&#x2F; 更新 task_exec_scale</span><br><span class="line">	&#x2F;&#x2F; 更新 task的 demand 和 perd_demand 期望下一个window 的运行时间</span><br><span class="line">	update_task_demand(p, rq, event, wallclock);</span><br><span class="line">	update_cpu_busy_time(p, rq, event, wallclock, irqtime); &#x2F;&#x2F;</span><br><span class="line">	update_task_pred_demand(rq, p, event);</span><br><span class="line">	if (event &#x3D;&#x3D; PUT_PREV_TASK &amp;&amp; p-&gt;state)</span><br><span class="line">		p-&gt;wts.iowaited &#x3D; p-&gt;in_iowait;</span><br><span class="line"></span><br><span class="line">	trace_sched_update_task_ravg(p, rq, event, wallclock, irqtime,</span><br><span class="line">				&amp;rq-&gt;wrq.grp_time);</span><br><span class="line">	trace_sched_update_task_ravg_mini(p, rq, event, wallclock, irqtime,</span><br><span class="line">				&amp;rq-&gt;wrq.grp_time);</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	p-&gt;wts.mark_start &#x3D; wallclock;</span><br><span class="line">&#x2F;&#x2F;	void walt_irq_work(struct irq_work *irq_work)</span><br><span class="line">	run_walt_irq_work(old_window_start, rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面关注<code>update_task_demand()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">static u64 update_task_demand(struct task_struct *p, struct rq *rq,</span><br><span class="line">			       int event, u64 wallclock)</span><br><span class="line">&#123;</span><br><span class="line">	u64 mark_start &#x3D; p-&gt;wts.mark_start;</span><br><span class="line">	u64 delta, window_start &#x3D; rq-&gt;wrq.window_start;</span><br><span class="line">	int new_window, nr_full_windows;</span><br><span class="line">	u32 window_size &#x3D; sched_ravg_window;</span><br><span class="line">	u64 runtime;</span><br><span class="line"></span><br><span class="line">	new_window &#x3D; mark_start &lt; window_start;</span><br><span class="line">	&#x2F;&#x2F; window_start &#x3D; rq-&gt;wrq.window_start 在之前俩函数已经更新过了，</span><br><span class="line">	&#x2F;&#x2F; 正常如果经历了新的window，new_window &#x3D;1</span><br><span class="line">	if (!account_busy_for_task_demand(rq, p, event)) &#123;</span><br><span class="line">		if (new_window)</span><br><span class="line">			&#x2F;*</span><br><span class="line">			 * If the time accounted isn&#39;t being accounted as</span><br><span class="line">			 * busy time, and a new window started, only the</span><br><span class="line">			 * previous window need be closed out with the</span><br><span class="line">			 * pre-existing demand. Multiple windows may have</span><br><span class="line">			 * elapsed, but since empty windows are dropped,</span><br><span class="line">			 * it is not necessary to account those.</span><br><span class="line">			 *&#x2F;</span><br><span class="line">			update_history(rq, p, p-&gt;wts.sum, 1, event);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; case: 没有经历新的window，p-&gt;wts.sum +&#x3D; delta， sum是保存所有不满一个 window的时间</span><br><span class="line">	if (!new_window) &#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * The simple case - busy time contained within the existing</span><br><span class="line">		 * window.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		return add_to_task_demand(rq, p, wallclock - mark_start);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Busy time spans at least two windows. Temporarily rewind</span><br><span class="line">	 * window_start to first window boundary after mark_start.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	delta &#x3D; window_start - mark_start;</span><br><span class="line">	nr_full_windows &#x3D; div64_u64(delta, window_size);</span><br><span class="line">	window_start -&#x3D; (u64)nr_full_windows * (u64)window_size;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Process (window_start - mark_start) first *&#x2F;</span><br><span class="line">	runtime &#x3D; add_to_task_demand(rq, p, window_start - mark_start);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Push new sample(s) into task&#39;s demand history *&#x2F;</span><br><span class="line">	update_history(rq, p, p-&gt;wts.sum, 1, event);</span><br><span class="line">	if (nr_full_windows) &#123;</span><br><span class="line">		u64 scaled_window &#x3D; scale_exec_time(window_size, rq);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 为啥这里没有 add_to_task_demand()? ,因为 更新demand也只是更新 p-&gt;wts.sum， 这里</span><br><span class="line">		&#x2F;&#x2F; 因为涉及多个 window，所以 sum肯定会超过一个window的时间。</span><br><span class="line">		&#x2F;&#x2F; 关注 update_history() 中的 p-&gt;wts.sum &#x3D; 0;</span><br><span class="line">		update_history(rq, p, scaled_window, nr_full_windows, event);</span><br><span class="line">		runtime +&#x3D; nr_full_windows * scaled_window;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Roll window_start back to current to process any remainder</span><br><span class="line">	 * in current window.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	window_start +&#x3D; (u64)nr_full_windows * (u64)window_size;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Process (wallclock - window_start) next *&#x2F;</span><br><span class="line">	mark_start &#x3D; window_start;</span><br><span class="line">	runtime +&#x3D; add_to_task_demand(rq, p, wallclock - mark_start);</span><br><span class="line"></span><br><span class="line">	return runtime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>add_to_task_demand()</code> 只是在 <code>scale-invariant</code>的尺度上将当前运行时间累计到 <code>task-&gt;wts.sum</code>上，<code>update_history()</code> 是 更新 <code>p-&gt;wts.sum_history[5]</code> 这个历史窗口的数据，类似不停地滚动，<code>update_history()</code>参数<code>runtime</code>也是 scale之后的，demand是根据不同的WINDOW_STATS_XXX决定的；然后根据 <code>predict_and_update_buckets()</code> 来预测 perd_demand需求，这里用到了buckets算法（不是重点）。</p>
<p>freq_policy_load() – __cpu_util_freq_walt() – cpu_util_freq_walt() – schedutil 使用此接口去获得 cpu使用率</p>
<h3 id="walt-输出api"><a href="#walt-输出api" class="headerlink" title="walt 输出api"></a>walt 输出api</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task_util()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以can_migrate_task()函数为例：</span><br><span class="line"></span><br><span class="line">通过task_util()获取该task的demand，即task级负载</span><br><span class="line"></span><br><span class="line">cpu_util_cum()获取cpu rq的累计demand，即cpu级负载</span><br><span class="line"></span><br><span class="line">如果 dst_cpu累计demand + task_demand &gt; src_cpu累计demand + task_demand，那么说明不满足迁移条件。</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-24T11:00:00.000Z" title="4/24/2021, 7:00:00 PM">2021-04-24</time>发表</span><span class="level-item"><time dateTime="2021-04-22T06:24:26.660Z" title="4/22/2021, 2:24:26 PM">2021-04-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">18 分钟读完 (大约2771个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/24/schedule/pelt/">pelt</a></h1><div class="content"><p>参考<a target="_blank" rel="noopener" href="http://www.wowotech.net/process_management/450.html">wowo文章</a></p>
<h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h2><p>为了让调度器更加的聪明，我们总是希望系统满足最大吞吐量同时又最大限度的降低功耗。虽然可能有些矛盾，但是现实总是这样。PELT算法是Linux 3.8合入的，那么在此之前，我们存在什么问题才引入PELT算法呢？在Linux 3.8之前，CFS以每个运行队列（runqueue，简称rq）为基础跟踪负载。但是这种方法，我们无法确定当前负载的来源。同时，即使工作负载相对稳定的情况下，在rq级别跟踪负载，其值也会产生很大变化。为了解决以上的问题，PELT算法会跟踪每个调度实体（per-scheduling entity）的负载情况。</p>
<h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW?"></a>HOW?</h2><p>为了做到Per-entity的负载跟踪，时间（物理时间，不是虚拟时间）被分成了1024us的序列，在每一个1024us的周期中，一个entity对系统负载的贡献可以根据该实体处于runnable状态（正在CPU上运行或者等待cpu调度运行）的时间进行计算。</p>
<p>如果在该周期内，runnable的时间是x，那么对系统负载的贡献就是（x/1024）。当然，一个实体在一个计算周期内的负载可能会超过1024us，这是因为我们会累积在过去周期中的负载，当然，对于过去的负载我们在计算的时候需要乘一个衰减因子。如果我们让Li表示在周期pi中该调度实体的对系统负载贡献，那么一个调度实体对系统负荷的总贡献可以表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L &#x3D; L0 + L1 * y + L2 * y2 + L3 * y3 + ... + Ln * yn</span><br><span class="line"></span><br><span class="line">其中：y32 &#x3D; 0.5, y &#x3D; 0.97857206</span><br></pre></td></tr></table></figure>

<p>如果有一个task，从第一次加入rq后开始一直运行4096us后一直睡眠，那么在1023us、2047us、3071us、4095us、5119us、6143us、7167us和8191us时间的每一个时刻负载贡献分别是多少呢？<br>        /<br>        |<br>       1|———————–|<br>        |                       |<br>       0|                       |——————————————<br>——————————————————————————-&gt;<br>                |       |       |       |       |       |       |       |<br>              1023    2047    4095    5119    7167    8191</p>
<p>可以计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L0 &#x3D; 1023 * y0 &#x3D; 1023</span><br><span class="line">L1 &#x3D; 1023 * y0 + 1024 * y1 &#x3D; 1023 + (L0 + 1) * y &#x3D; 2025</span><br><span class="line">L2 &#x3D; 1023 * y0 + 1024 * y1 + 1024 * y2 &#x3D; 1023 + (L1 + 1) * y1 &#x3D; 3005</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>可以得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ln &#x3D; Load(This)  + Ln-1 * y &#x3D;  当前周期负载 + 上一周期负载 * 衰减系数y</span><br></pre></td></tr></table></figure>

<p>需要经常计算 Ln-1 * y的值，但是内核并不是 简单计算  Ln-1 * y，也可能需要计算<br>Ln-m * ym，kernel中使用decay_laod()函数。<br>为了提高精度和计算速度，采用乘法  和 位移算法进行计算，输入是:</p>
<ol>
<li>val: 前n个负载计算周期的负载</li>
<li>n: 衰减n个周期之后的实际负载<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">decay_load(val, n) &#x3D; val * yn &#x3D; (val * yn) * (232 &gt;&gt;32)</span><br><span class="line">                              &#x3D; val * (yn * 232) &gt;&gt;  32</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>可以看到 yn * 232的值其实是固定的（n确定的情况下是一个数组）<br><code>runnable_avg_yN_inv[n] = yn*232, n &gt; 0 &amp;&amp; n &lt; 32</code><br>kernel中使用了一个数组来保存这些值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static const u32 runnable_avg_yN_inv[] &#x3D; &#123;</span><br><span class="line">	0xffffffff, 0xfa83b2da, 0xf5257d14, 0xefe4b99a, 0xeac0c6e6, 0xe5b906e6,</span><br><span class="line">	0xe0ccdeeb, 0xdbfbb796, 0xd744fcc9, 0xd2a81d91, 0xce248c14, 0xc9b9bd85,</span><br><span class="line">	0xc5672a10, 0xc12c4cc9, 0xbd08a39e, 0xb8fbaf46, 0xb504f333, 0xb123f581,</span><br><span class="line">	0xad583ee9, 0xa9a15ab4, 0xa5fed6a9, 0xa2704302, 0x9ef5325f, 0x9b8d39b9,</span><br><span class="line">	0x9837f050, 0x94f4efa8, 0x91c3d373, 0x8ea4398a, 0x8b95c1e3, 0x88980e80,</span><br><span class="line">	0x85aac367, 0x82cd8698,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是<code>decay_load</code>实际代码：</p>
<ol>
<li>如果衰减周期大于 <code>LOAD_AVG_PERIOD * 63</code>，那么我们认为<code>LOAD_AVG_PERIOD * 63</code>之前的负载val对现在的贡献是 0</li>
<li>如果<code>n &gt;= 32</code>，由于 <code>runnable_avg_yN_inv</code> 只包含了y31的值，所以 必须将n 归一化到 <code>&lt; 32</code>，每归一化一次，负载贡献就减半 (val = val &gt;&gt; 1)</li>
<li>最后衰减的负载是 <code>val * runnable_avg_yN_inv[local_n] &gt;&gt; 32</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Approximate:</span><br><span class="line"> *   val * y^n,    where y^32 ~&#x3D; 0.5 (~1 scheduling period)</span><br><span class="line"> *&#x2F;</span><br><span class="line">static u64 decay_load(u64 val, u64 n)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int local_n;</span><br><span class="line"></span><br><span class="line">	if (unlikely(n &gt; LOAD_AVG_PERIOD * 63))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;* after bounds checking we can collapse to 32-bit *&#x2F;</span><br><span class="line">	local_n &#x3D; n;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * As y^PERIOD &#x3D; 1&#x2F;2, we can combine</span><br><span class="line">	 *    y^n &#x3D; 1&#x2F;2^(n&#x2F;PERIOD) * y^(n%PERIOD)</span><br><span class="line">	 * With a look-up table which covers y^n (n&lt;PERIOD)</span><br><span class="line">	 *</span><br><span class="line">	 * To achieve constant time decay_load.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (unlikely(local_n &gt;&#x3D; LOAD_AVG_PERIOD)) &#123;</span><br><span class="line">		val &gt;&gt;&#x3D; local_n &#x2F; LOAD_AVG_PERIOD;</span><br><span class="line">		local_n %&#x3D; LOAD_AVG_PERIOD;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val &#x3D; mul_u64_u32_shr(val, runnable_avg_yN_inv[local_n], 32);</span><br><span class="line">	return val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="负载信息如何记录？"><a href="#负载信息如何记录？" class="headerlink" title="负载信息如何记录？"></a>负载信息如何记录？</h2><p>首先负载计算是相对于<code>调度实体se 和  就绪队列rq</code>的：<br>对于 <code>struct sched_entity</code>  <code>struct cfs_rq</code> <code>struct rq</code> 结构来说都内嵌了 <code>struct sched_avg</code> 结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">struct sched_avg &#123;</span><br><span class="line">	u64				last_update_time; &#x2F;&#x2F; 上一次负载更新的时间</span><br><span class="line">	u64				load_sum; &#x2F;&#x2F; running + runnable 的负载</span><br><span class="line">	u64				runnable_load_sum;&#x2F;&#x2F; 姑且等于 load_sum</span><br><span class="line">	u32				util_sum; &#x2F;&#x2F; running 的负载</span><br><span class="line">	u32				period_contrib;</span><br><span class="line">	unsigned long			load_avg; &#x2F;&#x2F; running + runnable 的平均负载</span><br><span class="line">	unsigned long			runnable_load_avg; &#x2F;&#x2F; 姑且等于 load_avg</span><br><span class="line">	unsigned long			util_avg; &#x2F;&#x2F; running 的平均负载</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sched_entity &#123;</span><br><span class="line">      	struct load_weight		load;</span><br><span class="line">	unsigned long			runnable_weight;</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Per entity load average tracking.</span><br><span class="line">	 *</span><br><span class="line">	 * Put into separate cache line so it does not</span><br><span class="line">	 * collide with read-mostly values above.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct sched_avg		avg;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cfs_rq &#123;</span><br><span class="line">	struct load_weight	load;</span><br><span class="line">	unsigned long		runnable_weight;</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * CFS load tracking</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct sched_avg	avg;</span><br><span class="line">#ifndef CONFIG_64BIT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct rq &#123;</span><br><span class="line">	&#x2F;* runqueue lock: *&#x2F;</span><br><span class="line">	raw_spinlock_t		lock;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * nr_running and cpu_load should be in the same cacheline because</span><br><span class="line">	 * remote CPUs use both these fields when doing load calculation.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	unsigned int		nr_running;</span><br><span class="line">	struct sched_avg	avg_rt;</span><br><span class="line">	struct sched_avg	avg_dl;</span><br><span class="line">#ifdef CONFIG_HAVE_SCHED_AVG_IRQ</span><br><span class="line">	struct sched_avg	avg_irq;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>通过init可以更清楚知道他们含义，如果<code>se</code>是：</p>
<ol>
<li><code>task</code>，那么 runnable_load_avg = load_avg 都和 se的权重相等</li>
<li><code>group se</code>，runnable_load_avg = load_avg = 0，也反映了此时<code>group se</code>还没有任何任务。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void init_entity_runnable_average(struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_avg *sa &#x3D; &amp;se-&gt;avg;</span><br><span class="line"></span><br><span class="line">	memset(sa, 0, sizeof(*sa));</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Tasks are initialized with full load to be seen as heavy tasks until</span><br><span class="line">	 * they get a chance to stabilize to their real load level.</span><br><span class="line">	 * Group entities are initialized with zero load to reflect the fact that</span><br><span class="line">	 * nothing has been attached to the task group yet.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (entity_is_task(se))</span><br><span class="line">		sa-&gt;runnable_load_avg &#x3D; sa-&gt;load_avg &#x3D; scale_load_down(se-&gt;load.weight);</span><br><span class="line"></span><br><span class="line">	se-&gt;runnable_weight &#x3D; se-&gt;load.weight;</span><br><span class="line"></span><br><span class="line">	&#x2F;* when this task enqueue&#39;ed, it will contribute to its cfs_rq&#39;s load_avg *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="那么如何计算当前se的负载？"><a href="#那么如何计算当前se的负载？" class="headerlink" title="那么如何计算当前se的负载？"></a>那么如何计算当前se的负载？</h2><p>假设一个task从0时刻一直开始运行，在1022us时刻负载是多少？<br>由于还没有之前运行周期可以凑满1024us 一个衰减周期，所以负载是1022，<br>又运行了10us之后负载应该如何计算？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L  &#x3D; (10 - (1024 - 1022)) +(1024 - 1022 + 1022)y</span><br><span class="line">   &#x3D; (10 -2) + (1022 + 2) * y1</span><br><span class="line">   &#x3D; 8 +  1024 *  y1</span><br></pre></td></tr></table></figure>

<p>假设上一时刻负载贡献是u，经历d时间后的负载贡献如何计算呢？根据上面的例子，我们可以把时间d分成3和部分：<br>d1是离当前时间最远（不完整的）period 的剩余部分，d2 是完整period时间，而d3是（不完整的）当前 period 的剩余部分。<br>假设时间d是经过p个周期（d=d1+d2+d3, p=1+d2/1024）。d1，d2，d3 的示意图如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">      d1          d2           d3</span><br><span class="line">      ^           ^            ^</span><br><span class="line">      |           |            |</span><br><span class="line">    |&lt;-&gt;|&lt;-----------------&gt;|&lt;---&gt;|</span><br><span class="line">|---x---|------| ... |------|-----x (now)</span><br><span class="line">    |</span><br><span class="line">   u时刻</span><br><span class="line"></span><br><span class="line">u&#39;  &#x3D; (u + d1) y^p + 1024 * (y^1 + y^2 + ...  + y^p-1) + d3 * y^0</span><br><span class="line">                           p-1</span><br><span class="line">    &#x3D; (u + d1) y^p + 1024 \Sum y^n + d3 y^0</span><br><span class="line">                           n&#x3D;1</span><br><span class="line"></span><br><span class="line">    &#x3D; u y^p +                                 ---&gt; Step1</span><br><span class="line">                     p-1</span><br><span class="line">    &#x3D; d1 y^p + 1024 \Sum y^n + d3 y^0         ---&gt; Step2</span><br><span class="line">                     n&#x3D;1</span><br></pre></td></tr></table></figure>


<p>kernel中是用 <code>accumulate_sum()</code> 实现这个当前时刻负载计算的</p>
<ol>
<li>period_contrib记录的是上次更新负载不足1024us周期的时间。delta是经过的时间，为了计算经过的周期个数需要加上period_contrib，然后整除1024。</li>
<li>计算周期个数</li>
<li>调用decay_load()函数计算公式中的step1部分</li>
<li>__accumulate_pelt_segments()负责计算公式step2部分</li>
<li>更新period_contrib为本次不足1024us部分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">static u32 __accumulate_pelt_segments(u64 periods, u32 d1, u32 d3)</span><br><span class="line">&#123;</span><br><span class="line">	u32 c1, c2, c3 &#x3D; d3; &#x2F;* y^0 &#x3D;&#x3D; 1 *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * c1 &#x3D; d1 y^p</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	c1 &#x3D; decay_load((u64)d1, periods);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 *            p-1</span><br><span class="line">	 * c2 &#x3D; 1024 \Sum y^n</span><br><span class="line">	 *            n&#x3D;1</span><br><span class="line">	 *</span><br><span class="line">	 *              inf        inf</span><br><span class="line">	 *    &#x3D; 1024 ( \Sum y^n - \Sum y^n - y^0 )</span><br><span class="line">	 *              n&#x3D;0        n&#x3D;p</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	c2 &#x3D; LOAD_AVG_MAX - decay_load(LOAD_AVG_MAX, periods) - 1024;</span><br><span class="line"></span><br><span class="line">	return c1 + c2 + c3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Accumulate the three separate parts of the sum; d1 the remainder</span><br><span class="line"> * of the last (incomplete) period, d2 the span of full periods and d3</span><br><span class="line"> * the remainder of the (incomplete) current period.</span><br><span class="line"> *</span><br><span class="line"> *           d1          d2           d3</span><br><span class="line"> *           ^           ^            ^</span><br><span class="line"> *           |           |            |</span><br><span class="line"> *         |&lt;-&gt;|&lt;-----------------&gt;|&lt;---&gt;|</span><br><span class="line"> * ... |---x---|------| ... |------|-----x (now)</span><br><span class="line"> *</span><br><span class="line"> *                           p-1</span><br><span class="line"> * u&#39; &#x3D; (u + d1) y^p + 1024 \Sum y^n + d3 y^0</span><br><span class="line"> *                           n&#x3D;1</span><br><span class="line"> *</span><br><span class="line"> *    &#x3D; u y^p +					(Step 1)</span><br><span class="line"> *</span><br><span class="line"> *                     p-1</span><br><span class="line"> *      d1 y^p + 1024 \Sum y^n + d3 y^0		(Step 2)</span><br><span class="line"> *                     n&#x3D;1</span><br><span class="line"> *&#x2F;</span><br><span class="line">static __always_inline u32</span><br><span class="line">accumulate_sum(u64 delta, struct sched_avg *sa,</span><br><span class="line">	       unsigned long load, unsigned long runnable, int running)</span><br><span class="line">&#123;</span><br><span class="line">	u32 contrib &#x3D; (u32)delta; &#x2F;* p &#x3D;&#x3D; 0 -&gt; delta &lt; 1024 *&#x2F;</span><br><span class="line">	u64 periods;</span><br><span class="line"></span><br><span class="line">	delta +&#x3D; sa-&gt;period_contrib;</span><br><span class="line">	periods &#x3D; delta &#x2F; 1024; &#x2F;* A period is 1024us (~1ms) *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Step 1: decay old *_sum if we crossed period boundaries.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (periods) &#123;</span><br><span class="line">		sa-&gt;load_sum &#x3D; decay_load(sa-&gt;load_sum, periods);</span><br><span class="line">		sa-&gt;runnable_load_sum &#x3D;</span><br><span class="line">			decay_load(sa-&gt;runnable_load_sum, periods);</span><br><span class="line">		sa-&gt;util_sum &#x3D; decay_load((u64)(sa-&gt;util_sum), periods);</span><br><span class="line"></span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * Step 2</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		delta %&#x3D; 1024;</span><br><span class="line">		contrib &#x3D; __accumulate_pelt_segments(periods,</span><br><span class="line">				1024 - sa-&gt;period_contrib, delta);</span><br><span class="line">	&#125;</span><br><span class="line">	sa-&gt;period_contrib &#x3D; delta;</span><br><span class="line"></span><br><span class="line">	if (load)</span><br><span class="line">		sa-&gt;load_sum +&#x3D; load * contrib;</span><br><span class="line">	if (runnable)</span><br><span class="line">		sa-&gt;runnable_load_sum +&#x3D; runnable * contrib;</span><br><span class="line">	if (running)</span><br><span class="line">		sa-&gt;util_sum +&#x3D; contrib &lt;&lt; SCHED_CAPACITY_SHIFT;</span><br><span class="line"></span><br><span class="line">	return periods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p>其中 <code>___update_load_sum()</code> 函数 计算的都是<em>sum</em>负载总和，函数返回值是</p>
<ol>
<li>0，如果和上次更新时间之间 没有 经历过一次完整的period</li>
<li>1，如果和上次更新时间之间 经历过一次完整的period</li>
</ol>
<p>如果经历过一个 <code>full period</code>之后，就需要更新 <code>load_avg</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline void</span><br><span class="line">___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)</span><br><span class="line">&#123;</span><br><span class="line">	u32 divider &#x3D; LOAD_AVG_MAX - 1024 + sa-&gt;period_contrib;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Step 2: update *_avg.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	sa-&gt;load_avg &#x3D; div_u64(load * sa-&gt;load_sum, divider);</span><br><span class="line">	sa-&gt;runnable_load_avg &#x3D;	div_u64(runnable * sa-&gt;runnable_load_sum, divider);</span><br><span class="line">	WRITE_ONCE(sa-&gt;util_avg, sa-&gt;util_sum &#x2F; divider);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __update_load_avg_se(u64 now, struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	if (___update_load_sum(now, &amp;se-&gt;avg, !!se-&gt;on_rq, !!se-&gt;on_rq,</span><br><span class="line">				cfs_rq-&gt;curr &#x3D;&#x3D; se)) &#123;</span><br><span class="line"></span><br><span class="line">		___update_load_avg(&amp;se-&gt;avg, se_weight(se), se_runnable(se));</span><br><span class="line">		cfs_se_util_change(&amp;se-&gt;avg);</span><br><span class="line">		trace_pelt_se_tp(se);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>                      |&lt;--1024--&gt;|</code></pre>
<p>|———————————————|—|——|<br>                          |-|-|<br>                      period_contrib</p>
<p>divider = LOAD_AVG_MAX - (1024 - period_contrib)<br>    = LOAD_AVG_MAX - 1024 + period_contrib</p>
<p>可以大概理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load_avg &#x3D; load_weight * (load_sum &#x2F;  time_sum)</span><br><span class="line">util_avg &#x3D; util_sum &#x2F; time_sum</span><br></pre></td></tr></table></figure>


<p>当一个task一直运行，负载足够高时，可以认为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load_sum &#x3D;&#x3D;  time_sum</span><br><span class="line">util_sum &#x3D;&#x3D; time_sum</span><br><span class="line">load_avg &#x3D; load_weight</span><br><span class="line">util_avg &#x3D; 1</span><br></pre></td></tr></table></figure>

<h2 id="如何计算当前cfs-rq的负载"><a href="#如何计算当前cfs-rq的负载" class="headerlink" title="如何计算当前cfs_rq的负载"></a>如何计算当前cfs_rq的负载</h2><p>我们跟踪<code>se</code>的负载，更多的想更精确的知道每时每刻 <code>rq</code>上有负载变化，从而对scheduler的行为作出指导。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">int __update_load_avg_cfs_rq(u64 now, struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	if (___update_load_sum(now, &amp;cfs_rq-&gt;avg,</span><br><span class="line">				scale_load_down(cfs_rq-&gt;load.weight),</span><br><span class="line">				scale_load_down(cfs_rq-&gt;runnable_weight),</span><br><span class="line">				cfs_rq-&gt;curr !&#x3D; NULL)) &#123;</span><br><span class="line"></span><br><span class="line">		___update_load_avg(&amp;cfs_rq-&gt;avg, 1, 1);</span><br><span class="line">		trace_pelt_cfs_tp(cfs_rq);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * update_cfs_rq_load_avg - update the cfs_rq&#39;s load&#x2F;util averages</span><br><span class="line"> * @now: current time, as per cfs_rq_clock_pelt()</span><br><span class="line"> * @cfs_rq: cfs_rq to update</span><br><span class="line"> *</span><br><span class="line"> * The cfs_rq avg is the direct sum of all its entities (blocked and runnable)</span><br><span class="line"> * avg. The immediate corollary is that all (fair) tasks must be attached, see</span><br><span class="line"> * post_init_entity_util_avg().</span><br><span class="line"> *</span><br><span class="line"> * cfs_rq-&gt;avg is used for task_h_load() and update_cfs_share() for example.</span><br><span class="line"> *</span><br><span class="line"> * Returns true if the load decayed or we removed load.</span><br><span class="line"> *</span><br><span class="line"> * Since both these conditions indicate a changed cfs_rq-&gt;avg.load we should</span><br><span class="line"> * call update_tg_load_avg() when this function returns true.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;*</span><br><span class="line"> * cfs_rq avg 是 cfs_rq中所有 entities 的 sum。</span><br><span class="line"> * 返回值：1 如果 有线程被移出这个 cfs_rq 或者经过了一个衰减周期</span><br><span class="line"> *        0</span><br><span class="line"> *&#x2F;</span><br><span class="line">static inline int</span><br><span class="line">update_cfs_rq_load_avg(u64 now, struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long removed_load &#x3D; 0, removed_util &#x3D; 0, removed_runnable_sum &#x3D; 0;</span><br><span class="line">	struct sched_avg *sa &#x3D; &amp;cfs_rq-&gt;avg;</span><br><span class="line">	int decayed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	if (cfs_rq-&gt;removed.nr) &#123;</span><br><span class="line">		unsigned long r;</span><br><span class="line">		u32 divider &#x3D; LOAD_AVG_MAX - 1024 + sa-&gt;period_contrib;</span><br><span class="line"></span><br><span class="line">		raw_spin_lock(&amp;cfs_rq-&gt;removed.lock);</span><br><span class="line">		swap(cfs_rq-&gt;removed.util_avg, removed_util);</span><br><span class="line">		swap(cfs_rq-&gt;removed.load_avg, removed_load);</span><br><span class="line">		swap(cfs_rq-&gt;removed.runnable_sum, removed_runnable_sum);</span><br><span class="line">		cfs_rq-&gt;removed.nr &#x3D; 0;</span><br><span class="line">		raw_spin_unlock(&amp;cfs_rq-&gt;removed.lock);</span><br><span class="line"></span><br><span class="line">		r &#x3D; removed_load;</span><br><span class="line">		sub_positive(&amp;sa-&gt;load_avg, r);</span><br><span class="line">		sub_positive(&amp;sa-&gt;load_sum, r * divider);</span><br><span class="line"></span><br><span class="line">		r &#x3D; removed_util;</span><br><span class="line">		sub_positive(&amp;sa-&gt;util_avg, r);</span><br><span class="line">		sub_positive(&amp;sa-&gt;util_sum, r * divider);</span><br><span class="line"></span><br><span class="line">		add_tg_cfs_propagate(cfs_rq, -(long)removed_runnable_sum);</span><br><span class="line"></span><br><span class="line">		decayed &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	decayed |&#x3D; __update_load_avg_cfs_rq(now, cfs_rq);</span><br><span class="line"></span><br><span class="line">#ifndef CONFIG_64BIT</span><br><span class="line">	smp_wmb();</span><br><span class="line">	cfs_rq-&gt;load_last_update_time_copy &#x3D; sa-&gt;last_update_time;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	return decayed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-21T11:00:00.000Z" title="4/21/2021, 7:00:00 PM">2021-04-21</time>发表</span><span class="level-item"><time dateTime="2021-04-21T06:12:55.960Z" title="4/21/2021, 2:12:55 PM">2021-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">10 分钟读完 (大约1461个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/21/schedule/ipi_sched/">ipi_sched</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p>IPI 中断 (Inter-Processor Interrupts) ，核间中断可以通过向这个寄存器写入需要的值来产生。若硬件线程 A 想要发送一个核间中断给硬件线程 B，它只需要向寄存器 IPIBase 中写入 B<br>的 Thread ID、中断向量、中断类型等值就可以了，PIC 会通知 B 所在的核挂起它当前的执行序列，并根据中断向量跳转到中断服务例程 ISR 的入口</p>
<h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW?"></a>HOW?</h2><p>linux上将 IPI 中断分为以下几类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum ipi_msg_type &#123;</span><br><span class="line">	IPI_RESCHEDULE,</span><br><span class="line">	IPI_CALL_FUNC,</span><br><span class="line">	IPI_CPU_STOP,</span><br><span class="line">	IPI_CPU_CRASH_STOP,</span><br><span class="line">	IPI_TIMER,</span><br><span class="line">	IPI_IRQ_WORK,</span><br><span class="line">	IPI_WAKEUP</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>通过接口 <code>smp_cross_call</code> 调用，For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void smp_send_reschedule(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	smp_cross_call(cpumask_of(cpu), IPI_RESCHEDULE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>CPUa 给 CPUb 发送一个 <code>IPI_RESCHEDULE</code> 信号，然后 CPUb执行相关函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Main handler for inter-processor interrupts</span><br><span class="line"> *&#x2F;</span><br><span class="line">void handle_IPI(int ipinr, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int cpu &#x3D; smp_processor_id();</span><br><span class="line">	struct pt_regs *old_regs &#x3D; set_irq_regs(regs);</span><br><span class="line"></span><br><span class="line">	switch (ipinr) &#123;</span><br><span class="line">	case IPI_RESCHEDULE:</span><br><span class="line">		scheduler_ipi();</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case IPI_CALL_FUNC:</span><br><span class="line">		irq_enter();</span><br><span class="line">		generic_smp_call_function_interrupt();</span><br><span class="line">		irq_exit();</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">	set_irq_regs(old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="scheduler-ipi-主要工作？"><a href="#scheduler-ipi-主要工作？" class="headerlink" title="scheduler_ipi 主要工作？"></a>scheduler_ipi 主要工作？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void scheduler_ipi(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting</span><br><span class="line">	 * TIF_NEED_RESCHED remotely (for the first time) will also send</span><br><span class="line">	 * this IPI.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	preempt_fold_need_resched();</span><br><span class="line"></span><br><span class="line">	if (llist_empty(&amp;this_rq()-&gt;wake_list) &amp;&amp; !got_nohz_idle_kick())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Not all reschedule IPI handlers call irq_enter&#x2F;irq_exit, since</span><br><span class="line">	 * traditionally all their work was done from the interrupt return</span><br><span class="line">	 * path. Now that we actually do some work, we need to make sure</span><br><span class="line">	 * we do call them.</span><br><span class="line">	 *</span><br><span class="line">	 * Some archs already do call them, luckily irq_enter&#x2F;exit nest</span><br><span class="line">	 * properly.</span><br><span class="line">	 *</span><br><span class="line">	 * Arguably we should visit all archs and update all handlers,</span><br><span class="line">	 * however a fair share of IPIs are still resched only so this would</span><br><span class="line">	 * somewhat pessimize the simple resched case.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	irq_enter();</span><br><span class="line">	sched_ttwu_pending();</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Check if someone kicked us for doing the nohz idle load balance.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (unlikely(got_nohz_idle_kick())) &#123;</span><br><span class="line">		this_rq()-&gt;idle_balance &#x3D; 1;</span><br><span class="line">		raise_softirq_irqoff(SCHED_SOFTIRQ);</span><br><span class="line">	&#125;</span><br><span class="line">	irq_exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>llist_empty(&amp;this_rq()-&gt;wake_list)</code> 成立，意味着rq上没有需要wake_up的thread，且同时 <code>!got_nohz_idle_kick()</code>也成立的话，就直接返回了，这个 IPI就是无效的。</p>
<p>正常都会继续往下继续走，重点是 <code>sched_ttwu_pending</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void sched_ttwu_pending(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; this_rq();</span><br><span class="line">	struct llist_node *llist &#x3D; llist_del_all(&amp;rq-&gt;wake_list);</span><br><span class="line">	struct task_struct *p, *t;</span><br><span class="line">	struct rq_flags rf;</span><br><span class="line"></span><br><span class="line">	if (!llist)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">        &#x2F;&#x2F; 一次性唤醒所有 &#96;wake_list&#96; 上的task。</span><br><span class="line">	llist_for_each_entry_safe(p, t, llist, wake_entry)</span><br><span class="line">		ttwu_do_activate(rq, p, p-&gt;sched_remote_wakeup ? WF_MIGRATED : 0, &amp;rf);</span><br><span class="line"></span><br><span class="line">	rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后查看是否需要做 <code>load_balance</code></p>
<h2 id="什么情况下会发送-IPI-RESCHEDULE？"><a href="#什么情况下会发送-IPI-RESCHEDULE？" class="headerlink" title="什么情况下会发送 IPI_RESCHEDULE？"></a>什么情况下会发送 IPI_RESCHEDULE？</h2><ol>
<li>resched_curr()<br>如果cpu == smp_processor_id()，(这里分为俩种情况，1. UP架构只有一个CPU 2. SMP架构上恰好resched_curr()的是本cpu)<br>那仅仅是设置 当前 curr的thread_info的 need_resched标志位。<br>如果是需要其他cpu执行 resched_curr()，就需要 <code>smp_send_reschedule(cpu)</code> 来发送 <code>IPI_RESCHEDULE</code>了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * resched_curr - mark rq&#39;s current task &#39;to be rescheduled now&#39;.</span><br><span class="line"> *</span><br><span class="line"> * On UP this means the setting of the need_resched flag, on SMP it</span><br><span class="line"> * might also involve a cross-CPU call to trigger the scheduler on</span><br><span class="line"> * the target CPU.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void resched_curr(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *curr &#x3D; rq-&gt;curr;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	if (test_tsk_need_resched(curr))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	cpu &#x3D; cpu_of(rq);</span><br><span class="line"></span><br><span class="line">	if (cpu &#x3D;&#x3D; smp_processor_id()) &#123;</span><br><span class="line">		set_tsk_need_resched(curr);</span><br><span class="line">		set_preempt_need_resched();</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (set_nr_and_not_polling(curr))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	else</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li>wake_up_idle_cpu()</li>
</ol>
<p>在唤醒一个 idle的cpu时，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void wake_up_idle_cpu(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	if (cpu &#x3D;&#x3D; smp_processor_id())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (set_nr_and_not_polling(rq-&gt;idle))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	else</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>kick_process()</li>
</ol>
<p>让一个 task立刻进入 kernel mode（without any delay），从而来处理 signal信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> * kick_process - kick a running thread to enter&#x2F;exit the kernel</span><br><span class="line"> * @p: the to-be-kicked thread</span><br><span class="line"> *</span><br><span class="line"> * Cause a process which is running on another CPU to enter</span><br><span class="line"> * kernel-mode, without any delay. (to get signals handled.)</span><br><span class="line"> *</span><br><span class="line"> * NOTE: this function doesn&#39;t have to take the runqueue lock,</span><br><span class="line"> * because all it wants to ensure is that the remote task enters</span><br><span class="line"> * the kernel. If the IPI races and the task has been migrated</span><br><span class="line"> * to another CPU then no harm is done and the purpose has been</span><br><span class="line"> * achieved as well.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void kick_process(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu &#x3D; task_cpu(p);</span><br><span class="line">	if ((cpu !&#x3D; smp_processor_id()) &amp;&amp; task_curr(p))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(kick_process);</span><br><span class="line"></span><br><span class="line">void signal_wake_up_state(struct task_struct *t, unsigned int state)</span><br><span class="line">&#123;</span><br><span class="line">	set_tsk_thread_flag(t, TIF_SIGPENDING);</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * TASK_WAKEKILL also means wake it up in the stopped&#x2F;traced&#x2F;killable</span><br><span class="line">	 * case. We don&#39;t check t-&gt;state here because there is a race with it</span><br><span class="line">	 * executing another processor and just now entering stopped state.</span><br><span class="line">	 * By using wake_up_state, we ensure the process will wake up and</span><br><span class="line">	 * handle its death signal.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!wake_up_state(t, state | TASK_INTERRUPTIBLE))</span><br><span class="line">		kick_process(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>ttwu_queue_remote()</li>
</ol>
<p>try_to_wake_up() 一个thread之后，需要将 这个task入队<br>a. 如果是 task不是在 <code>本cpu</code> 唤醒的，那就需要IPI中断<code>smp_send_reschedule</code>来搞了<br>b. 如果是在 <code>本地cpu</code> 唤醒的，就直接 lock_rq() 之后进行 <code>ttwu_do_activate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static void ttwu_queue_remote(struct task_struct *p, int cpu, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	p-&gt;sched_remote_wakeup &#x3D; !!(wake_flags &amp; WF_MIGRATED);</span><br><span class="line"></span><br><span class="line">	if (llist_add(&amp;p-&gt;wake_entry, &amp;cpu_rq(cpu)-&gt;wake_list)) &#123;</span><br><span class="line">		if (!set_nr_if_polling(rq-&gt;idle))</span><br><span class="line">			smp_send_reschedule(cpu);</span><br><span class="line">		else</span><br><span class="line">			trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void ttwu_queue(struct task_struct *p, int cpu, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line">	struct rq_flags rf;</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_SMP)</span><br><span class="line">	if (sched_feat(TTWU_QUEUE) &amp;&amp; !cpus_share_cache(smp_processor_id(), cpu)) &#123;</span><br><span class="line">		sched_clock_cpu(cpu); &#x2F;* Sync clocks across CPUs *&#x2F;</span><br><span class="line">		ttwu_queue_remote(p, cpu, wake_flags);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	ttwu_do_activate(rq, p, wake_flags, &amp;rf);</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>wake_up_if_idle()<br><code>wake_up_if_idle()</code> 只有在 <code>wake_up_all_idle_cpus()</code> 中被调用，主要是看此 cpu 是否idle空闲，就是看他 <code>is_idle_task(cpu_rq(cpu)-&gt;curr)</code> 是否成立，成立的话就需要 IPI中断去唤醒。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void wake_up_if_idle(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line">	struct rq_flags rf;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	if (!is_idle_task(rcu_dereference(rq-&gt;curr)))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	if (set_nr_if_polling(rq-&gt;idle)) &#123;</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">		if (is_idle_task(rq-&gt;curr))</span><br><span class="line">			smp_send_reschedule(cpu);</span><br><span class="line">		&#x2F;* Else CPU is not idle, do nothing here: *&#x2F;</span><br><span class="line">		rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void wake_up_all_idle_cpus(void)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	for_each_online_cpu(cpu) &#123;</span><br><span class="line">		if (cpu &#x3D;&#x3D; smp_processor_id())</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		wake_up_if_idle(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>參考linux-5.4.61代码</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-15T11:00:00.000Z" title="4/15/2021, 7:00:00 PM">2021-04-15</time>发表</span><span class="level-item"><time dateTime="2021-04-15T02:37:17.900Z" title="4/15/2021, 10:37:17 AM">2021-04-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/frequency-governer/">frequency governer</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/frequency-governer/schedule-util/">schedule util</a></span><span class="level-item">几秒读完 (大约12个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/15/schedule/freq%20governer/">freq governer</a></h1><div class="content"><p>参考<a href="Documentation/admin-guide/pm/cpufreq.rst">内核文档</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-12T11:00:00.000Z" title="4/12/2021, 7:00:00 PM">2021-04-12</time>发表</span><span class="level-item"><time dateTime="2021-04-21T08:09:37.140Z" title="4/21/2021, 4:09:37 PM">2021-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">6 分钟读完 (大约886个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/12/schedule/sched_domain%20and%20root_domain/">sched_domain and root_domain</a></h1><div class="content"><h2 id="root-domain"><a href="#root-domain" class="headerlink" title="root_domain"></a>root_domain</h2><p><code>root_domain</code> 相对于 <code>sched_domain</code> 来说简单很多， 这是描述一个cpu集合的 数据结构。<br>每个 <code>cpuset</code> 都会拥有一个 <code>root_domain</code>，无论何时何地 <code>cpuset</code>被创建，同时会创建 并 attach 一个 root_domain结构。<br>一个  <code>root_domain</code> 可能包含多个cpu，且这些cpu的能效不一定是一致的，所以内嵌了<code>perf_domain</code> 结构来描述这种差异。</p>
<p><code>perf_domain</code> 的<code>next</code> 指针 就这样将这个<code>root_domain</code> 中的<code>perf_domain</code> 连接起来了。<br>具有同一能效模型的俩cpu(在同一cluster上)，共享一个 <code>em_perf_domain</code> 能效模型结构，但是 <code>perf_domain</code>可能是分开的，因为这俩cpu可能是属于不同<code>root_domain</code>的。</p>
<p>参考 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/scheduler/sched-energy.html">kernel 文档</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">The lists are attached to the root domains in order to cope with exclusive cpuset configurations. Since the boundaries of exclusive cpusets do not necessarily match those of performance domains, the lists of different root domains can contain duplicate elements.</span><br><span class="line"></span><br><span class="line">Example 1.</span><br><span class="line">Let us consider a platform with 12 CPUs, split in 3 performance domains (pd0, pd4 and pd8), organized as follows:</span><br><span class="line"></span><br><span class="line">CPUs:   0 1 2 3 4 5 6 7 8 9 10 11</span><br><span class="line">PDs:   |--pd0--|--pd4--|---pd8---|</span><br><span class="line">RDs:   |----rd1----|-----rd2-----|</span><br><span class="line">Now, consider that userspace decided to split the system with two exclusive cpusets, hence creating two independent root domains, each containing 6 CPUs. The two root domains are denoted rd1 and rd2 in the above figure. Since pd4 intersects with both rd1 and rd2, it will be present in the linked list ‘-&gt;pd’ attached to each of them:</span><br><span class="line">rd1-&gt;pd: pd0 -&gt; pd4</span><br><span class="line">rd2-&gt;pd: pd4 -&gt; pd8</span><br><span class="line"></span><br><span class="line">Please note that the scheduler will create two duplicate list nodes for pd4 (one for each list). However, both just hold a pointer to the same shared data structure of the EM framework.</span><br><span class="line"></span><br><span class="line">Since the access to these lists can happen concurrently with hotplug and other things, they are protected by RCU, like the rest of topology structures manipulated by the scheduler.</span><br><span class="line"></span><br><span class="line">EAS also maintains a static key (sched_energy_present) which is enabled when at least one root domain meets all conditions for EAS to start. Those conditions are summarized in Section 6.</span><br></pre></td></tr></table></figure>

<p>这是 <code>root_domain</code> 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">struct perf_domain &#123;</span><br><span class="line">	struct em_perf_domain *em_pd;</span><br><span class="line">	struct perf_domain *next;</span><br><span class="line">	struct rcu_head rcu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * We add the notion of a root-domain which will be used to define per-domain</span><br><span class="line"> * variables. Each exclusive cpuset essentially defines an island domain by</span><br><span class="line"> * fully partitioning the member CPUs from any other cpuset. Whenever a new</span><br><span class="line"> * exclusive cpuset is created, we also create and attach a new root-domain</span><br><span class="line"> * object.</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct root_domain &#123;</span><br><span class="line">	atomic_t		refcount;</span><br><span class="line">	atomic_t		rto_count;</span><br><span class="line">	struct rcu_head		rcu;</span><br><span class="line">	cpumask_var_t		span;</span><br><span class="line">	cpumask_var_t		online;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Indicate pullable load on at least one CPU, e.g:</span><br><span class="line">	 * - More than one runnable task</span><br><span class="line">	 * - Running task is misfit</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	int			overload;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Indicate one or more cpus over-utilized (tipping point) *&#x2F;</span><br><span class="line">	int			overutilized;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The bit corresponding to a CPU gets set here if such CPU has more</span><br><span class="line">	 * than one runnable -deadline task (as it is below for RT tasks).</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	cpumask_var_t		dlo_mask;</span><br><span class="line">	atomic_t		dlo_count;</span><br><span class="line">	struct dl_bw		dl_bw;</span><br><span class="line">	struct cpudl		cpudl;</span><br><span class="line"></span><br><span class="line">#ifdef HAVE_RT_PUSH_IPI</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * For IPI pull requests, loop across the rto_mask.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct irq_work		rto_push_work;</span><br><span class="line">	raw_spinlock_t		rto_lock;</span><br><span class="line">	&#x2F;* These are only updated and read within rto_lock *&#x2F;</span><br><span class="line">	int			rto_loop;</span><br><span class="line">	int			rto_cpu;</span><br><span class="line">	&#x2F;* These atomics are updated outside of a lock *&#x2F;</span><br><span class="line">	atomic_t		rto_loop_next;</span><br><span class="line">	atomic_t		rto_loop_start;</span><br><span class="line">#endif</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The &quot;RT overload&quot; flag: it gets set if a CPU has more than</span><br><span class="line">	 * one runnable RT task.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	cpumask_var_t		rto_mask;</span><br><span class="line">	struct cpupri		cpupri;</span><br><span class="line"></span><br><span class="line">	unsigned long		max_cpu_capacity;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * NULL-terminated list of performance domains intersecting with the</span><br><span class="line">	 * CPUs of the rd. Protected by RCU.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct perf_domain __rcu *pd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="sched-domain-WHAT"><a href="#sched-domain-WHAT" class="headerlink" title="sched domain: WHAT?"></a>sched domain: WHAT?</h2><h2 id="sched-domain-如何标识？"><a href="#sched-domain-如何标识？" class="headerlink" title="sched domain: 如何标识？"></a>sched domain: 如何标识？</h2><p><code>include/linux/sched/sd_flags.h</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SDF_SHARED_CHILD       0x1</span><br><span class="line">#define SDF_SHARED_PARENT      0x2</span><br><span class="line">#define SDF_NEEDS_GROUPS       0x4</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SD_FLAG(SD_BALANCE_NEWIDLE, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_BALANCE_EXEC, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_BALANCE_FORK, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_BALANCE_WAKE, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_WAKE_AFFINE, SDF_SHARED_CHILD)</span><br><span class="line">SD_FLAG(SD_ASYM_CPUCAPACITY, SDF_SHARED_PARENT | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_SHARE_CPUCAPACITY, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_SHARE_PKG_RESOURCES, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_SERIALIZE, SDF_SHARED_PARENT | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_ASYM_PACKING, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_PREFER_SIBLING, SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_OVERLAP, SDF_SHARED_PARENT | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_NUMA, SDF_SHARED_PARENT | SDF_NEEDS_GROUPS)</span><br></pre></td></tr></table></figure>


</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">上一页</a></div><div class="pagination-next"><a href="/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/12/">12</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Hui Su"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Hui Su</p><p class="is-size-6 is-block">liulangren bolg</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">115</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">143</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liulangrenaaa" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liulangrenaaa"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.google.com.hk/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Google</span></span><span class="level-right"><span class="level-item tag">www.google.com.hk</span></span></a></li><li><a class="level is-mobile" href="https://lkml.org/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">LKML</span></span><span class="level-right"><span class="level-item tag">lkml.org</span></span></a></li><li><a class="level is-mobile" href="https://mail.google.com/mail" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gmail</span></span><span class="level-right"><span class="level-item tag">mail.google.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhihu.com/explore" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/contest/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 剑指offer</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 周赛</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://tongji.baidu.com/web/32051076/overview/index?siteId=16230094" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">百度分析</span></span><span class="level-right"><span class="level-item tag">tongji.baidu.com</span></span></a></li><li><a class="level is-mobile" href="https://analytics.google.com/analytics/web/#/a187909645p259761261/admin/streams/table/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">google分析</span></span><span class="level-right"><span class="level-item tag">analytics.google.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BRK/"><span class="tag">BRK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HW/"><span class="tag">HW</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KASAN/"><span class="tag">KASAN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OOM/"><span class="tag">OOM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QCOM/"><span class="tag">QCOM</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aarch64/"><span class="tag">aarch64</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/acl/"><span class="tag">acl</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android-framework/"><span class="tag">android framework</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android12-gdb64%E8%B0%83%E8%AF%95%E8%BF%9B%E7%A8%8B/"><span class="tag">android12 gdb64调试进程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpf/"><span class="tag">bpf</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpftrace/"><span class="tag">bpftrace</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup/"><span class="tag">cgroup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v1/"><span class="tag">cgroup v1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v2/"><span class="tag">cgroup v2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpu%E8%B0%83%E9%A2%91/"><span class="tag">cpu调频</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/crash/"><span class="tag">crash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dd/"><span class="tag">dd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/deadlock/"><span class="tag">deadlock</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debugfs/"><span class="tag">debugfs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/double-free/"><span class="tag">double free</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/drop-caches/"><span class="tag">drop_caches</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dumpe2fs/"><span class="tag">dumpe2fs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/eas/"><span class="tag">eas</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/event-trace/"><span class="tag">event trace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ext2/"><span class="tag">ext2</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-attr/"><span class="tag">file attr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-hole/"><span class="tag">file hole</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/filesystem/"><span class="tag">filesystem</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fsck/"><span class="tag">fsck</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ftrace/"><span class="tag">ftrace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gdb/"><span class="tag">gdb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hardlockup/"><span class="tag">hardlockup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hrtimer/"><span class="tag">hrtimer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hugepage/"><span class="tag">hugepage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hungtask/"><span class="tag">hungtask</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/interrupt/"><span class="tag">interrupt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt/"><span class="tag">intrrrupt</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt-storm/"><span class="tag">intrrrupt storm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/irq/"><span class="tag">irq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kallsyms/"><span class="tag">kallsyms</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kdump/"><span class="tag">kdump</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kernel-patch/"><span class="tag">kernel patch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kfence/"><span class="tag">kfence</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kmemleak/"><span class="tag">kmemleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kprobes/"><span class="tag">kprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kretprobes/"><span class="tag">kretprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ksoftirqd/"><span class="tag">ksoftirqd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kthread/"><span class="tag">kthread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvm/"><span class="tag">kvm</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvmtool/"><span class="tag">kvmtool</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/launch-json/"><span class="tag">launch.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-kernel/"><span class="tag">linux kernel</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-native-aio/"><span class="tag">linux native aio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lock-stat/"><span class="tag">lock_stat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lockdep/"><span class="tag">lockdep</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/makedumpfile/"><span class="tag">makedumpfile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memleak/"><span class="tag">memleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory/"><span class="tag">memory</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory-direct-reclaim/"><span class="tag">memory direct reclaim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mount/"><span class="tag">mount</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/namespace/"><span class="tag">namespace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oom/"><span class="tag">oom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oops/"><span class="tag">oops</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-cache/"><span class="tag">page_cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-owner/"><span class="tag">page_owner</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pagecache/"><span class="tag">pagecache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pagemap/"><span class="tag">pagemap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/panic/"><span class="tag">panic</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/per-cpu/"><span class="tag">per-cpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/perf/"><span class="tag">perf</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/perf-c2c/"><span class="tag">perf c2c</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pid-namespace/"><span class="tag">pid namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preempt-count/"><span class="tag">preempt_count</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preemption/"><span class="tag">preemption</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pressure/"><span class="tag">pressure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/process-madvise/"><span class="tag">process_madvise</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psi/"><span class="tag">psi</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psoix-aio/"><span class="tag">psoix aio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/randomize-va-space/"><span class="tag">randomize_va_space</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rcu/"><span class="tag">rcu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/read-code/"><span class="tag">read code</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sched-latency/"><span class="tag">sched latency</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/schedule/"><span class="tag">schedule</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slab/"><span class="tag">slab</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub/"><span class="tag">slub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub-debug/"><span class="tag">slub_debug</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/softlockup/"><span class="tag">softlockup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stack-overflow/"><span class="tag">stack_overflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-key/"><span class="tag">static_key</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sync/"><span class="tag">sync</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systemTap/"><span class="tag">systemTap</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systrace/"><span class="tag">systrace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-json/"><span class="tag">task.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-struct/"><span class="tag">task_struct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tasklet/"><span class="tag">tasklet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thread-info/"><span class="tag">thread_info</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tracepoint/"><span class="tag">tracepoint</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ubuntu/"><span class="tag">ubuntu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/use-after-free/"><span class="tag">use after free</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uts-namespace/"><span class="tag">uts namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/valgrind/"><span class="tag">valgrind</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vdso/"><span class="tag">vdso</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmstat/"><span class="tag">vmstat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmtouch/"><span class="tag">vmtouch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vscode/"><span class="tag">vscode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/x86/"><span class="tag">x86</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xattr/"><span class="tag">xattr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zone/"><span class="tag">zone</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%B6%8A%E7%95%8C/"><span class="tag">内存泄漏越界</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"><span class="tag">内存泄露</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内核内存泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C/"><span class="tag">内核内存越界</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"><span class="tag">内核同步</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0/"><span class="tag">内核抢占</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%A0%88%E6%BA%A2%E5%87%BA/"><span class="tag">内核栈溢出</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E7%AE%A1%E7%AE%A1%E7%90%86/"><span class="tag">内管管理</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"><span class="tag">函数调用</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E9%9A%8F%E6%9C%BA%E5%8C%96/"><span class="tag">地址空间布局随机化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/"><span class="tag">性能稳定性</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B3%84%E6%BC%8F/"><span class="tag">文件描述符泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><span class="tag">文件系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E9%A1%B9/"><span class="tag">杂项</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%88/"><span class="tag">栈</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/"><span class="tag">死锁检测</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="tag">生活感悟</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%A8%E6%88%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">用户内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A9%BA%E6%8C%87%E9%92%88/"><span class="tag">空指针</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F/"><span class="tag">虚拟地址空间泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F/"><span class="tag">资源泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%B8%AD%E6%96%AD/"><span class="tag">软中断</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"><span class="tag">进程调度</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/"><span class="tag">通用寄存器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81%E7%B2%92%E5%BA%A6/"><span class="tag">锁粒度</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E7%B3%BB%E7%BB%9F/"><span class="tag">问题系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/QCOM/"><span class="level-start"><span class="level-item">QCOM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/cgroup-v1/"><span class="level-start"><span class="level-item">cgroup v1</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/cgroup-v1/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/kernel-debug/"><span class="level-start"><span class="level-item">kernel debug</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/kernel-debug/cache-false-sharing/"><span class="level-start"><span class="level-item">cache false sharing</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/linux-kernel/"><span class="level-start"><span class="level-item">linux kernel</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/"><span class="level-start"><span class="level-item">linux schedule</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/deadline-schedule/"><span class="level-start"><span class="level-item">deadline schedule</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/"><span class="level-start"><span class="level-item">frequency governer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/schedule-util/"><span class="level-start"><span class="level-item">schedule util</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/idle/"><span class="level-start"><span class="level-item">idle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/linux%E5%86%85%E6%A0%B8/"><span class="level-start"><span class="level-item">linux内核</span></span><span class="level-end"><span class="level-item tag">68</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/"><span class="level-start"><span class="level-item">namespace</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/namespace/pid-namespace/"><span class="level-start"><span class="level-item">pid namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/uts-namespace/"><span class="level-start"><span class="level-item">uts namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/qemu/"><span class="level-start"><span class="level-item">qemu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/schedule/"><span class="level-start"><span class="level-item">schedule</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/server/"><span class="level-start"><span class="level-item">server</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/shell%E8%84%9A%E6%9C%AC/"><span class="level-start"><span class="level-item">shell脚本</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="level-start"><span class="level-item">生活感悟</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-24T11:00:00.000Z">2022-01-24</time></p><p class="title"><a href="/2022/01/24/schedule/cpu%E8%B0%83%E9%A2%91/">cpu调频</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-20T08:42:37.115Z">2022-01-20</time></p><p class="title"><a href="/2022/01/20/schedule/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-05T11:00:00.000Z">2022-01-05</time></p><p class="title"><a href="/2022/01/05/schedule/eas/">eas</a></p><p class="categories"><a href="/categories/linux-kernel/">linux kernel</a> / <a href="/categories/linux-kernel/linux-schedule/">linux schedule</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-03T11:00:00.000Z">2021-11-03</time></p><p class="title"><a href="/2021/11/03/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/perf%E7%9B%B8%E5%85%B3/perf%20c2c/">perf c2c</a></p><p class="categories"><a href="/categories/kernel-debug/">kernel debug</a> / <a href="/categories/kernel-debug/cache-false-sharing/">cache false sharing</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-23T11:00:00.000Z">2021-09-23</time></p><p class="title"><a href="/2021/09/23/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/android12%20gdb64%E8%B0%83%E8%AF%95%E8%BF%9B%E7%A8%8B/">android12 gdb64调试进程</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Su Hui</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>