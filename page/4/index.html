<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>liulangren Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="liulangren blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="liulangren blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="liulangren Blog"><meta property="og:url" content="https://liulangrenaaa.github.io/"><meta property="og:site_name" content="liulangren Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liulangrenaaa.github.io/img/og_image.png"><meta property="article:author" content="Su Hui"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liulangrenaaa.github.io"},"headline":"liulangren Blog","image":["https://liulangrenaaa.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Su Hui"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cabdc5b9b70bb83fa919a6ebeb439f93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=PTKX6HMR55" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'PTKX6HMR55');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-24T11:00:00.000Z" title="4/24/2021, 7:00:00 PM">2021-04-24</time>发表</span><span class="level-item"><time dateTime="2021-04-22T06:24:26.660Z" title="4/22/2021, 2:24:26 PM">2021-04-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">18 分钟读完 (大约2771个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/24/schedule/pelt/">pelt</a></h1><div class="content"><p>参考<a target="_blank" rel="noopener" href="http://www.wowotech.net/process_management/450.html">wowo文章</a></p>
<h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h2><p>为了让调度器更加的聪明，我们总是希望系统满足最大吞吐量同时又最大限度的降低功耗。虽然可能有些矛盾，但是现实总是这样。PELT算法是Linux 3.8合入的，那么在此之前，我们存在什么问题才引入PELT算法呢？在Linux 3.8之前，CFS以每个运行队列（runqueue，简称rq）为基础跟踪负载。但是这种方法，我们无法确定当前负载的来源。同时，即使工作负载相对稳定的情况下，在rq级别跟踪负载，其值也会产生很大变化。为了解决以上的问题，PELT算法会跟踪每个调度实体（per-scheduling entity）的负载情况。</p>
<h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW?"></a>HOW?</h2><p>为了做到Per-entity的负载跟踪，时间（物理时间，不是虚拟时间）被分成了1024us的序列，在每一个1024us的周期中，一个entity对系统负载的贡献可以根据该实体处于runnable状态（正在CPU上运行或者等待cpu调度运行）的时间进行计算。</p>
<p>如果在该周期内，runnable的时间是x，那么对系统负载的贡献就是（x/1024）。当然，一个实体在一个计算周期内的负载可能会超过1024us，这是因为我们会累积在过去周期中的负载，当然，对于过去的负载我们在计算的时候需要乘一个衰减因子。如果我们让Li表示在周期pi中该调度实体的对系统负载贡献，那么一个调度实体对系统负荷的总贡献可以表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L &#x3D; L0 + L1 * y + L2 * y2 + L3 * y3 + ... + Ln * yn</span><br><span class="line"></span><br><span class="line">其中：y32 &#x3D; 0.5, y &#x3D; 0.97857206</span><br></pre></td></tr></table></figure>

<p>如果有一个task，从第一次加入rq后开始一直运行4096us后一直睡眠，那么在1023us、2047us、3071us、4095us、5119us、6143us、7167us和8191us时间的每一个时刻负载贡献分别是多少呢？<br>        /<br>        |<br>       1|———————–|<br>        |                       |<br>       0|                       |——————————————<br>——————————————————————————-&gt;<br>                |       |       |       |       |       |       |       |<br>              1023    2047    4095    5119    7167    8191</p>
<p>可以计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L0 &#x3D; 1023 * y0 &#x3D; 1023</span><br><span class="line">L1 &#x3D; 1023 * y0 + 1024 * y1 &#x3D; 1023 + (L0 + 1) * y &#x3D; 2025</span><br><span class="line">L2 &#x3D; 1023 * y0 + 1024 * y1 + 1024 * y2 &#x3D; 1023 + (L1 + 1) * y1 &#x3D; 3005</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>可以得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ln &#x3D; Load(This)  + Ln-1 * y &#x3D;  当前周期负载 + 上一周期负载 * 衰减系数y</span><br></pre></td></tr></table></figure>

<p>需要经常计算 Ln-1 * y的值，但是内核并不是 简单计算  Ln-1 * y，也可能需要计算<br>Ln-m * ym，kernel中使用decay_laod()函数。<br>为了提高精度和计算速度，采用乘法  和 位移算法进行计算，输入是:</p>
<ol>
<li>val: 前n个负载计算周期的负载</li>
<li>n: 衰减n个周期之后的实际负载<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">decay_load(val, n) &#x3D; val * yn &#x3D; (val * yn) * (232 &gt;&gt;32)</span><br><span class="line">                              &#x3D; val * (yn * 232) &gt;&gt;  32</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>可以看到 yn * 232的值其实是固定的（n确定的情况下是一个数组）<br><code>runnable_avg_yN_inv[n] = yn*232, n &gt; 0 &amp;&amp; n &lt; 32</code><br>kernel中使用了一个数组来保存这些值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static const u32 runnable_avg_yN_inv[] &#x3D; &#123;</span><br><span class="line">	0xffffffff, 0xfa83b2da, 0xf5257d14, 0xefe4b99a, 0xeac0c6e6, 0xe5b906e6,</span><br><span class="line">	0xe0ccdeeb, 0xdbfbb796, 0xd744fcc9, 0xd2a81d91, 0xce248c14, 0xc9b9bd85,</span><br><span class="line">	0xc5672a10, 0xc12c4cc9, 0xbd08a39e, 0xb8fbaf46, 0xb504f333, 0xb123f581,</span><br><span class="line">	0xad583ee9, 0xa9a15ab4, 0xa5fed6a9, 0xa2704302, 0x9ef5325f, 0x9b8d39b9,</span><br><span class="line">	0x9837f050, 0x94f4efa8, 0x91c3d373, 0x8ea4398a, 0x8b95c1e3, 0x88980e80,</span><br><span class="line">	0x85aac367, 0x82cd8698,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是<code>decay_load</code>实际代码：</p>
<ol>
<li>如果衰减周期大于 <code>LOAD_AVG_PERIOD * 63</code>，那么我们认为<code>LOAD_AVG_PERIOD * 63</code>之前的负载val对现在的贡献是 0</li>
<li>如果<code>n &gt;= 32</code>，由于 <code>runnable_avg_yN_inv</code> 只包含了y31的值，所以 必须将n 归一化到 <code>&lt; 32</code>，每归一化一次，负载贡献就减半 (val = val &gt;&gt; 1)</li>
<li>最后衰减的负载是 <code>val * runnable_avg_yN_inv[local_n] &gt;&gt; 32</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Approximate:</span><br><span class="line"> *   val * y^n,    where y^32 ~&#x3D; 0.5 (~1 scheduling period)</span><br><span class="line"> *&#x2F;</span><br><span class="line">static u64 decay_load(u64 val, u64 n)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int local_n;</span><br><span class="line"></span><br><span class="line">	if (unlikely(n &gt; LOAD_AVG_PERIOD * 63))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;* after bounds checking we can collapse to 32-bit *&#x2F;</span><br><span class="line">	local_n &#x3D; n;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * As y^PERIOD &#x3D; 1&#x2F;2, we can combine</span><br><span class="line">	 *    y^n &#x3D; 1&#x2F;2^(n&#x2F;PERIOD) * y^(n%PERIOD)</span><br><span class="line">	 * With a look-up table which covers y^n (n&lt;PERIOD)</span><br><span class="line">	 *</span><br><span class="line">	 * To achieve constant time decay_load.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (unlikely(local_n &gt;&#x3D; LOAD_AVG_PERIOD)) &#123;</span><br><span class="line">		val &gt;&gt;&#x3D; local_n &#x2F; LOAD_AVG_PERIOD;</span><br><span class="line">		local_n %&#x3D; LOAD_AVG_PERIOD;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val &#x3D; mul_u64_u32_shr(val, runnable_avg_yN_inv[local_n], 32);</span><br><span class="line">	return val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="负载信息如何记录？"><a href="#负载信息如何记录？" class="headerlink" title="负载信息如何记录？"></a>负载信息如何记录？</h2><p>首先负载计算是相对于<code>调度实体se 和  就绪队列rq</code>的：<br>对于 <code>struct sched_entity</code>  <code>struct cfs_rq</code> <code>struct rq</code> 结构来说都内嵌了 <code>struct sched_avg</code> 结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">struct sched_avg &#123;</span><br><span class="line">	u64				last_update_time; &#x2F;&#x2F; 上一次负载更新的时间</span><br><span class="line">	u64				load_sum; &#x2F;&#x2F; running + runnable 的负载</span><br><span class="line">	u64				runnable_load_sum;&#x2F;&#x2F; 姑且等于 load_sum</span><br><span class="line">	u32				util_sum; &#x2F;&#x2F; running 的负载</span><br><span class="line">	u32				period_contrib;</span><br><span class="line">	unsigned long			load_avg; &#x2F;&#x2F; running + runnable 的平均负载</span><br><span class="line">	unsigned long			runnable_load_avg; &#x2F;&#x2F; 姑且等于 load_avg</span><br><span class="line">	unsigned long			util_avg; &#x2F;&#x2F; running 的平均负载</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sched_entity &#123;</span><br><span class="line">      	struct load_weight		load;</span><br><span class="line">	unsigned long			runnable_weight;</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Per entity load average tracking.</span><br><span class="line">	 *</span><br><span class="line">	 * Put into separate cache line so it does not</span><br><span class="line">	 * collide with read-mostly values above.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct sched_avg		avg;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cfs_rq &#123;</span><br><span class="line">	struct load_weight	load;</span><br><span class="line">	unsigned long		runnable_weight;</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * CFS load tracking</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct sched_avg	avg;</span><br><span class="line">#ifndef CONFIG_64BIT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct rq &#123;</span><br><span class="line">	&#x2F;* runqueue lock: *&#x2F;</span><br><span class="line">	raw_spinlock_t		lock;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * nr_running and cpu_load should be in the same cacheline because</span><br><span class="line">	 * remote CPUs use both these fields when doing load calculation.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	unsigned int		nr_running;</span><br><span class="line">	struct sched_avg	avg_rt;</span><br><span class="line">	struct sched_avg	avg_dl;</span><br><span class="line">#ifdef CONFIG_HAVE_SCHED_AVG_IRQ</span><br><span class="line">	struct sched_avg	avg_irq;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>通过init可以更清楚知道他们含义，如果<code>se</code>是：</p>
<ol>
<li><code>task</code>，那么 runnable_load_avg = load_avg 都和 se的权重相等</li>
<li><code>group se</code>，runnable_load_avg = load_avg = 0，也反映了此时<code>group se</code>还没有任何任务。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void init_entity_runnable_average(struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_avg *sa &#x3D; &amp;se-&gt;avg;</span><br><span class="line"></span><br><span class="line">	memset(sa, 0, sizeof(*sa));</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Tasks are initialized with full load to be seen as heavy tasks until</span><br><span class="line">	 * they get a chance to stabilize to their real load level.</span><br><span class="line">	 * Group entities are initialized with zero load to reflect the fact that</span><br><span class="line">	 * nothing has been attached to the task group yet.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (entity_is_task(se))</span><br><span class="line">		sa-&gt;runnable_load_avg &#x3D; sa-&gt;load_avg &#x3D; scale_load_down(se-&gt;load.weight);</span><br><span class="line"></span><br><span class="line">	se-&gt;runnable_weight &#x3D; se-&gt;load.weight;</span><br><span class="line"></span><br><span class="line">	&#x2F;* when this task enqueue&#39;ed, it will contribute to its cfs_rq&#39;s load_avg *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="那么如何计算当前se的负载？"><a href="#那么如何计算当前se的负载？" class="headerlink" title="那么如何计算当前se的负载？"></a>那么如何计算当前se的负载？</h2><p>假设一个task从0时刻一直开始运行，在1022us时刻负载是多少？<br>由于还没有之前运行周期可以凑满1024us 一个衰减周期，所以负载是1022，<br>又运行了10us之后负载应该如何计算？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L  &#x3D; (10 - (1024 - 1022)) +(1024 - 1022 + 1022)y</span><br><span class="line">   &#x3D; (10 -2) + (1022 + 2) * y1</span><br><span class="line">   &#x3D; 8 +  1024 *  y1</span><br></pre></td></tr></table></figure>

<p>假设上一时刻负载贡献是u，经历d时间后的负载贡献如何计算呢？根据上面的例子，我们可以把时间d分成3和部分：<br>d1是离当前时间最远（不完整的）period 的剩余部分，d2 是完整period时间，而d3是（不完整的）当前 period 的剩余部分。<br>假设时间d是经过p个周期（d=d1+d2+d3, p=1+d2/1024）。d1，d2，d3 的示意图如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">      d1          d2           d3</span><br><span class="line">      ^           ^            ^</span><br><span class="line">      |           |            |</span><br><span class="line">    |&lt;-&gt;|&lt;-----------------&gt;|&lt;---&gt;|</span><br><span class="line">|---x---|------| ... |------|-----x (now)</span><br><span class="line">    |</span><br><span class="line">   u时刻</span><br><span class="line"></span><br><span class="line">u&#39;  &#x3D; (u + d1) y^p + 1024 * (y^1 + y^2 + ...  + y^p-1) + d3 * y^0</span><br><span class="line">                           p-1</span><br><span class="line">    &#x3D; (u + d1) y^p + 1024 \Sum y^n + d3 y^0</span><br><span class="line">                           n&#x3D;1</span><br><span class="line"></span><br><span class="line">    &#x3D; u y^p +                                 ---&gt; Step1</span><br><span class="line">                     p-1</span><br><span class="line">    &#x3D; d1 y^p + 1024 \Sum y^n + d3 y^0         ---&gt; Step2</span><br><span class="line">                     n&#x3D;1</span><br></pre></td></tr></table></figure>


<p>kernel中是用 <code>accumulate_sum()</code> 实现这个当前时刻负载计算的</p>
<ol>
<li>period_contrib记录的是上次更新负载不足1024us周期的时间。delta是经过的时间，为了计算经过的周期个数需要加上period_contrib，然后整除1024。</li>
<li>计算周期个数</li>
<li>调用decay_load()函数计算公式中的step1部分</li>
<li>__accumulate_pelt_segments()负责计算公式step2部分</li>
<li>更新period_contrib为本次不足1024us部分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">static u32 __accumulate_pelt_segments(u64 periods, u32 d1, u32 d3)</span><br><span class="line">&#123;</span><br><span class="line">	u32 c1, c2, c3 &#x3D; d3; &#x2F;* y^0 &#x3D;&#x3D; 1 *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * c1 &#x3D; d1 y^p</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	c1 &#x3D; decay_load((u64)d1, periods);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 *            p-1</span><br><span class="line">	 * c2 &#x3D; 1024 \Sum y^n</span><br><span class="line">	 *            n&#x3D;1</span><br><span class="line">	 *</span><br><span class="line">	 *              inf        inf</span><br><span class="line">	 *    &#x3D; 1024 ( \Sum y^n - \Sum y^n - y^0 )</span><br><span class="line">	 *              n&#x3D;0        n&#x3D;p</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	c2 &#x3D; LOAD_AVG_MAX - decay_load(LOAD_AVG_MAX, periods) - 1024;</span><br><span class="line"></span><br><span class="line">	return c1 + c2 + c3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Accumulate the three separate parts of the sum; d1 the remainder</span><br><span class="line"> * of the last (incomplete) period, d2 the span of full periods and d3</span><br><span class="line"> * the remainder of the (incomplete) current period.</span><br><span class="line"> *</span><br><span class="line"> *           d1          d2           d3</span><br><span class="line"> *           ^           ^            ^</span><br><span class="line"> *           |           |            |</span><br><span class="line"> *         |&lt;-&gt;|&lt;-----------------&gt;|&lt;---&gt;|</span><br><span class="line"> * ... |---x---|------| ... |------|-----x (now)</span><br><span class="line"> *</span><br><span class="line"> *                           p-1</span><br><span class="line"> * u&#39; &#x3D; (u + d1) y^p + 1024 \Sum y^n + d3 y^0</span><br><span class="line"> *                           n&#x3D;1</span><br><span class="line"> *</span><br><span class="line"> *    &#x3D; u y^p +					(Step 1)</span><br><span class="line"> *</span><br><span class="line"> *                     p-1</span><br><span class="line"> *      d1 y^p + 1024 \Sum y^n + d3 y^0		(Step 2)</span><br><span class="line"> *                     n&#x3D;1</span><br><span class="line"> *&#x2F;</span><br><span class="line">static __always_inline u32</span><br><span class="line">accumulate_sum(u64 delta, struct sched_avg *sa,</span><br><span class="line">	       unsigned long load, unsigned long runnable, int running)</span><br><span class="line">&#123;</span><br><span class="line">	u32 contrib &#x3D; (u32)delta; &#x2F;* p &#x3D;&#x3D; 0 -&gt; delta &lt; 1024 *&#x2F;</span><br><span class="line">	u64 periods;</span><br><span class="line"></span><br><span class="line">	delta +&#x3D; sa-&gt;period_contrib;</span><br><span class="line">	periods &#x3D; delta &#x2F; 1024; &#x2F;* A period is 1024us (~1ms) *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Step 1: decay old *_sum if we crossed period boundaries.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (periods) &#123;</span><br><span class="line">		sa-&gt;load_sum &#x3D; decay_load(sa-&gt;load_sum, periods);</span><br><span class="line">		sa-&gt;runnable_load_sum &#x3D;</span><br><span class="line">			decay_load(sa-&gt;runnable_load_sum, periods);</span><br><span class="line">		sa-&gt;util_sum &#x3D; decay_load((u64)(sa-&gt;util_sum), periods);</span><br><span class="line"></span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * Step 2</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		delta %&#x3D; 1024;</span><br><span class="line">		contrib &#x3D; __accumulate_pelt_segments(periods,</span><br><span class="line">				1024 - sa-&gt;period_contrib, delta);</span><br><span class="line">	&#125;</span><br><span class="line">	sa-&gt;period_contrib &#x3D; delta;</span><br><span class="line"></span><br><span class="line">	if (load)</span><br><span class="line">		sa-&gt;load_sum +&#x3D; load * contrib;</span><br><span class="line">	if (runnable)</span><br><span class="line">		sa-&gt;runnable_load_sum +&#x3D; runnable * contrib;</span><br><span class="line">	if (running)</span><br><span class="line">		sa-&gt;util_sum +&#x3D; contrib &lt;&lt; SCHED_CAPACITY_SHIFT;</span><br><span class="line"></span><br><span class="line">	return periods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p>其中 <code>___update_load_sum()</code> 函数 计算的都是<em>sum</em>负载总和，函数返回值是</p>
<ol>
<li>0，如果和上次更新时间之间 没有 经历过一次完整的period</li>
<li>1，如果和上次更新时间之间 经历过一次完整的period</li>
</ol>
<p>如果经历过一个 <code>full period</code>之后，就需要更新 <code>load_avg</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline void</span><br><span class="line">___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)</span><br><span class="line">&#123;</span><br><span class="line">	u32 divider &#x3D; LOAD_AVG_MAX - 1024 + sa-&gt;period_contrib;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Step 2: update *_avg.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	sa-&gt;load_avg &#x3D; div_u64(load * sa-&gt;load_sum, divider);</span><br><span class="line">	sa-&gt;runnable_load_avg &#x3D;	div_u64(runnable * sa-&gt;runnable_load_sum, divider);</span><br><span class="line">	WRITE_ONCE(sa-&gt;util_avg, sa-&gt;util_sum &#x2F; divider);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __update_load_avg_se(u64 now, struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	if (___update_load_sum(now, &amp;se-&gt;avg, !!se-&gt;on_rq, !!se-&gt;on_rq,</span><br><span class="line">				cfs_rq-&gt;curr &#x3D;&#x3D; se)) &#123;</span><br><span class="line"></span><br><span class="line">		___update_load_avg(&amp;se-&gt;avg, se_weight(se), se_runnable(se));</span><br><span class="line">		cfs_se_util_change(&amp;se-&gt;avg);</span><br><span class="line">		trace_pelt_se_tp(se);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>                      |&lt;--1024--&gt;|</code></pre>
<p>|———————————————|—|——|<br>                          |-|-|<br>                      period_contrib</p>
<p>divider = LOAD_AVG_MAX - (1024 - period_contrib)<br>    = LOAD_AVG_MAX - 1024 + period_contrib</p>
<p>可以大概理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load_avg &#x3D; load_weight * (load_sum &#x2F;  time_sum)</span><br><span class="line">util_avg &#x3D; util_sum &#x2F; time_sum</span><br></pre></td></tr></table></figure>


<p>当一个task一直运行，负载足够高时，可以认为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load_sum &#x3D;&#x3D;  time_sum</span><br><span class="line">util_sum &#x3D;&#x3D; time_sum</span><br><span class="line">load_avg &#x3D; load_weight</span><br><span class="line">util_avg &#x3D; 1</span><br></pre></td></tr></table></figure>

<h2 id="如何计算当前cfs-rq的负载"><a href="#如何计算当前cfs-rq的负载" class="headerlink" title="如何计算当前cfs_rq的负载"></a>如何计算当前cfs_rq的负载</h2><p>我们跟踪<code>se</code>的负载，更多的想更精确的知道每时每刻 <code>rq</code>上有负载变化，从而对scheduler的行为作出指导。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">int __update_load_avg_cfs_rq(u64 now, struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	if (___update_load_sum(now, &amp;cfs_rq-&gt;avg,</span><br><span class="line">				scale_load_down(cfs_rq-&gt;load.weight),</span><br><span class="line">				scale_load_down(cfs_rq-&gt;runnable_weight),</span><br><span class="line">				cfs_rq-&gt;curr !&#x3D; NULL)) &#123;</span><br><span class="line"></span><br><span class="line">		___update_load_avg(&amp;cfs_rq-&gt;avg, 1, 1);</span><br><span class="line">		trace_pelt_cfs_tp(cfs_rq);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * update_cfs_rq_load_avg - update the cfs_rq&#39;s load&#x2F;util averages</span><br><span class="line"> * @now: current time, as per cfs_rq_clock_pelt()</span><br><span class="line"> * @cfs_rq: cfs_rq to update</span><br><span class="line"> *</span><br><span class="line"> * The cfs_rq avg is the direct sum of all its entities (blocked and runnable)</span><br><span class="line"> * avg. The immediate corollary is that all (fair) tasks must be attached, see</span><br><span class="line"> * post_init_entity_util_avg().</span><br><span class="line"> *</span><br><span class="line"> * cfs_rq-&gt;avg is used for task_h_load() and update_cfs_share() for example.</span><br><span class="line"> *</span><br><span class="line"> * Returns true if the load decayed or we removed load.</span><br><span class="line"> *</span><br><span class="line"> * Since both these conditions indicate a changed cfs_rq-&gt;avg.load we should</span><br><span class="line"> * call update_tg_load_avg() when this function returns true.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;*</span><br><span class="line"> * cfs_rq avg 是 cfs_rq中所有 entities 的 sum。</span><br><span class="line"> * 返回值：1 如果 有线程被移出这个 cfs_rq 或者经过了一个衰减周期</span><br><span class="line"> *        0</span><br><span class="line"> *&#x2F;</span><br><span class="line">static inline int</span><br><span class="line">update_cfs_rq_load_avg(u64 now, struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long removed_load &#x3D; 0, removed_util &#x3D; 0, removed_runnable_sum &#x3D; 0;</span><br><span class="line">	struct sched_avg *sa &#x3D; &amp;cfs_rq-&gt;avg;</span><br><span class="line">	int decayed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	if (cfs_rq-&gt;removed.nr) &#123;</span><br><span class="line">		unsigned long r;</span><br><span class="line">		u32 divider &#x3D; LOAD_AVG_MAX - 1024 + sa-&gt;period_contrib;</span><br><span class="line"></span><br><span class="line">		raw_spin_lock(&amp;cfs_rq-&gt;removed.lock);</span><br><span class="line">		swap(cfs_rq-&gt;removed.util_avg, removed_util);</span><br><span class="line">		swap(cfs_rq-&gt;removed.load_avg, removed_load);</span><br><span class="line">		swap(cfs_rq-&gt;removed.runnable_sum, removed_runnable_sum);</span><br><span class="line">		cfs_rq-&gt;removed.nr &#x3D; 0;</span><br><span class="line">		raw_spin_unlock(&amp;cfs_rq-&gt;removed.lock);</span><br><span class="line"></span><br><span class="line">		r &#x3D; removed_load;</span><br><span class="line">		sub_positive(&amp;sa-&gt;load_avg, r);</span><br><span class="line">		sub_positive(&amp;sa-&gt;load_sum, r * divider);</span><br><span class="line"></span><br><span class="line">		r &#x3D; removed_util;</span><br><span class="line">		sub_positive(&amp;sa-&gt;util_avg, r);</span><br><span class="line">		sub_positive(&amp;sa-&gt;util_sum, r * divider);</span><br><span class="line"></span><br><span class="line">		add_tg_cfs_propagate(cfs_rq, -(long)removed_runnable_sum);</span><br><span class="line"></span><br><span class="line">		decayed &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	decayed |&#x3D; __update_load_avg_cfs_rq(now, cfs_rq);</span><br><span class="line"></span><br><span class="line">#ifndef CONFIG_64BIT</span><br><span class="line">	smp_wmb();</span><br><span class="line">	cfs_rq-&gt;load_last_update_time_copy &#x3D; sa-&gt;last_update_time;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	return decayed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-21T11:00:00.000Z" title="4/21/2021, 7:00:00 PM">2021-04-21</time>发表</span><span class="level-item"><time dateTime="2021-04-21T06:12:55.960Z" title="4/21/2021, 2:12:55 PM">2021-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">10 分钟读完 (大约1461个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/21/schedule/ipi_sched/">ipi_sched</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p>IPI 中断 (Inter-Processor Interrupts) ，核间中断可以通过向这个寄存器写入需要的值来产生。若硬件线程 A 想要发送一个核间中断给硬件线程 B，它只需要向寄存器 IPIBase 中写入 B<br>的 Thread ID、中断向量、中断类型等值就可以了，PIC 会通知 B 所在的核挂起它当前的执行序列，并根据中断向量跳转到中断服务例程 ISR 的入口</p>
<h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW?"></a>HOW?</h2><p>linux上将 IPI 中断分为以下几类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum ipi_msg_type &#123;</span><br><span class="line">	IPI_RESCHEDULE,</span><br><span class="line">	IPI_CALL_FUNC,</span><br><span class="line">	IPI_CPU_STOP,</span><br><span class="line">	IPI_CPU_CRASH_STOP,</span><br><span class="line">	IPI_TIMER,</span><br><span class="line">	IPI_IRQ_WORK,</span><br><span class="line">	IPI_WAKEUP</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>通过接口 <code>smp_cross_call</code> 调用，For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void smp_send_reschedule(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	smp_cross_call(cpumask_of(cpu), IPI_RESCHEDULE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>CPUa 给 CPUb 发送一个 <code>IPI_RESCHEDULE</code> 信号，然后 CPUb执行相关函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Main handler for inter-processor interrupts</span><br><span class="line"> *&#x2F;</span><br><span class="line">void handle_IPI(int ipinr, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int cpu &#x3D; smp_processor_id();</span><br><span class="line">	struct pt_regs *old_regs &#x3D; set_irq_regs(regs);</span><br><span class="line"></span><br><span class="line">	switch (ipinr) &#123;</span><br><span class="line">	case IPI_RESCHEDULE:</span><br><span class="line">		scheduler_ipi();</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case IPI_CALL_FUNC:</span><br><span class="line">		irq_enter();</span><br><span class="line">		generic_smp_call_function_interrupt();</span><br><span class="line">		irq_exit();</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">	set_irq_regs(old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="scheduler-ipi-主要工作？"><a href="#scheduler-ipi-主要工作？" class="headerlink" title="scheduler_ipi 主要工作？"></a>scheduler_ipi 主要工作？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void scheduler_ipi(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting</span><br><span class="line">	 * TIF_NEED_RESCHED remotely (for the first time) will also send</span><br><span class="line">	 * this IPI.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	preempt_fold_need_resched();</span><br><span class="line"></span><br><span class="line">	if (llist_empty(&amp;this_rq()-&gt;wake_list) &amp;&amp; !got_nohz_idle_kick())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Not all reschedule IPI handlers call irq_enter&#x2F;irq_exit, since</span><br><span class="line">	 * traditionally all their work was done from the interrupt return</span><br><span class="line">	 * path. Now that we actually do some work, we need to make sure</span><br><span class="line">	 * we do call them.</span><br><span class="line">	 *</span><br><span class="line">	 * Some archs already do call them, luckily irq_enter&#x2F;exit nest</span><br><span class="line">	 * properly.</span><br><span class="line">	 *</span><br><span class="line">	 * Arguably we should visit all archs and update all handlers,</span><br><span class="line">	 * however a fair share of IPIs are still resched only so this would</span><br><span class="line">	 * somewhat pessimize the simple resched case.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	irq_enter();</span><br><span class="line">	sched_ttwu_pending();</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Check if someone kicked us for doing the nohz idle load balance.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (unlikely(got_nohz_idle_kick())) &#123;</span><br><span class="line">		this_rq()-&gt;idle_balance &#x3D; 1;</span><br><span class="line">		raise_softirq_irqoff(SCHED_SOFTIRQ);</span><br><span class="line">	&#125;</span><br><span class="line">	irq_exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>llist_empty(&amp;this_rq()-&gt;wake_list)</code> 成立，意味着rq上没有需要wake_up的thread，且同时 <code>!got_nohz_idle_kick()</code>也成立的话，就直接返回了，这个 IPI就是无效的。</p>
<p>正常都会继续往下继续走，重点是 <code>sched_ttwu_pending</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void sched_ttwu_pending(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; this_rq();</span><br><span class="line">	struct llist_node *llist &#x3D; llist_del_all(&amp;rq-&gt;wake_list);</span><br><span class="line">	struct task_struct *p, *t;</span><br><span class="line">	struct rq_flags rf;</span><br><span class="line"></span><br><span class="line">	if (!llist)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">        &#x2F;&#x2F; 一次性唤醒所有 &#96;wake_list&#96; 上的task。</span><br><span class="line">	llist_for_each_entry_safe(p, t, llist, wake_entry)</span><br><span class="line">		ttwu_do_activate(rq, p, p-&gt;sched_remote_wakeup ? WF_MIGRATED : 0, &amp;rf);</span><br><span class="line"></span><br><span class="line">	rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后查看是否需要做 <code>load_balance</code></p>
<h2 id="什么情况下会发送-IPI-RESCHEDULE？"><a href="#什么情况下会发送-IPI-RESCHEDULE？" class="headerlink" title="什么情况下会发送 IPI_RESCHEDULE？"></a>什么情况下会发送 IPI_RESCHEDULE？</h2><ol>
<li>resched_curr()<br>如果cpu == smp_processor_id()，(这里分为俩种情况，1. UP架构只有一个CPU 2. SMP架构上恰好resched_curr()的是本cpu)<br>那仅仅是设置 当前 curr的thread_info的 need_resched标志位。<br>如果是需要其他cpu执行 resched_curr()，就需要 <code>smp_send_reschedule(cpu)</code> 来发送 <code>IPI_RESCHEDULE</code>了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * resched_curr - mark rq&#39;s current task &#39;to be rescheduled now&#39;.</span><br><span class="line"> *</span><br><span class="line"> * On UP this means the setting of the need_resched flag, on SMP it</span><br><span class="line"> * might also involve a cross-CPU call to trigger the scheduler on</span><br><span class="line"> * the target CPU.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void resched_curr(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *curr &#x3D; rq-&gt;curr;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	if (test_tsk_need_resched(curr))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	cpu &#x3D; cpu_of(rq);</span><br><span class="line"></span><br><span class="line">	if (cpu &#x3D;&#x3D; smp_processor_id()) &#123;</span><br><span class="line">		set_tsk_need_resched(curr);</span><br><span class="line">		set_preempt_need_resched();</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (set_nr_and_not_polling(curr))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	else</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li>wake_up_idle_cpu()</li>
</ol>
<p>在唤醒一个 idle的cpu时，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void wake_up_idle_cpu(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	if (cpu &#x3D;&#x3D; smp_processor_id())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (set_nr_and_not_polling(rq-&gt;idle))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	else</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>kick_process()</li>
</ol>
<p>让一个 task立刻进入 kernel mode（without any delay），从而来处理 signal信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> * kick_process - kick a running thread to enter&#x2F;exit the kernel</span><br><span class="line"> * @p: the to-be-kicked thread</span><br><span class="line"> *</span><br><span class="line"> * Cause a process which is running on another CPU to enter</span><br><span class="line"> * kernel-mode, without any delay. (to get signals handled.)</span><br><span class="line"> *</span><br><span class="line"> * NOTE: this function doesn&#39;t have to take the runqueue lock,</span><br><span class="line"> * because all it wants to ensure is that the remote task enters</span><br><span class="line"> * the kernel. If the IPI races and the task has been migrated</span><br><span class="line"> * to another CPU then no harm is done and the purpose has been</span><br><span class="line"> * achieved as well.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void kick_process(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu &#x3D; task_cpu(p);</span><br><span class="line">	if ((cpu !&#x3D; smp_processor_id()) &amp;&amp; task_curr(p))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(kick_process);</span><br><span class="line"></span><br><span class="line">void signal_wake_up_state(struct task_struct *t, unsigned int state)</span><br><span class="line">&#123;</span><br><span class="line">	set_tsk_thread_flag(t, TIF_SIGPENDING);</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * TASK_WAKEKILL also means wake it up in the stopped&#x2F;traced&#x2F;killable</span><br><span class="line">	 * case. We don&#39;t check t-&gt;state here because there is a race with it</span><br><span class="line">	 * executing another processor and just now entering stopped state.</span><br><span class="line">	 * By using wake_up_state, we ensure the process will wake up and</span><br><span class="line">	 * handle its death signal.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!wake_up_state(t, state | TASK_INTERRUPTIBLE))</span><br><span class="line">		kick_process(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>ttwu_queue_remote()</li>
</ol>
<p>try_to_wake_up() 一个thread之后，需要将 这个task入队<br>a. 如果是 task不是在 <code>本cpu</code> 唤醒的，那就需要IPI中断<code>smp_send_reschedule</code>来搞了<br>b. 如果是在 <code>本地cpu</code> 唤醒的，就直接 lock_rq() 之后进行 <code>ttwu_do_activate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static void ttwu_queue_remote(struct task_struct *p, int cpu, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	p-&gt;sched_remote_wakeup &#x3D; !!(wake_flags &amp; WF_MIGRATED);</span><br><span class="line"></span><br><span class="line">	if (llist_add(&amp;p-&gt;wake_entry, &amp;cpu_rq(cpu)-&gt;wake_list)) &#123;</span><br><span class="line">		if (!set_nr_if_polling(rq-&gt;idle))</span><br><span class="line">			smp_send_reschedule(cpu);</span><br><span class="line">		else</span><br><span class="line">			trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void ttwu_queue(struct task_struct *p, int cpu, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line">	struct rq_flags rf;</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_SMP)</span><br><span class="line">	if (sched_feat(TTWU_QUEUE) &amp;&amp; !cpus_share_cache(smp_processor_id(), cpu)) &#123;</span><br><span class="line">		sched_clock_cpu(cpu); &#x2F;* Sync clocks across CPUs *&#x2F;</span><br><span class="line">		ttwu_queue_remote(p, cpu, wake_flags);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	ttwu_do_activate(rq, p, wake_flags, &amp;rf);</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>wake_up_if_idle()<br><code>wake_up_if_idle()</code> 只有在 <code>wake_up_all_idle_cpus()</code> 中被调用，主要是看此 cpu 是否idle空闲，就是看他 <code>is_idle_task(cpu_rq(cpu)-&gt;curr)</code> 是否成立，成立的话就需要 IPI中断去唤醒。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void wake_up_if_idle(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line">	struct rq_flags rf;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	if (!is_idle_task(rcu_dereference(rq-&gt;curr)))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	if (set_nr_if_polling(rq-&gt;idle)) &#123;</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">		if (is_idle_task(rq-&gt;curr))</span><br><span class="line">			smp_send_reschedule(cpu);</span><br><span class="line">		&#x2F;* Else CPU is not idle, do nothing here: *&#x2F;</span><br><span class="line">		rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void wake_up_all_idle_cpus(void)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	for_each_online_cpu(cpu) &#123;</span><br><span class="line">		if (cpu &#x3D;&#x3D; smp_processor_id())</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		wake_up_if_idle(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>參考linux-5.4.61代码</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-15T11:00:00.000Z" title="4/15/2021, 7:00:00 PM">2021-04-15</time>发表</span><span class="level-item"><time dateTime="2021-04-15T02:37:17.900Z" title="4/15/2021, 10:37:17 AM">2021-04-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/frequency-governer/">frequency governer</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/frequency-governer/schedule-util/">schedule util</a></span><span class="level-item">几秒读完 (大约12个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/15/schedule/freq%20governer/">freq governer</a></h1><div class="content"><p>参考<a href="Documentation/admin-guide/pm/cpufreq.rst">内核文档</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-12T11:00:00.000Z" title="4/12/2021, 7:00:00 PM">2021-04-12</time>发表</span><span class="level-item"><time dateTime="2021-04-21T08:09:37.140Z" title="4/21/2021, 4:09:37 PM">2021-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">6 分钟读完 (大约886个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/12/schedule/sched_domain%20and%20root_domain/">sched_domain and root_domain</a></h1><div class="content"><h2 id="root-domain"><a href="#root-domain" class="headerlink" title="root_domain"></a>root_domain</h2><p><code>root_domain</code> 相对于 <code>sched_domain</code> 来说简单很多， 这是描述一个cpu集合的 数据结构。<br>每个 <code>cpuset</code> 都会拥有一个 <code>root_domain</code>，无论何时何地 <code>cpuset</code>被创建，同时会创建 并 attach 一个 root_domain结构。<br>一个  <code>root_domain</code> 可能包含多个cpu，且这些cpu的能效不一定是一致的，所以内嵌了<code>perf_domain</code> 结构来描述这种差异。</p>
<p><code>perf_domain</code> 的<code>next</code> 指针 就这样将这个<code>root_domain</code> 中的<code>perf_domain</code> 连接起来了。<br>具有同一能效模型的俩cpu(在同一cluster上)，共享一个 <code>em_perf_domain</code> 能效模型结构，但是 <code>perf_domain</code>可能是分开的，因为这俩cpu可能是属于不同<code>root_domain</code>的。</p>
<p>参考 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/scheduler/sched-energy.html">kernel 文档</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">The lists are attached to the root domains in order to cope with exclusive cpuset configurations. Since the boundaries of exclusive cpusets do not necessarily match those of performance domains, the lists of different root domains can contain duplicate elements.</span><br><span class="line"></span><br><span class="line">Example 1.</span><br><span class="line">Let us consider a platform with 12 CPUs, split in 3 performance domains (pd0, pd4 and pd8), organized as follows:</span><br><span class="line"></span><br><span class="line">CPUs:   0 1 2 3 4 5 6 7 8 9 10 11</span><br><span class="line">PDs:   |--pd0--|--pd4--|---pd8---|</span><br><span class="line">RDs:   |----rd1----|-----rd2-----|</span><br><span class="line">Now, consider that userspace decided to split the system with two exclusive cpusets, hence creating two independent root domains, each containing 6 CPUs. The two root domains are denoted rd1 and rd2 in the above figure. Since pd4 intersects with both rd1 and rd2, it will be present in the linked list ‘-&gt;pd’ attached to each of them:</span><br><span class="line">rd1-&gt;pd: pd0 -&gt; pd4</span><br><span class="line">rd2-&gt;pd: pd4 -&gt; pd8</span><br><span class="line"></span><br><span class="line">Please note that the scheduler will create two duplicate list nodes for pd4 (one for each list). However, both just hold a pointer to the same shared data structure of the EM framework.</span><br><span class="line"></span><br><span class="line">Since the access to these lists can happen concurrently with hotplug and other things, they are protected by RCU, like the rest of topology structures manipulated by the scheduler.</span><br><span class="line"></span><br><span class="line">EAS also maintains a static key (sched_energy_present) which is enabled when at least one root domain meets all conditions for EAS to start. Those conditions are summarized in Section 6.</span><br></pre></td></tr></table></figure>

<p>这是 <code>root_domain</code> 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">struct perf_domain &#123;</span><br><span class="line">	struct em_perf_domain *em_pd;</span><br><span class="line">	struct perf_domain *next;</span><br><span class="line">	struct rcu_head rcu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * We add the notion of a root-domain which will be used to define per-domain</span><br><span class="line"> * variables. Each exclusive cpuset essentially defines an island domain by</span><br><span class="line"> * fully partitioning the member CPUs from any other cpuset. Whenever a new</span><br><span class="line"> * exclusive cpuset is created, we also create and attach a new root-domain</span><br><span class="line"> * object.</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct root_domain &#123;</span><br><span class="line">	atomic_t		refcount;</span><br><span class="line">	atomic_t		rto_count;</span><br><span class="line">	struct rcu_head		rcu;</span><br><span class="line">	cpumask_var_t		span;</span><br><span class="line">	cpumask_var_t		online;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Indicate pullable load on at least one CPU, e.g:</span><br><span class="line">	 * - More than one runnable task</span><br><span class="line">	 * - Running task is misfit</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	int			overload;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Indicate one or more cpus over-utilized (tipping point) *&#x2F;</span><br><span class="line">	int			overutilized;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The bit corresponding to a CPU gets set here if such CPU has more</span><br><span class="line">	 * than one runnable -deadline task (as it is below for RT tasks).</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	cpumask_var_t		dlo_mask;</span><br><span class="line">	atomic_t		dlo_count;</span><br><span class="line">	struct dl_bw		dl_bw;</span><br><span class="line">	struct cpudl		cpudl;</span><br><span class="line"></span><br><span class="line">#ifdef HAVE_RT_PUSH_IPI</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * For IPI pull requests, loop across the rto_mask.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct irq_work		rto_push_work;</span><br><span class="line">	raw_spinlock_t		rto_lock;</span><br><span class="line">	&#x2F;* These are only updated and read within rto_lock *&#x2F;</span><br><span class="line">	int			rto_loop;</span><br><span class="line">	int			rto_cpu;</span><br><span class="line">	&#x2F;* These atomics are updated outside of a lock *&#x2F;</span><br><span class="line">	atomic_t		rto_loop_next;</span><br><span class="line">	atomic_t		rto_loop_start;</span><br><span class="line">#endif</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The &quot;RT overload&quot; flag: it gets set if a CPU has more than</span><br><span class="line">	 * one runnable RT task.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	cpumask_var_t		rto_mask;</span><br><span class="line">	struct cpupri		cpupri;</span><br><span class="line"></span><br><span class="line">	unsigned long		max_cpu_capacity;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * NULL-terminated list of performance domains intersecting with the</span><br><span class="line">	 * CPUs of the rd. Protected by RCU.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct perf_domain __rcu *pd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="sched-domain-WHAT"><a href="#sched-domain-WHAT" class="headerlink" title="sched domain: WHAT?"></a>sched domain: WHAT?</h2><h2 id="sched-domain-如何标识？"><a href="#sched-domain-如何标识？" class="headerlink" title="sched domain: 如何标识？"></a>sched domain: 如何标识？</h2><p><code>include/linux/sched/sd_flags.h</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SDF_SHARED_CHILD       0x1</span><br><span class="line">#define SDF_SHARED_PARENT      0x2</span><br><span class="line">#define SDF_NEEDS_GROUPS       0x4</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SD_FLAG(SD_BALANCE_NEWIDLE, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_BALANCE_EXEC, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_BALANCE_FORK, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_BALANCE_WAKE, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_WAKE_AFFINE, SDF_SHARED_CHILD)</span><br><span class="line">SD_FLAG(SD_ASYM_CPUCAPACITY, SDF_SHARED_PARENT | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_SHARE_CPUCAPACITY, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_SHARE_PKG_RESOURCES, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_SERIALIZE, SDF_SHARED_PARENT | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_ASYM_PACKING, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_PREFER_SIBLING, SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_OVERLAP, SDF_SHARED_PARENT | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_NUMA, SDF_SHARED_PARENT | SDF_NEEDS_GROUPS)</span><br></pre></td></tr></table></figure>


</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-12T11:00:00.000Z" title="4/12/2021, 7:00:00 PM">2021-04-12</time>发表</span><span class="level-item"><time dateTime="2021-04-13T07:07:27.891Z" title="4/13/2021, 3:07:27 PM">2021-04-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/deadline-schedule/">deadline schedule</a></span><span class="level-item">6 分钟读完 (大约948个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/12/schedule/%E7%BF%BB%E8%AF%91/Capacity%20awareness%20for%20the%20deadline%20scheduler/">Capacity awareness for the deadline scheduler</a></h1><div class="content"><h2 id="What-is-CPU-Capacity"><a href="#What-is-CPU-Capacity" class="headerlink" title="What is CPU Capacity?"></a>What is CPU Capacity?</h2><h2 id="What-is-Capacity-awareness"><a href="#What-is-Capacity-awareness" class="headerlink" title="What is Capacity awareness"></a>What is Capacity awareness</h2><p>Capacity Awareness refers to the fact that on heterogeneous systems<br>(like Arm big.LITTLE), the capacity of the CPUs is not uniform, hence<br>when placing tasks we need to be aware of this difference of CPU<br>capacities.<br>容量意识是指在异构系统上（例如Arm big.LITTLE），CPU的容量不一致，因此<br>在放置任务时，我们需要意识到CPU的这种差异能力。</p>
<h2 id="RT-scheduler-遇到的问题"><a href="#RT-scheduler-遇到的问题" class="headerlink" title="RT scheduler 遇到的问题"></a>RT scheduler 遇到的问题</h2><p>参考<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=804d402fb6f6">sched/rt: Make RT capacity-aware</a></p>
<p>在ARM big.LITTLE情况下，我们要确保所选的CPU有足够的Capacity，满足运行任务运行的要求，可以理解为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capacity_orig_of（cpu）&gt; &#x3D; task.requirement。</span><br></pre></td></tr></table></figure>
<ol>
<li><p>对于CFS来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capacity_orig_of(cpu) &gt;&#x3D; cfs_task.util</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于 deadline来说：(虽然还没有这个机制，但是可以使用bandwidth<br>reservation实现)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capacity_orig_of(cpu)&#x2F;SCHED_CAPACITY &gt;&#x3D; dl_deadline&#x2F;dl_runtime</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于RT，我们没有跟踪Per-task的CPU利用率，并且我们没有任何需求 去跟踪 RT-task对性能的要求。 但是随着uclamp的引入，RT任务现在可以控制通过设置uclamp_min来保证最低性能点。</p>
</li>
</ol>
<h2 id="Deadline-scheduler-遇到的问题"><a href="#Deadline-scheduler-遇到的问题" class="headerlink" title="Deadline scheduler 遇到的问题"></a>Deadline scheduler 遇到的问题</h2><p>参考<a target="_blank" rel="noopener" href="https://lwn.net/Articles/821578/">LWN文章</a><br>linux deadline scheduler 将cpu分配给deadline 调度类的task，确保每个task不会逾期，这在SMP系统上很容易办到，但是在arm的 big.LITTLE系统中这变得很复杂，因为一个task假设在big core上需要运行50ms，在LITTLE core上可能需要运行100ms。在scheduler 不能感知到这些 big.LITTLE core的算力差异的时候，deadline的选核操作就有很大问题，会导致一些task被调度到小核上去，task由于小核算力不足导致最后逾期。</p>
<p>deadline schedule中缺少的信息是对CPU容量（CPU Capacity）的了解-在给定时间内可以执行的指令数。CPU capacity已经在 load balancing和其他场景中使用了。</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. [Telling the scheduler about thermal pressure](https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;788380&#x2F;)</span><br><span class="line"></span><br><span class="line">2. [CPU capacity Usage in rt scheduler](https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;commit&#x2F;?id&#x3D;804d402fb6f6)</span><br></pre></td></tr></table></figure>

<p>Eggemann’s的工作主要是让 task placement 算法 考虑了不通CPU的 Capacity的差异，加上他的patch之后，deadline scheduler不管是选择到了big core还是 LITTLE core，都会满足 task的算力要求。</p>
<h2 id="具体改了啥？"><a href="#具体改了啥？" class="headerlink" title="具体改了啥？"></a>具体改了啥？</h2><p>admission-control 主要是基于系统中CPU总算力决定的。</p>
<ol>
<li>在SMP系统中，单个CPU 容量是c, 系统中有x个cpu，系统总算力C = x * c。</li>
<li>AMP系统中，x个big core，单个容量是c1，y个LITTLE core，单个容量是c2，系统总算力C = x * c1 + y * c2。</li>
</ol>
<p>deadline scheduler的task-placement 还必须更好地了解系统的CPU拓扑。 在将任务移至新CPU之前，调度程序需要确保新CPU可以处理该任务。 在AMP中，需要有新的方法检查从一个cpu a迁移出的task到 cpu b，b的CPU Capacity满足task的要求，使用以下公式执行 fitness check：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(CPU capacity) &#x2F; 1024 &gt;&#x3D; (task runtime) &#x2F; (task deadline)</span><br><span class="line">                    |</span><br><span class="line"></span><br><span class="line">cap            &gt;&gt; 10  &gt;&#x3D; (p-&gt;dl.dl_runtime) &#x2F; (p-&gt;dl.dl_deadline)</span><br><span class="line">                    |</span><br><span class="line"></span><br><span class="line">(cap &gt;&gt; 10) * p-&gt;dl.dl_deadline  &gt;&#x3D;  p-&gt;dl.dl_runtime</span><br><span class="line">                    |</span><br><span class="line"></span><br><span class="line">(cap * p-&gt;dl.dl_deadline)  &gt;&gt; 10  &gt;&#x3D;  p-&gt;dl.dl_runtime</span><br><span class="line">                    |</span><br><span class="line"></span><br><span class="line">cap_scale(p-&gt;dl.dl_deadline, cap) &gt;&#x3D; p-&gt;dl.dl_runtime;</span><br></pre></td></tr></table></figure>

<p>对应<code>kernel/sched/sched.h</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define cap_scale(v, s) ((v)*(s) &gt;&gt; SCHED_CAPACITY_SHIFT)</span><br><span class="line"></span><br><span class="line">static inline bool dl_task_fits_capacity(struct task_struct *p, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long cap &#x3D; arch_scale_cpu_capacity(cpu);</span><br><span class="line"></span><br><span class="line">	return cap_scale(p-&gt;dl.dl_deadline, cap) &gt;&#x3D; p-&gt;dl.dl_runtime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="这个改动会影响啥"><a href="#这个改动会影响啥" class="headerlink" title="这个改动会影响啥"></a>这个改动会影响啥</h2><ol>
<li>waking up a deadline task</li>
<li>moving a deadline task to a different CPU</li>
<li>migrating a task out of a CPU that is going offline</li>
</ol>
<p>都会检查 target cpu的 Capacity 是否满足task 的deadline条件。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-12T11:00:00.000Z" title="4/12/2021, 7:00:00 PM">2021-04-12</time>发表</span><span class="level-item"><time dateTime="2021-04-02T09:36:11.503Z" title="4/2/2021, 5:36:11 PM">2021-04-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">6 分钟读完 (大约844个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/12/schedule/sched%20concepts/">sched concepts</a></h1><div class="content"><h2 id="EAS"><a href="#EAS" class="headerlink" title="EAS"></a>EAS</h2><p>what?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This patch series introduces Energy Aware Scheduling (EAS) for CFS tasks</span><br><span class="line">on platforms with asymmetric CPU topologies (e.g. Arm big.LITTLE).</span><br></pre></td></tr></table></figure>
<p>参考 <a target="_blank" rel="noopener" href="https://lore.kernel.org/lkml/20181016101513.26919-1-quentin.perret@arm.com/">lkml EAS cover letter</a><br>参考 <a target="_blank" rel="noopener" href="https://marc.info/?l=linux-kernel&m=153243513908731&w=2">lkml EAS overall design V5</a></p>
<h2 id="misfit"><a href="#misfit" class="headerlink" title="misfit"></a>misfit</h2><p>应该是指 task运行位置不合适：<br>运行 此 task需要的算力 比 当前 CPU or rq的最大算力还要高，实际代码里面使用的是<br>task需求算力  &lt;  （CPU 最大算力 * 1.2）？</p>
<p>task需求算力如何计算：<br>uclamp_task_util(p)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * The margin used when comparing utilization with CPU capacity.</span><br><span class="line"> *</span><br><span class="line"> * (default: ~20%)</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define fits_capacity(cap, max)	((cap) * 1280 &lt; (max) * 1024)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static inline int task_fits_capacity(struct task_struct *p, long capacity)</span><br><span class="line">&#123;</span><br><span class="line">	return fits_capacity(uclamp_task_util(p), capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if (task_fits_capacity(p, capacity_of(cpu_of(rq)))) &#123;</span><br><span class="line">		rq-&gt;misfit_task_load &#x3D; 0;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>




<h2 id="utilization-clamping"><a href="#utilization-clamping" class="headerlink" title="utilization clamping"></a>utilization clamping</h2><p>The main use-cases for utilization clamping are:</p>
<ul>
<li><p>boosting: better interactive response for small tasks which<br>are affecting the user experience.</p>
<p>Consider for example the case of a small control thread for an external<br>accelerator (e.g. GPU, DSP, other devices). Here, from the task utilization<br>the scheduler does not have a complete view of what the task’s requirements<br>are and, if it’s a small utilization task, it keeps selecting a more energy<br>efficient CPU, with smaller capacity and lower frequency, thus negatively<br>impacting the overall time required to complete task activations.</p>
</li>
<li><p>capping: increase energy efficiency for background tasks not affecting the<br>user experience.</p>
<p>Since running on a lower capacity CPU at a lower frequency is more energy<br>efficient, when the completion time is not a main goal, then capping the<br>utilization considered for certain (maybe big) tasks can have positive<br>effects, both on energy consumption and thermal headroom.<br>This feature allows also to make RT tasks more energy friendly on mobile<br>systems where running them on high capacity CPUs and at the maximum<br>frequency is not required.</p>
</li>
</ul>
<p>参考 <a target="_blank" rel="noopener" href="https://lwn.net/Articles/791682/">LWN 文章-Add utilization clamping support</a></p>
<h2 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h2><p>WHY?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dedicating a CPU to a specific performance-critical process&#x2F;task is desired.</span><br></pre></td></tr></table></figure>
<p>需要将某些CPU 专用于 特定的性能关键的进程/任务。</p>
<p>HOW?<br>需要在boot的时候设置启动参数。<br>四核SMP系统上，加入需要 isolate CPU 0,1,2,3 中的 CPU2 与 CPU3，可以配置 kernel的启动参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isolcpus&#x3D;2,3</span><br></pre></td></tr></table></figure>

<p>完整启动参数是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   sudo qemu-system-x86_64 \</span><br><span class="line">-kernel &#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share&#x2F;stable&#x2F;bzImage \</span><br><span class="line">-hda &#x2F;home&#x2F;ubuntu&#x2F;myspace&#x2F;qemu_build&#x2F;stable_ubuntu.img \</span><br><span class="line">-append &quot;root&#x3D;&#x2F;dev&#x2F;sda5 console&#x3D;ttyS0 crashkernel&#x3D;256M isolcpus&#x3D;2,3&quot; \</span><br><span class="line">-smp 4 \</span><br><span class="line">-m 4096 \</span><br><span class="line">--enable-kvm \</span><br><span class="line">-net nic \</span><br><span class="line">-net user,hostfwd&#x3D;tcp::2222-:22 \</span><br><span class="line">--nographic \</span><br><span class="line">-fsdev local,id&#x3D;fs1,path&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share,security_model&#x3D;none \</span><br><span class="line">-device virtio-9p-pci,fsdev&#x3D;fs1,mount_tag&#x3D;host_share</span><br></pre></td></tr></table></figure>

<p>一旦系统用这个参数启动，进程/任务将不会被分配给或从指定的CPU，除非通过taskset或cset命令分配进程到 isolate的CPU。<br>在Linux上，可以使用taskset命令设置进程的CPU亲和度，使用cset命令设置进程的CPU亲和度。</p>
<p>可以使用 taskset 设置task的 cpu 亲和性<br>查看某个进程的亲和性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@wsl:~&#x2F;workspace&#x2F;linux-stable $ ps -aux | grep sleep</span><br><span class="line">ubuntu    4445  0.0  0.0  15276   824 tty2     S    11:19   0:00 sleep 1000</span><br><span class="line">ubuntu    4448  0.0  0.0  16208  1284 pts&#x2F;0    S    11:19   0:00 grep --color&#x3D;auto sleep</span><br><span class="line">ubuntu@wsl:~&#x2F;workspace&#x2F;linux-stable $ taskset -c -p 4445</span><br><span class="line">pid 4445&#39;s current affinity list: 0-11</span><br></pre></td></tr></table></figure>

<p>设置某个进程的亲和性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@wsl:~&#x2F;workspace&#x2F;linux-stable $ taskset -cp 1 4445</span><br><span class="line">pid 4445&#39;s current affinity list: 0-11</span><br><span class="line">pid 4445&#39;s new affinity list: 1</span><br><span class="line">ubuntu@wsl:~&#x2F;workspace&#x2F;linux-stable $ taskset -c -p 4445</span><br><span class="line">pid 4445&#39;s current affinity list: 1</span><br><span class="line">ubuntu@wsl:~&#x2F;workspace&#x2F;linux-stable $</span><br></pre></td></tr></table></figure>

<p>在server上实际测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试环境：0-3共有四核 CPU，启动时 isolate出2-3俩核心。</span><br><span class="line">1. 开机之后，0-1核 有正常task在跑，2-3核无任何 task。（此时task的 allow_cpumask都是 0-1）</span><br><span class="line">2. userspace &amp; kernelspace 的 cfs可以正常绑定到2-3核心，且可以正常跑</span><br><span class="line">3. userspace 与 kernelspace 的rt 进程均可绑定到2-3核心，且可以正常跑</span><br><span class="line">4. usespace 的 cfs绑定到0-3核心，可以跑到2-3核心上。</span><br></pre></td></tr></table></figure>
<p>参考 <a target="_blank" rel="noopener" href="https://www.suse.com/support/kb/doc/?id=000017747">Suse 的官方文档</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-09T11:00:00.000Z" title="4/9/2021, 7:00:00 PM">2021-04-09</time>发表</span><span class="level-item"><time dateTime="2021-09-02T01:51:27.712Z" title="9/2/2021, 9:51:27 AM">2021-09-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/qemu/">qemu</a></span><span class="level-item">5 分钟读完 (大约713个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/09/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/qemu%E5%90%AF%E5%8A%A8%E7%9A%84ubuntu%20img%E5%88%B6%E4%BD%9C/">qemu启动的ubuntu img制作</a></h1><div class="content"><h2 id="基础img是从哪里来？"><a href="#基础img是从哪里来？" class="headerlink" title="基础img是从哪里来？"></a>基础img是从哪里来？</h2><p>直接 wget <a target="_blank" rel="noopener" href="https://cloud-images.ubuntu.com/focal/20210407/">链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;cloud-images.ubuntu.com&#x2F;focal&#x2F;20210407&#x2F;focal-server-cloudimg-arm64.img</span><br></pre></td></tr></table></figure>

<p>参考<a target="_blank" rel="noopener" href="https://spyff.github.io/linux/2018/07/20/qemu-vm/">博客</a></p>
<h2 id="不替换kernel，如何启动这个kernel"><a href="#不替换kernel，如何启动这个kernel" class="headerlink" title="不替换kernel，如何启动这个kernel ???"></a>不替换kernel，如何启动这个kernel ???</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 \</span><br><span class="line">	-hda &#x2F;home&#x2F;ubuntu&#x2F;myspace&#x2F;qemu_build&#x2F;aarch64&#x2F;arm64_ubuntu.img \</span><br><span class="line">	-m 2048M \</span><br><span class="line">	-smp 4  \</span><br><span class="line">	-M virt \</span><br><span class="line">	-cpu cortex-a72 \</span><br><span class="line">	-net nic \</span><br><span class="line">	-net user,hostfwd&#x3D;tcp::2222-:22 \</span><br><span class="line">	-nographic</span><br></pre></td></tr></table></figure>


<h2 id="如何使用这个-img"><a href="#如何使用这个-img" class="headerlink" title="如何使用这个 img"></a>如何使用这个 img</h2><p>这个img是直接可以启动的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 \</span><br><span class="line">	-hda &#x2F;home&#x2F;ubuntu&#x2F;myspace&#x2F;qemu_build&#x2F;aarch64&#x2F;arm64_ubuntu.img \</span><br><span class="line">	-kernel &#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;linux-stable&#x2F;out&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;Image \</span><br><span class="line">	-append &quot;console&#x3D;ttyAMA0 root&#x3D;&#x2F;dev&#x2F;vda1&quot; \</span><br><span class="line">	-m 2048M \</span><br><span class="line">	-smp 4  \</span><br><span class="line">	-M virt \</span><br><span class="line">	-cpu cortex-a72 \</span><br><span class="line">	-net nic \</span><br><span class="line">	-net user,hostfwd&#x3D;tcp::2222-:22 \</span><br><span class="line">	-nographic</span><br></pre></td></tr></table></figure>

<p>但是由于是 <code>cloud img</code>，所以一开始无法使用账号密码登陆，也没法通过ssh登陆。<br>但是可以通过 <code>mount</code> 整个 img，将主机的 ssh的 id_rsa.pub 添加到 <code>cloud img</code>的 <code>authorized_keys</code>中，然后就可以通过 <code>ssh</code> 登陆了。</p>
<h2 id="How-to-mount-a-qcow2-disk-image-方法一"><a href="#How-to-mount-a-qcow2-disk-image-方法一" class="headerlink" title="How to mount a qcow2 disk image- 方法一"></a>How to mount a qcow2 disk image- 方法一</h2><p>This is a quick guide to mounting a qcow2 disk images on your host server. This is useful to reset passwords, edit files, or recover something without the virtual machine running.</p>
<h3 id="Step-1-Enable-NBD-on-the-Host"><a href="#Step-1-Enable-NBD-on-the-Host" class="headerlink" title="Step 1 - Enable NBD on the Host"></a>Step 1 - Enable NBD on the Host</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe nbd max_part&#x3D;8</span><br></pre></td></tr></table></figure>

<h3 id="Step-2-Connect-the-QCOW2-as-network-block-device"><a href="#Step-2-Connect-the-QCOW2-as-network-block-device" class="headerlink" title="Step 2 - Connect the QCOW2 as network block device"></a>Step 2 - Connect the QCOW2 as network block device</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-nbd --connect&#x3D;&#x2F;dev&#x2F;nbd0 &#x2F;var&#x2F;lib&#x2F;vz&#x2F;images&#x2F;100&#x2F;vm-100-disk-1.qcow2</span><br></pre></td></tr></table></figure>

<h3 id="Step-3-Find-The-Virtual-Machine-Partitions"><a href="#Step-3-Find-The-Virtual-Machine-Partitions" class="headerlink" title="Step 3 - Find The Virtual Machine Partitions"></a>Step 3 - Find The Virtual Machine Partitions</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk &#x2F;dev&#x2F;nbd0 -l</span><br></pre></td></tr></table></figure>

<h3 id="Step-4-Mount-the-partition-from-the-VM"><a href="#Step-4-Mount-the-partition-from-the-VM" class="headerlink" title="Step 4 - Mount the partition from the VM"></a>Step 4 - Mount the partition from the VM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;nbd0p1 &#x2F;mnt&#x2F;somepoint&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="Step-5-After-you-done-unmount-and-disconnect"><a href="#Step-5-After-you-done-unmount-and-disconnect" class="headerlink" title="Step 5 - After you done, unmount and disconnect"></a>Step 5 - After you done, unmount and disconnect</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">umount &#x2F;mnt&#x2F;somepoint&#x2F;</span><br><span class="line">qemu-nbd --disconnect &#x2F;dev&#x2F;nbd0</span><br><span class="line">rmmod nbd</span><br></pre></td></tr></table></figure>

<h2 id="How-to-mount-a-qcow2-disk-image-方法二"><a href="#How-to-mount-a-qcow2-disk-image-方法二" class="headerlink" title="How to mount a qcow2 disk image- 方法二"></a>How to mount a qcow2 disk image- 方法二</h2><h3 id="安装-libguestfs-tools"><a href="#安装-libguestfs-tools" class="headerlink" title="安装 libguestfs-tools"></a>安装 libguestfs-tools</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libguestfs-tools</span><br></pre></td></tr></table></figure>

<h3 id="help-libguestfs-tools"><a href="#help-libguestfs-tools" class="headerlink" title="help libguestfs-tools"></a>help libguestfs-tools</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:~&#x2F;workspace&#x2F;share&#x2F;simpleapp_hw_breakpoints $ guestmount --help</span><br><span class="line">guestmount: FUSE module for libguestfs</span><br><span class="line">guestmount lets you mount a virtual machine filesystem</span><br><span class="line">Copyright (C) 2009-2020 Red Hat Inc.</span><br><span class="line">Usage:</span><br><span class="line">  guestmount [--options] mountpoint</span><br><span class="line">Options:</span><br><span class="line">  -a|--add image       Add image</span><br><span class="line">  --blocksize[&#x3D;512|4096]</span><br><span class="line">                       Set sector size of the disk for -a option</span><br><span class="line">  -c|--connect uri     Specify libvirt URI for -d option</span><br><span class="line">  --dir-cache-timeout  Set readdir cache timeout (default 5 sec)</span><br><span class="line">  -d|--domain guest    Add disks from libvirt guest</span><br><span class="line">  --echo-keys          Don&#39;t turn off echo for passphrases</span><br><span class="line">  --fd&#x3D;FD              Write to pipe FD when mountpoint is ready</span><br><span class="line">  --format[&#x3D;raw|..]    Force disk format for -a option</span><br><span class="line">  --fuse-help          Display extra FUSE options</span><br><span class="line">  -i|--inspector       Automatically mount filesystems</span><br><span class="line">  --help               Display help message and exit</span><br><span class="line">  --key selector       Specify a LUKS key</span><br></pre></td></tr></table></figure>

<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo guestmount  -a userdata-qemu.img.qcow2 -m &#x2F;dev&#x2F;sda qcow2_mount_point</span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo guestunmount qcow2_mount_point</span><br></pre></td></tr></table></figure>


<h2 id="如何连接-到-img"><a href="#如何连接-到-img" class="headerlink" title="如何连接 到 img"></a>如何连接 到 img</h2><ol>
<li><p>ssh<br>添加key之后，可以直接使用 ssh连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -v ubuntu@127.0.0.1 -p 2222</span><br></pre></td></tr></table></figure>
<p>连接之后，可以添加账号密码，修改默认账号密码</p>
</li>
<li><p>账号密码</p>
</li>
</ol>
<h2 id="如何加大-img-size"><a href="#如何加大-img-size" class="headerlink" title="如何加大 img size"></a>如何加大 img size</h2><p>在长时间运行 安装软件 编译软件之后， img的size会越来越大，这时候最好可以扩展 img的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img resize ubuntu.img +10G</span><br></pre></td></tr></table></figure>

<h2 id="如何开启-numa-架构支持"><a href="#如何开启-numa-架构支持" class="headerlink" title="如何开启 numa 架构支持"></a>如何开启 numa 架构支持</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-x86_64 -kernel &#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;linux&#x2F;out&#x2F;arch&#x2F;x86&#x2F;boot&#x2F;bzImage -hda &#x2F;home&#x2F;ubuntu&#x2F;myspace&#x2F;qemu_build&#x2F;stable_ubuntu.img -append &#39;root&#x3D;&#x2F;dev&#x2F;sda5 console&#x3D;ttyS0 crashkernel&#x3D;256M systemd.unified_cgroup_hierarchy&#x3D;1&#39; -smp cores&#x3D;4,threads&#x3D;1,sockets&#x3D;2 -m 4G -object memory-backend-ram,id&#x3D;mem0,size&#x3D;2G -object memory-backend-ram,id&#x3D;mem1,size&#x3D;2G -numa node,memdev&#x3D;mem0,cpus&#x3D;0-3,nodeid&#x3D;0 -numa node,memdev&#x3D;mem1,cpus&#x3D;4-7,nodeid&#x3D;1 --enable-kvm -net nic -net user,hostfwd&#x3D;tcp::2222-:22 --nographic -fsdev local,id&#x3D;fs1,path&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share,security_model&#x3D;none -device virtio-9p-pci,fsdev&#x3D;fs1,mount_tag&#x3D;host_share</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-18T11:00:00.000Z" title="3/18/2021, 7:00:00 PM">2021-03-18</time>发表</span><span class="level-item"><time dateTime="2021-03-19T05:13:34.287Z" title="3/19/2021, 1:13:34 PM">2021-03-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></span><span class="level-item">3 分钟读完 (大约478个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/18/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/arm64%20kernel%20%E7%BC%96%E8%AF%91%20+%20vscode%E8%A7%A3%E6%9E%90/">arm64 kernel 编译 + vscode解析</a></h1><div class="content"><p>最近要换坑位了，下一家公司是做arm64手机芯片的，所以先熟悉一下arm64 kernel 开发环境的配置。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><p>安装 aarch64 架构的gcc编译器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@100ubuntu: ~&#x2F;workspace&#x2F;linux-stable# sudo apt install gcc-aarch64-linux-gnu</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">下列软件包是自动安装的并且现在不需要了：</span><br><span class="line">  gir1.2-keybinder-3.0 libfprint-2-tod1 libkeybinder-3.0-0 python3-configobj python3-psutil</span><br><span class="line">使用&#39;sudo apt autoremove&#39;来卸载它(它们)。</span><br><span class="line">将会同时安装下列软件：</span><br><span class="line">  cpp-aarch64-linux-gnu</span><br><span class="line">建议安装：</span><br><span class="line">  cpp-doc gdb-aarch64-linux-gnu gcc-doc</span><br><span class="line">下列【新】软件包将被安装：</span><br><span class="line">  cpp-aarch64-linux-gnu gcc-aarch64-linux-gnu</span><br><span class="line">升级了 0 个软件包，新安装了 2 个软件包，要卸载 0 个软件包，有 80 个软件包未被升级。</span><br><span class="line">需要下载 4,852 B 的归档。</span><br><span class="line">解压缩后会消耗 56.3 kB 的额外空间。</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备 defconfig</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@130ubuntu: ~&#x2F;workspace&#x2F;linux-stable# cp arch&#x2F;arm64&#x2F;configs&#x2F;defconfig .config</span><br><span class="line">Inspiron-5548@ubuntu: ~&#x2F;workspace&#x2F;linux-stable#</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ol>
<li>配置 config</li>
</ol>
<p><code>make ARCH=arm64 CROSS_COMPILE=/usr/bin/aarch64-linux-gnu- menuconfig</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@ubuntu: ~&#x2F;workspace&#x2F;linux-stable# make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;&#x2F;usr&#x2F;bin&#x2F;aarch64-linux-gnu- menuconfig</span><br><span class="line">.config:745:warning: symbol value &#39;m&#39; invalid for KVM</span><br><span class="line">configuration written to .config</span><br><span class="line"></span><br><span class="line">*** End of the configuration.</span><br><span class="line">*** Execute &#39;make&#39; to start the build or try &#39;make help&#39;.</span><br><span class="line"></span><br><span class="line">Inspiron-5548@ubuntu: ~&#x2F;workspace&#x2F;linux-stable#</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编译<br><code>make ARCH=arm64 CROSS_COMPILE=/usr/bin/aarch64-linux-gnu- all -j4</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@ubuntu: ~&#x2F;workspace&#x2F;linux-stable# make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;&#x2F;usr&#x2F;bin&#x2F;aarch64-linux-gnu- all -j4 O&#x3D;.&#x2F;out</span><br><span class="line"></span><br><span class="line">  SYNC    include&#x2F;config&#x2F;auto.conf.cmd</span><br><span class="line">  HOSTCC  scripts&#x2F;kconfig&#x2F;conf.o</span><br><span class="line">  HOSTLD  scripts&#x2F;kconfig&#x2F;conf</span><br><span class="line">  WRAP    arch&#x2F;arm64&#x2F;include&#x2F;generated&#x2F;uapi&#x2F;asm&#x2F;kvm_para.h</span><br><span class="line">  WRAP    arch&#x2F;arm64&#x2F;include&#x2F;generated&#x2F;uapi&#x2F;asm&#x2F;errno.h</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>生成compile_commands.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 4.19 - 5.8 之前可以用</span><br><span class="line">.&#x2F;scripts&#x2F;gen_compile_commands.py -d .&#x2F;out&#x2F;</span><br><span class="line"># 5.9 之后可以用</span><br><span class="line">.&#x2F;scripts&#x2F;clang-tools&#x2F;gen_compile_commands.py -d .&#x2F;out&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 .vscode/c_cpp_properties.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"># 4.19 - 5.8 之前可以用</span><br><span class="line">    .....</span><br><span class="line">    &quot;compileCommands&quot;: &quot;$&#123;WorkspaceFolder&#125;&#x2F;out&#x2F;compile_commands.json&quot;</span><br><span class="line">    .....</span><br><span class="line"># 5.9 之后可以用</span><br><span class="line">    .....</span><br><span class="line">    &quot;compileCommands&quot;: &quot;$&#123;WorkspaceFolder&#125;&#x2F;compile_commands.json&quot;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，基本上在浏览内核代码上不会有困难了</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-04T11:00:40.000Z" title="3/4/2021, 7:00:40 PM">2021-03-04</time>发表</span><span class="level-item"><time dateTime="2021-07-22T09:21:52.820Z" title="7/22/2021, 5:21:52 PM">2021-07-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">2 分钟读完 (大约262个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/04/interrupt/%E5%92%8C%E4%B8%AD%E6%96%AD%E6%8A%A2%E5%8D%A0%E7%9B%B8%E5%85%B3api/">和中断抢占相关api</a></h1><div class="content"><h2 id="开关关中断api"><a href="#开关关中断api" class="headerlink" title="开关关中断api"></a>开关关中断api</h2><p>api1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define local_irq_enable()	do &#123; raw_local_irq_enable(); &#125; while (0)</span><br><span class="line">#define local_irq_disable()	do &#123; raw_local_irq_disable(); &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>api2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define local_irq_save(flags)	do &#123; raw_local_irq_save(flags); &#125; while (0)</span><br><span class="line">#define local_irq_restore(flags) do &#123; raw_local_irq_restore(flags); &#125; while (0)</span><br></pre></td></tr></table></figure>



<h2 id="this-cpu-read-amp-amp-this-cpu-read"><a href="#this-cpu-read-amp-amp-this-cpu-read" class="headerlink" title="__this_cpu_read &amp;&amp; this_cpu_read"></a>__this_cpu_read &amp;&amp; this_cpu_read</h2><h3 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h3><p>可以在中断上下文中使用，无需考虑被中断或者进程强占</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Operations for contexts that are safe from preemption&#x2F;interrupts.  These</span><br><span class="line"> * operations verify that preemption is disabled.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define __this_cpu_read(pcp)						\</span><br><span class="line">(&#123;									\</span><br><span class="line">	__this_cpu_preempt_check(&quot;read&quot;);				\</span><br><span class="line">	raw_cpu_read(pcp);						\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#define __this_cpu_write(pcp, val)					\</span><br><span class="line">(&#123;									\</span><br><span class="line">	__this_cpu_preempt_check(&quot;write&quot;);				\</span><br><span class="line">	raw_cpu_write(pcp, val);					\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>可以在进程上下文中使用，实现了 强占、中断保护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Operations with implied preemption&#x2F;interrupt protection.  These</span><br><span class="line"> * operations can be used without worrying about preemption or interrupt.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define this_cpu_read(pcp)		__pcpu_size_call_return(this_cpu_read_, pcp)</span><br><span class="line">#define this_cpu_write(pcp, val)	__pcpu_size_call(this_cpu_write_, pcp, val)</span><br></pre></td></tr></table></figure>

<p>参考<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?id=8afecaa68df1e94a9d634f1f961533a925f239fc">patch1</a><br>参考<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?id=17c891ab349138e8d8a59ca2700f42ce8af96f4e">patch2</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-04T11:00:40.000Z" title="3/4/2021, 7:00:40 PM">2021-03-04</time>发表</span><span class="level-item"><time dateTime="2021-03-08T08:11:46.200Z" title="3/8/2021, 4:11:46 PM">2021-03-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">7 分钟读完 (大约1013个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/04/interrupt/hrtimer/">hrtimer</a></h1><div class="content"><p>hrtimer没有使用时间轮对定时器进行管理，而是选用了更加通用、性能稳定的红黑树。红黑树查找，插入和删除平均时间复杂度是O(logN)。虽然查找的时间复杂度达不到O(1)，但是避免了时间轮的迁移。</p>
<p>因此在平均性能上红黑树和时间轮会较为接近。 hrtimer红黑树是在红黑树的基础上做了简单的封装，hrtimer红黑树节点使用数据结构struct timerqueue_node，比rb_node多了一个expires字段，用于记录超时时刻。<br>hrtimer的数据结构与动态定时器的数据结构类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct timerqueue_node &#123;</span><br><span class="line">	struct rb_node node;</span><br><span class="line">	ktime_t expires;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; include&#x2F;linux&#x2F;hrtimer.h</span><br><span class="line">&#x2F;**</span><br><span class="line"> * struct hrtimer - the basic hrtimer structure</span><br><span class="line"> * @node:	timerqueue node, which also manages node.expires,</span><br><span class="line"> *		the absolute expiry time in the hrtimers internal</span><br><span class="line"> *		representation. The time is related to the clock on</span><br><span class="line"> *		which the timer is based. Is setup by adding</span><br><span class="line"> *		slack to the _softexpires value. For non range timers</span><br><span class="line"> *		identical to _softexpires.</span><br><span class="line"> * @_softexpires: the absolute earliest expiry time of the hrtimer.</span><br><span class="line"> *		The time which was given as expiry time when the timer</span><br><span class="line"> *		was armed.</span><br><span class="line"> * @function:	timer expiry callback function</span><br><span class="line"> * @base:	pointer to the timer base (per cpu and per clock)</span><br><span class="line"> * @state:	state information (See bit values above)</span><br><span class="line"> * @is_rel:	Set if the timer was armed relative</span><br><span class="line"> * @is_soft:	Set if hrtimer will be expired in soft interrupt context.</span><br><span class="line"> * @is_hard:	Set if hrtimer will be expired in hard interrupt context</span><br><span class="line"> *		even on RT.</span><br><span class="line"> *</span><br><span class="line"> * The hrtimer structure must be initialized by hrtimer_init()</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct hrtimer &#123;</span><br><span class="line">	struct timerqueue_node		node;</span><br><span class="line">	ktime_t				_softexpires;</span><br><span class="line">	enum hrtimer_restart		(*function)(struct hrtimer *);</span><br><span class="line">	struct hrtimer_clock_base	*base;</span><br><span class="line">	u8				state;</span><br><span class="line">	u8				is_rel;</span><br><span class="line">	u8				is_soft;</span><br><span class="line">	u8				is_hard;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * struct hrtimer_sleeper - simple sleeper structure</span><br><span class="line"> * @timer:	embedded timer structure</span><br><span class="line"> * @task:	task to wake up</span><br><span class="line"> *</span><br><span class="line"> * task is set to NULL, when the timer expires.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct hrtimer_sleeper &#123;</span><br><span class="line">	struct hrtimer timer;</span><br><span class="line">	struct task_struct *task;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>hrtimer和动态定时器一样拥有超时计数字段_softexpires和超时后的回调函数。 通过比较当前时间是否大于_softexpires来决定定时器超时，执行回调函数。 在红黑树的node中同样保存了一份expires，node.expires大于等于_softexpires。 这样做的目的是在高精度模式下，在_softexpires到node.expires期间设定定时器被触发的时间。</p>
<p>hrtimer管理器结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct hrtimer_cpu_base &#123;</span><br><span class="line">	raw_spinlock_t			lock;</span><br><span class="line">	unsigned int			cpu;</span><br><span class="line">	unsigned int			active_bases;</span><br><span class="line">	unsigned int			clock_was_set_seq;</span><br><span class="line">	unsigned int			hres_active		: 1,</span><br><span class="line">					in_hrtirq		: 1,</span><br><span class="line">					hang_detected		: 1,</span><br><span class="line">					softirq_activated       : 1;</span><br><span class="line">#ifdef CONFIG_HIGH_RES_TIMERS</span><br><span class="line">	unsigned int			nr_events;</span><br><span class="line">	unsigned short			nr_retries;</span><br><span class="line">	unsigned short			nr_hangs;</span><br><span class="line">	unsigned int			max_hang_time;</span><br><span class="line">#endif</span><br><span class="line">	ktime_t				expires_next;</span><br><span class="line">	struct hrtimer			*next_timer;</span><br><span class="line">	ktime_t				softirq_expires_next;</span><br><span class="line">	struct hrtimer			*softirq_next_timer;</span><br><span class="line">	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>

<p><code>running</code> 字段指向正在执行的 <code>hrtimer</code>。 next_timer字段指向第一个超时的hrtimer。 clock_base字段是当前CPU维护的定时器树。 目前每个CPU都维护了若干组定时器树，其中包括单条递增时间HRTIMER_BASE_MONOTONIC,上墙时间HRTIMER_BASE_REALTIME等。<br>。</p>
<p>hrtimer有两种精度模式，高精度模式和低精度模式。那么同样的数据设计，如何实现两种精度呢？ 这里的关键就是调用检查hrtimer函数的地方。我们来看看两种精度的调用栈。</p>
<p>低精度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_interrupt() -&gt; update_process_times() -&gt; run_local_timers() -&gt; hrtimer_run_queues() -&gt; __hrtimer_run_queues()</span><br></pre></td></tr></table></figure>

<p>高精度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hrtimer_interrupt() -&gt; __hrtimer_run_queues()</span><br></pre></td></tr></table></figure>

<p>当hrtimer处于低精度模式时，每次irq0上的时间中断，即每次tick事件，调用一次检查hrtimer函数。 tick的频率是1000hz，此时，hrtimer处于低精度模式。 在第一篇文章中，我们提到TSC、HPET都是可以提供纳秒级的时间设备。 当hrtimer处于高精度模式时，Linux把hrtimer_interrupt()绑定到高精度的时间设备，这时就可以提供纳秒级的定时器服务了。 但是频繁的调用检查hrtimer函数会非常消耗机器性能。 为了避免这个缺陷，hrtimer_interrupt()的调用采用了one-shot的模式。每一次调用都会设定下一次调用的时间。</p>
<p>参考<a target="_blank" rel="noopener" href="http://rangechow.com/2016/04/19/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%AE%9A%E6%97%B6%E5%99%A8Hrtimer.html">高精度定时器Hrtimer</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">上一页</a></div><div class="pagination-next"><a href="/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/11/">11</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Hui Su"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Hui Su</p><p class="is-size-6 is-block">liulangren bolg</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">101</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">130</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liulangrenaaa" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liulangrenaaa"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.google.com.hk/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Google</span></span><span class="level-right"><span class="level-item tag">www.google.com.hk</span></span></a></li><li><a class="level is-mobile" href="https://lkml.org/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">LKML</span></span><span class="level-right"><span class="level-item tag">lkml.org</span></span></a></li><li><a class="level is-mobile" href="https://mail.google.com/mail" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gmail</span></span><span class="level-right"><span class="level-item tag">mail.google.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhihu.com/explore" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/contest/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 剑指offer</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 周赛</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://tongji.baidu.com/web/32051076/overview/index?siteId=16230094" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">百度分析</span></span><span class="level-right"><span class="level-item tag">tongji.baidu.com</span></span></a></li><li><a class="level is-mobile" href="https://analytics.google.com/analytics/web/#/a187909645p259761261/admin/streams/table/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">google分析</span></span><span class="level-right"><span class="level-item tag">analytics.google.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BRK/"><span class="tag">BRK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KASAN/"><span class="tag">KASAN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OOM/"><span class="tag">OOM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QCOM/"><span class="tag">QCOM</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aarch64/"><span class="tag">aarch64</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpf/"><span class="tag">bpf</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpftrace/"><span class="tag">bpftrace</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup/"><span class="tag">cgroup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v1/"><span class="tag">cgroup v1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v2/"><span class="tag">cgroup v2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/crash/"><span class="tag">crash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dd/"><span class="tag">dd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/deadlock/"><span class="tag">deadlock</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debugfs/"><span class="tag">debugfs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/double-free/"><span class="tag">double free</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/drop-caches/"><span class="tag">drop_caches</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dumpe2fs/"><span class="tag">dumpe2fs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/event-trace/"><span class="tag">event trace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ext2/"><span class="tag">ext2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-attr/"><span class="tag">file attr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-hole/"><span class="tag">file hole</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/filesystem/"><span class="tag">filesystem</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fsck/"><span class="tag">fsck</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ftrace/"><span class="tag">ftrace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gdb/"><span class="tag">gdb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hardlockup/"><span class="tag">hardlockup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hrtimer/"><span class="tag">hrtimer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hugepage/"><span class="tag">hugepage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hungtask/"><span class="tag">hungtask</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/interrupt/"><span class="tag">interrupt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt/"><span class="tag">intrrrupt</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt-storm/"><span class="tag">intrrrupt storm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/irq/"><span class="tag">irq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kdump/"><span class="tag">kdump</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kernel-patch/"><span class="tag">kernel patch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kfence/"><span class="tag">kfence</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kmemleak/"><span class="tag">kmemleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kprobes/"><span class="tag">kprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kretprobes/"><span class="tag">kretprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ksoftirqd/"><span class="tag">ksoftirqd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kthread/"><span class="tag">kthread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvm/"><span class="tag">kvm</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvmtool/"><span class="tag">kvmtool</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/launch-json/"><span class="tag">launch.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-kernel/"><span class="tag">linux kernel</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-native-aio/"><span class="tag">linux native aio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lockdep/"><span class="tag">lockdep</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/makedumpfile/"><span class="tag">makedumpfile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memleak/"><span class="tag">memleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory/"><span class="tag">memory</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory-direct-reclaim/"><span class="tag">memory direct reclaim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mount/"><span class="tag">mount</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/namespace/"><span class="tag">namespace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oom/"><span class="tag">oom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oops/"><span class="tag">oops</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-cache/"><span class="tag">page_cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-owner/"><span class="tag">page_owner</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pagecache/"><span class="tag">pagecache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/panic/"><span class="tag">panic</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/per-cpu/"><span class="tag">per-cpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/perf/"><span class="tag">perf</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pid-namespace/"><span class="tag">pid namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preempt-count/"><span class="tag">preempt_count</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preemption/"><span class="tag">preemption</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pressure/"><span class="tag">pressure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psi/"><span class="tag">psi</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psoix-aio/"><span class="tag">psoix aio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/randomize-va-space/"><span class="tag">randomize_va_space</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rcu/"><span class="tag">rcu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/read-code/"><span class="tag">read code</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sched-latency/"><span class="tag">sched latency</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/schedule/"><span class="tag">schedule</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slab/"><span class="tag">slab</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub/"><span class="tag">slub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub-debug/"><span class="tag">slub_debug</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/softlockup/"><span class="tag">softlockup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stack-overflow/"><span class="tag">stack_overflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-key/"><span class="tag">static_key</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sync/"><span class="tag">sync</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systemTap/"><span class="tag">systemTap</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-json/"><span class="tag">task.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-struct/"><span class="tag">task_struct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tasklet/"><span class="tag">tasklet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thread-info/"><span class="tag">thread_info</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tracepoint/"><span class="tag">tracepoint</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ubuntu/"><span class="tag">ubuntu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/use-after-free/"><span class="tag">use after free</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uts-namespace/"><span class="tag">uts namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/valgrind/"><span class="tag">valgrind</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vdso/"><span class="tag">vdso</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmstat/"><span class="tag">vmstat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmtouch/"><span class="tag">vmtouch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vscode/"><span class="tag">vscode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/x86/"><span class="tag">x86</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xattr/"><span class="tag">xattr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zone/"><span class="tag">zone</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%B6%8A%E7%95%8C/"><span class="tag">内存泄漏越界</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"><span class="tag">内存泄露</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内核内存泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C/"><span class="tag">内核内存越界</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"><span class="tag">内核同步</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0/"><span class="tag">内核抢占</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%A0%88%E6%BA%A2%E5%87%BA/"><span class="tag">内核栈溢出</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E7%AE%A1%E7%AE%A1%E7%90%86/"><span class="tag">内管管理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"><span class="tag">函数调用</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E9%9A%8F%E6%9C%BA%E5%8C%96/"><span class="tag">地址空间布局随机化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/"><span class="tag">性能稳定性</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B3%84%E6%BC%8F/"><span class="tag">文件描述符泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><span class="tag">文件系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E9%A1%B9/"><span class="tag">杂项</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%88/"><span class="tag">栈</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/"><span class="tag">死锁检测</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="tag">生活感悟</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%A8%E6%88%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">用户内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A9%BA%E6%8C%87%E9%92%88/"><span class="tag">空指针</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F/"><span class="tag">虚拟地址空间泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F/"><span class="tag">资源泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%B8%AD%E6%96%AD/"><span class="tag">软中断</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"><span class="tag">进程调度</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/"><span class="tag">通用寄存器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81%E7%B2%92%E5%BA%A6/"><span class="tag">锁粒度</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E7%B3%BB%E7%BB%9F/"><span class="tag">问题系统</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/QCOM/"><span class="level-start"><span class="level-item">QCOM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/cgroup-v1/"><span class="level-start"><span class="level-item">cgroup v1</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/cgroup-v1/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/kernel-debug/"><span class="level-start"><span class="level-item">kernel debug</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-kernel/"><span class="level-start"><span class="level-item">linux kernel</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/"><span class="level-start"><span class="level-item">linux schedule</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/deadline-schedule/"><span class="level-start"><span class="level-item">deadline schedule</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/"><span class="level-start"><span class="level-item">frequency governer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/schedule-util/"><span class="level-start"><span class="level-item">schedule util</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/idle/"><span class="level-start"><span class="level-item">idle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/linux%E5%86%85%E6%A0%B8/"><span class="level-start"><span class="level-item">linux内核</span></span><span class="level-end"><span class="level-item tag">58</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/"><span class="level-start"><span class="level-item">namespace</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/namespace/pid-namespace/"><span class="level-start"><span class="level-item">pid namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/uts-namespace/"><span class="level-start"><span class="level-item">uts namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/qemu/"><span class="level-start"><span class="level-item">qemu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/server/"><span class="level-start"><span class="level-item">server</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/shell%E8%84%9A%E6%9C%AC/"><span class="level-start"><span class="level-item">shell脚本</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="level-start"><span class="level-item">生活感悟</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-23T11:00:00.000Z">2021-09-23</time></p><p class="title"><a href="/2021/09/23/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E9%9A%8F%E6%9C%BA%E5%8C%96/">地址空间布局随机化</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-14T11:00:00.000Z">2021-09-14</time></p><p class="title"><a href="/2021/09/14/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/static_key%E6%9C%BA%E5%88%B6/">static_key机制</a></p><p class="categories"><a href="/categories/kernel-debug/">kernel debug</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-14T11:00:00.000Z">2021-09-14</time></p><p class="title"><a href="/2021/09/14/%E7%BC%96%E8%AF%91%E5%99%A8/gnu%20built_in/">gnu built_in</a></p><p class="categories"><a href="/categories/kernel-debug/">kernel debug</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-14T11:00:00.000Z">2021-09-14</time></p><p class="title"><a href="/2021/09/14/interrupt/aarch64%20%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/">aarch64 中断处理</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-14T11:00:00.000Z">2021-09-14</time></p><p class="title"><a href="/2021/09/14/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/tracepoint%20%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/">tracepoint 原理与使用</a></p><p class="categories"><a href="/categories/kernel-debug/">kernel debug</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Su Hui</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>