<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>liulangren Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="liulangren blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="liulangren blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="liulangren Blog"><meta property="og:url" content="https://liulangrenaaa.github.io/"><meta property="og:site_name" content="liulangren Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liulangrenaaa.github.io/img/og_image.png"><meta property="article:author" content="Su Hui"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liulangrenaaa.github.io"},"headline":"liulangren Blog","image":["https://liulangrenaaa.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Su Hui"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cabdc5b9b70bb83fa919a6ebeb439f93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=PTKX6HMR55" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'PTKX6HMR55');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-11T11:00:00.000Z" title="6/11/2021, 7:00:00 PM">2021-06-11</time>发表</span><span class="level-item"><time dateTime="2021-06-11T09:22:33.005Z" title="6/11/2021, 5:22:33 PM">2021-06-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">4 分钟读完 (大约661个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/11/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/kfence%20%E4%BD%BF%E7%94%A8/">kfence 使用</a></h1><div class="content"><h2 id="Kfence-配置"><a href="#Kfence-配置" class="headerlink" title="Kfence 配置"></a>Kfence 配置</h2><p>看下<code>.config</code>的改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:~&#x2F;workspace&#x2F;linux $ diff .&#x2F;out&#x2F;.config &#x2F;tmp&#x2F;.config</span><br><span class="line">4713c4713,4717</span><br><span class="line">&lt; # CONFIG_KFENCE is not set</span><br><span class="line">---</span><br><span class="line">&gt; CONFIG_KFENCE&#x3D;y</span><br><span class="line">&gt; CONFIG_KFENCE_STATIC_KEYS&#x3D;y</span><br><span class="line">&gt; CONFIG_KFENCE_SAMPLE_INTERVAL&#x3D;100</span><br><span class="line">&gt; CONFIG_KFENCE_NUM_OBJECTS&#x3D;255</span><br><span class="line">&gt; CONFIG_KFENCE_STRESS_TEST_FAULTS&#x3D;0</span><br></pre></td></tr></table></figure>

<h2 id="Kfence-使用"><a href="#Kfence-使用" class="headerlink" title="Kfence 使用"></a>Kfence 使用</h2><p>写了一个test case，参考<a target="_blank" rel="noopener" href="https://github.com/liulangrenaaa/test_modules/blob/main/memory/kfence/kfence_debug.c">代码</a></p>
<h3 id="oob检测"><a href="#oob检测" class="headerlink" title="oob检测"></a>oob检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static int kfence_debug_oob(void *data)</span><br><span class="line">&#123;</span><br><span class="line">	char *p[100] &#x3D; &#123;NULL, &#125;;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	data &#x3D; data;</span><br><span class="line"></span><br><span class="line">	msleep(1000 * 5);</span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">		p[i] &#x3D; (char *)kmalloc(32, GFP_KERNEL);</span><br><span class="line">		p[i][32] &#x3D; &#39;a&#39;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while(!kthread_should_stop()) &#123;</span><br><span class="line">		msleep_interruptible(1000);</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是越界写了 1byte的 kmalloc数据。</p>
<p>insmod 之后立刻报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[  779.341929] kfence_debug: loading out-of-tree module taints kernel.</span><br><span class="line">[  784.638024] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[  784.641414] BUG: KFENCE: out-of-bounds write in kfence_debug_oob+0x26&#x2F;0x60 [kfence_debug]</span><br><span class="line"></span><br><span class="line">[  784.643513] Out-of-bounds write at 0x00000000514f5e22 (32B right of kfence-#176):</span><br><span class="line">[  784.644142]  kfence_debug_oob+0x26&#x2F;0x60 [kfence_debug]</span><br><span class="line">[  784.644144]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[  784.644146]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line"></span><br><span class="line">[  784.644283] kfence-#176 [0x000000001f204f03-0x00000000533650da, size&#x3D;32, cache&#x3D;kmalloc-32] allocated by task 3757:</span><br><span class="line">[  784.644288]  kfence_debug_oob+0x26&#x2F;0x60 [kfence_debug]</span><br><span class="line">[  784.644289]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[  784.644290]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line"></span><br><span class="line">[  784.644423] CPU: 2 PID: 3757 Comm: kfence_debug Kdump: loaded Tainted: G           O      5.13.0-rc5+ #4</span><br><span class="line">[  784.645207] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04&#x2F;01&#x2F;2014</span><br><span class="line">[  784.646006] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p><code>oob</code> 的 代码堆栈直接也打印出来了，十分清晰</p>
<h3 id="use-after-free-检测"><a href="#use-after-free-检测" class="headerlink" title="use after free 检测"></a>use after free 检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static int kfence_debug_use_after_free(void *data)</span><br><span class="line">&#123;</span><br><span class="line">	char *p[100] &#x3D; &#123;NULL, &#125;;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	data &#x3D; data;</span><br><span class="line"></span><br><span class="line">	msleep(1000 * 5);</span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">		p[i] &#x3D; (char *)kmalloc(32, GFP_KERNEL);</span><br><span class="line">		p[i][30] &#x3D; &#39;a&#39;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">		kfree(p[i]);</span><br><span class="line">		msleep_interruptible(100);</span><br><span class="line">		p[i][30] &#x3D; &#39;a&#39;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while(!kthread_should_stop()) &#123;</span><br><span class="line">		msleep_interruptible(1000);</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>user after free:</p>
<ul>
<li>kmalloc 32 bytes mem =&gt; p</li>
<li>assign val to p[30]</li>
<li>free p</li>
<li>assign val to p[30]</li>
</ul>
<p>insmod 之后立刻报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[ 1779.536493] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[ 1779.539850] BUG: KFENCE: use-after-free write in kfence_debug_use_after_free+0x7e&#x2F;0xd0 [kfence_debug]</span><br><span class="line"></span><br><span class="line">[ 1779.542427] Use-after-free write at 0x0000000013fef528 (in kfence-#218):</span><br><span class="line">[ 1779.542985]  kfence_debug_use_after_free+0x7e&#x2F;0xd0 [kfence_debug]</span><br><span class="line">[ 1779.542987]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[ 1779.542990]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line"></span><br><span class="line">[ 1779.543123] kfence-#218 [0x000000007dc7fe8d-0x0000000000dd0a85, size&#x3D;32, cache&#x3D;kmalloc-32] allocated by task 3868:</span><br><span class="line">[ 1779.543127]  kfence_debug_use_after_free+0x58&#x2F;0xd0 [kfence_debug]</span><br><span class="line">[ 1779.543129]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[ 1779.543130]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line">[ 1779.543131]</span><br><span class="line">               freed by task 3868:</span><br><span class="line">[ 1779.543133]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[ 1779.543134]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line"></span><br><span class="line">[ 1779.543266] CPU: 1 PID: 3868 Comm: kfence_debug Kdump: loaded Tainted: G    B      O      5.13.0-rc5+ #4</span><br><span class="line">[ 1779.544051] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04&#x2F;01&#x2F;2014</span><br><span class="line">[ 1779.544818] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>可以看出这是一个 <code>kmalloc-32</code> 的 mem，且是 <code>allocated</code> by task 3868，<code>freed</code> by task 3868。<br>也可以看到详细堆栈。</p>
<h3 id="double-free-检测"><a href="#double-free-检测" class="headerlink" title="double free 检测"></a>double free 检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int kfence_debug_double_free(void *data)</span><br><span class="line">&#123;</span><br><span class="line">	char *p[100] &#x3D; &#123;NULL, &#125;;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	data &#x3D; data;</span><br><span class="line"></span><br><span class="line">	msleep(1000 * 5);</span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">		p[i] &#x3D; (char *)kmalloc(32, GFP_KERNEL);</span><br><span class="line">		p[i][30] &#x3D; &#39;a&#39;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">		kfree(p[i]);</span><br><span class="line">		msleep_interruptible(100);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">		kfree(p[i]);</span><br><span class="line">		msleep_interruptible(100);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while(!kthread_should_stop()) &#123;</span><br><span class="line">		msleep_interruptible(1000);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>double free:</p>
<ul>
<li>kmalloc 32 bytes mem =&gt; p</li>
<li>free p</li>
<li>free p</li>
</ul>
<p>insmod 之后立刻报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[ 2489.576810] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[ 2489.577668] BUG: KFENCE: invalid free in kthread+0xf9&#x2F;0x130</span><br><span class="line"></span><br><span class="line">[ 2489.578464] Invalid free of 0x00000000ed008e01 (in kfence-#160):</span><br><span class="line">[ 2489.579128]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[ 2489.579131]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line"></span><br><span class="line">[ 2489.579305] kfence-#160 [0x00000000ed008e01-0x0000000086ffed42, size&#x3D;32, cache&#x3D;kmalloc-32] allocated by task 3914:</span><br><span class="line">[ 2489.579310]  kfence_debug_double_free+0x58&#x2F;0xd0 [kfence_debug]</span><br><span class="line">[ 2489.579312]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[ 2489.579313]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line">[ 2489.579315]</span><br><span class="line">               freed by task 3914:</span><br><span class="line">[ 2489.579318]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[ 2489.579319]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line"></span><br><span class="line">[ 2489.579492] CPU: 3 PID: 3914 Comm: kfence_debug Kdump: loaded Tainted: G    B      O      5.13.0-rc5+ #4</span><br><span class="line">[ 2489.580590] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04&#x2F;01&#x2F;2014</span><br><span class="line">[ 2489.581698] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>可以看出这是一个 <code>kmalloc-32</code> 的 mem，且是 <code>allocated</code> by task 3914, <code>freed</code> by task 3914。<br>也可以看到详细堆栈。</p>
<h2 id="Kfence-原理"><a href="#Kfence-原理" class="headerlink" title="Kfence 原理"></a>Kfence 原理</h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-01T11:00:00.000Z" title="6/1/2021, 7:00:00 PM">2021-06-01</time>发表</span><span class="level-item"><time dateTime="2021-06-03T01:57:01.752Z" title="6/3/2021, 9:57:01 AM">2021-06-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">3 分钟读完 (大约515个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/01/schedule/benchmark/">benchmark</a></h1><div class="content"><p>参考<a target="_blank" rel="noopener" href="https://lwn.net/Articles/725238/">LWN文章</a></p>
<h2 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h2><h2 id="hackbench"><a href="#hackbench" class="headerlink" title="hackbench"></a>hackbench</h2><p><code>hackbench</code> 包含在 <code>rt-tests</code> 中，主要是 xxx 的测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;test $ sudo apt-cache search hackbench</span><br><span class="line">rt-tests - Test programs for rt kernels</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;test $</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;test $ hackbench</span><br><span class="line">Running in process mode with 10 groups using 40 file descriptors each (&#x3D;&#x3D; 400 tasks)</span><br><span class="line">Each sender will pass 100 messages of 100 bytes</span><br><span class="line">Time: 0.093</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;test $</span><br></pre></td></tr></table></figure>

<h2 id="schbench"><a href="#schbench" class="headerlink" title="schbench"></a>schbench</h2><p><code>schbench</code> 需要自己手动编译安装，地址在 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/mason/schbench.git/tree/">这里</a><br>下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;mason&#x2F;schbench.git</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ ls</span><br><span class="line">Makefile  schbench.c  schedstat.py</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ make</span><br><span class="line">gcc -o schbench.o -c -Wall -O2 -g -W -D_GNU_SOURCE -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS&#x3D;64 schbench.c</span><br><span class="line">gcc -Wall -O2 -g -W -D_GNU_SOURCE -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS&#x3D;64 -o schbench schbench.o -lpthread</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ ls</span><br><span class="line">Makefile  schbench  schbench.c  schbench.o  schedstat.py</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $</span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ ls</span><br><span class="line">Makefile  schbench  schbench.c  schbench.o  schedstat.py</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ sudo mv schbench &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ ls</span><br><span class="line">Makefile  schbench.c  schbench.o  schedstat.py</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ schbench</span><br><span class="line"></span><br><span class="line">warmup done, zeroing stats</span><br><span class="line">Latency percentiles (usec) runtime 10 (s) (1649 total samples)</span><br><span class="line">	50.0th: 80 (833 samples)</span><br><span class="line">	75.0th: 8040 (404 samples)</span><br><span class="line">	90.0th: 14352 (248 samples)</span><br><span class="line">	95.0th: 16016 (95 samples)</span><br><span class="line">	*99.0th: 24992 (54 samples)</span><br><span class="line">	99.5th: 28960 (7 samples)</span><br><span class="line">	99.9th: 31968 (8 samples)</span><br><span class="line">	min&#x3D;4, max&#x3D;31999</span><br><span class="line">Latency percentiles (usec) runtime 20 (s) (4929 total samples)</span><br><span class="line">	50.0th: 77 (2473 samples)</span><br><span class="line">	75.0th: 8056 (1234 samples)</span><br><span class="line">	90.0th: 14160 (735 samples)</span><br><span class="line">	95.0th: 15824 (247 samples)</span><br><span class="line">	*99.0th: 24736 (193 samples)</span><br><span class="line">	99.5th: 28000 (24 samples)</span><br><span class="line">	99.9th: 32032 (22 samples)</span><br><span class="line">	min&#x3D;3, max&#x3D;39652</span><br><span class="line">Latency percentiles (usec) runtime 30 (s) (8274 total samples)</span><br><span class="line">	50.0th: 75 (4163 samples)</span><br><span class="line">	75.0th: 8008 (2059 samples)</span><br><span class="line">	90.0th: 14096 (1226 samples)</span><br><span class="line">	95.0th: 15760 (415 samples)</span><br><span class="line">	*99.0th: 24096 (329 samples)</span><br><span class="line">	99.5th: 26976 (41 samples)</span><br><span class="line">	99.9th: 31968 (34 samples)</span><br><span class="line">	min&#x3D;3, max&#x3D;39652</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $</span><br></pre></td></tr></table></figure>


<h2 id="adrestia"><a href="#adrestia" class="headerlink" title="adrestia"></a>adrestia</h2><p><code>adrestia</code> 需要自己手动编译安装，地址在 <a target="_blank" rel="noopener" href="https://github.com/mfleming/adrestia.git">这里</a></p>
<p>下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;mfleming&#x2F;adrestia.git</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench&#x2F;adrestia $ make</span><br><span class="line">cc -Wall -lpthread -I &#x2F;tmp&#x2F;schbench&#x2F;adrestia&#x2F;include -g   -c -o wake.o wake.c</span><br><span class="line">cc -Wall -lpthread -I &#x2F;tmp&#x2F;schbench&#x2F;adrestia&#x2F;include -g   -c -o stats.o stats.c</span><br><span class="line">cc -Wall -lpthread -I &#x2F;tmp&#x2F;schbench&#x2F;adrestia&#x2F;include -g adrestia.c wake.o stats.o -o adrestia -lpthread</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench&#x2F;adrestia $ .&#x2F;adrestia</span><br><span class="line">wakeup cost (single): 11us</span><br><span class="line">wakeup cost (periodic, 10us): 12us</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench&#x2F;adrestia $</span><br></pre></td></tr></table></figure>

<h2 id="rt-app"><a href="#rt-app" class="headerlink" title="rt-app"></a>rt-app</h2><p><code>rt-app</code> 需要自己手动编译安装，地址在 <a target="_blank" rel="noopener" href="https://github.com/scheduler-tools/rt-app">这里</a></p>
<p>下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;scheduler-tools&#x2F;rt-app</span><br></pre></td></tr></table></figure>

<p>编译<br>由于对 <code>json-c</code> <code>numactl</code> 有一定依赖，所以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>##</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-25T11:00:00.000Z" title="5/25/2021, 7:00:00 PM">2021-05-25</time>发表</span><span class="level-item"><time dateTime="2021-05-26T01:59:02.564Z" title="5/26/2021, 9:59:02 AM">2021-05-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">7 分钟读完 (大约1047个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/25/schedule/sched_features/">sched_features</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p><code>sched features</code> 是 linux scheduler 的一些 feature实现开关，可以在系统运行中动态开关，相关 feature 在 <code>kernel/sched/features.h</code> 有定义。</p>
<h2 id="feature-拆解"><a href="#feature-拆解" class="headerlink" title="feature 拆解"></a>feature 拆解</h2><p>每个 feature 对调度行为都有一定影响或者优化，但是需要根据实际情况来选择是否开启 这个 feature.</p>
<h3 id="GENTLE-FAIR-SLEEPERS"><a href="#GENTLE-FAIR-SLEEPERS" class="headerlink" title="GENTLE_FAIR_SLEEPERS"></a>GENTLE_FAIR_SLEEPERS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Only give sleepers 50% of their service deficit. This allows</span><br><span class="line"> * them to run sooner, but does not allow tons of sleepers to</span><br><span class="line"> * rip the spread apart.</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(GENTLE_FAIR_SLEEPERS, true)</span><br></pre></td></tr></table></figure>
<p><code>GENTLE_FAIR_SLEEPERS</code> 主要是 减少对 sleep task的 vruntime 补偿。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">		 * Halve their sleep time&#39;s effect, to allow</span><br><span class="line">		 * for a gentler effect of sleepers:</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (sched_feat(GENTLE_FAIR_SLEEPERS))</span><br><span class="line">			thresh &gt;&gt;&#x3D; 1;</span><br><span class="line"></span><br><span class="line">		vruntime -&#x3D; thresh;</span><br></pre></td></tr></table></figure>
<p>实际 使用时，仅仅是将 补偿时间减少一半。</p>
<h3 id="START-DEBIT"><a href="#START-DEBIT" class="headerlink" title="START_DEBIT"></a>START_DEBIT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Place new tasks ahead so that they do not starve already running</span><br><span class="line"> * tasks</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(START_DEBIT, true)</span><br></pre></td></tr></table></figure>
<p><code>START_DEBIT</code> 主要是 对 initial task 的一种惩罚，对 vruntime 增加，可以让运行时间减少 和 不会立刻运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial)</span><br><span class="line">&#123;</span><br><span class="line">	u64 vruntime &#x3D; cfs_rq-&gt;min_vruntime;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The &#39;current&#39; period is already promised to the current tasks,</span><br><span class="line">	 * however the extra weight of the new task will slow them down a</span><br><span class="line">	 * little, place the new task so that it fits in the slot that</span><br><span class="line">	 * stays open at the end.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (initial &amp;&amp; sched_feat(START_DEBIT))</span><br><span class="line">		vruntime +&#x3D; sched_vslice(cfs_rq, se);</span><br></pre></td></tr></table></figure>

<h3 id="NEXT-BUDDY"><a href="#NEXT-BUDDY" class="headerlink" title="NEXT_BUDDY"></a>NEXT_BUDDY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Prefer to schedule the task we woke last (assuming it failed</span><br><span class="line"> * wakeup-preemption), since its likely going to consume data we</span><br><span class="line"> * touched, increases cache locality.</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(NEXT_BUDDY, false)</span><br></pre></td></tr></table></figure>
<p><code>NEXT_BUDDY</code> 主要是 希望可以 尽快调度到 抢占 <code>curr</code>的 task.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	if (sched_feat(NEXT_BUDDY) &amp;&amp; scale &amp;&amp; !(wake_flags &amp; WF_FORK)) &#123;</span><br><span class="line">		set_next_buddy(pse);</span><br><span class="line">		next_buddy_marked &#x3D; 1;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LAST-BUDDY"><a href="#LAST-BUDDY" class="headerlink" title="LAST_BUDDY"></a>LAST_BUDDY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Prefer to schedule the task that ran last (when we did</span><br><span class="line"> * wake-preempt) as that likely will touch the same data, increases</span><br><span class="line"> * cache locality.</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(LAST_BUDDY, true)</span><br></pre></td></tr></table></figure>
<p><code>LAST_BUDDY</code> 主要是 希望可以尽快调度到上次被 <code>wakeup task</code> <code>preempt</code> 的task。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	if (sched_feat(LAST_BUDDY) &amp;&amp; scale &amp;&amp; entity_is_task(se))</span><br><span class="line">		set_last_buddy(se);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CACHE-HOT-BUDDY"><a href="#CACHE-HOT-BUDDY" class="headerlink" title="CACHE_HOT_BUDDY"></a>CACHE_HOT_BUDDY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Consider buddies to be cache hot, decreases the likeliness of a</span><br><span class="line"> * cache buddy being migrated away, increases cache locality.</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(CACHE_HOT_BUDDY, true)</span><br></pre></td></tr></table></figure>
<p>认为 [last|next]buddies 是 cache hot的，所以不能让他们 migrate away，增加 cache 命中率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Is this task likely cache-hot:</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int task_hot(struct task_struct *p, struct lb_env *env)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Buddy candidates are cache hot:</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (sched_feat(CACHE_HOT_BUDDY) &amp;&amp; env-&gt;dst_rq-&gt;nr_running &amp;&amp;</span><br><span class="line">			(&amp;p-&gt;se &#x3D;&#x3D; cfs_rq_of(&amp;p-&gt;se)-&gt;next ||</span><br><span class="line">			 &amp;p-&gt;se &#x3D;&#x3D; cfs_rq_of(&amp;p-&gt;se)-&gt;last))</span><br><span class="line">		return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WAKEUP-PREEMPTION"><a href="#WAKEUP-PREEMPTION" class="headerlink" title="WAKEUP_PREEMPTION"></a>WAKEUP_PREEMPTION</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Allow wakeup-time preemption of the current task:</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(WAKEUP_PREEMPTION, true)</span><br></pre></td></tr></table></figure>
<p>是否可以唤醒强占， 后续补充</p>
<h3 id="HRTICK-HRTICK-DL-DOUBLE-TICK"><a href="#HRTICK-HRTICK-DL-DOUBLE-TICK" class="headerlink" title="HRTICK HRTICK_DL DOUBLE_TICK"></a>HRTICK HRTICK_DL DOUBLE_TICK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SCHED_FEAT(HRTICK, false)</span><br><span class="line">SCHED_FEAT(HRTICK_DL, false)</span><br><span class="line">SCHED_FEAT(DOUBLE_TICK, false)</span><br></pre></td></tr></table></figure>
<p><code>HRTICK HRTICK_DL DOUBLE_TICK</code> 这三个 feature 主要是利用 <code>rq-&gt;hrtick_timer</code> 优化调度行为的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void __sched notrace __schedule(bool preempt)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	if (sched_feat(HRTICK) || sched_feat(HRTICK_DL))</span><br><span class="line">		hrtick_clear(rq);</span><br></pre></td></tr></table></figure>

<p>主要是 <code>dl task</code> 会使用 这个 hrtimer 在<code>dl-&gt;runtime</code>到期的时候 发生一个 tick，使得任务运行时间更加精准</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void start_hrtick_dl(struct rq *rq, struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	hrtick_start(rq, p-&gt;dl.runtime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void set_next_task_dl(struct rq *rq, struct task_struct *p, bool first)</span><br><span class="line">&#123;</span><br><span class="line">	p-&gt;se.exec_start &#x3D; rq_clock_task(rq);</span><br><span class="line"></span><br><span class="line">	if (hrtick_enabled_dl(rq))</span><br><span class="line">		start_hrtick_dl(rq, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>cfs task</code> 会使用 这个 hrtimer 在<code>delta</code> 期望运行时间 到期的时候 发生一个 tick_fair，使得运行时间更加精准。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void hrtick_start_fair(struct rq *rq, struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_entity *se &#x3D; &amp;p-&gt;se;</span><br><span class="line">	struct cfs_rq *cfs_rq &#x3D; cfs_rq_of(se);</span><br><span class="line"></span><br><span class="line">	SCHED_WARN_ON(task_rq(p) !&#x3D; rq);</span><br><span class="line"></span><br><span class="line">	if (rq-&gt;cfs.h_nr_running &gt; 1) &#123;</span><br><span class="line">		u64 slice &#x3D; sched_slice(cfs_rq, se);</span><br><span class="line">		u64 ran &#x3D; se-&gt;sum_exec_runtime - se-&gt;prev_sum_exec_runtime;</span><br><span class="line">		s64 delta &#x3D; slice - ran;</span><br><span class="line"></span><br><span class="line">		if (delta &lt; 0) &#123;</span><br><span class="line">			if (task_current(rq, p))</span><br><span class="line">				resched_curr(rq);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		hrtick_start(rq, delta);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct task_struct *</span><br><span class="line">pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	if (hrtick_enabled_fair(rq))</span><br><span class="line">		hrtick_start_fair(rq, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="NONTASK-CAPACITY"><a href="#NONTASK-CAPACITY" class="headerlink" title="NONTASK_CAPACITY"></a>NONTASK_CAPACITY</h3><h3 id="TTWU-QUEUE"><a href="#TTWU-QUEUE" class="headerlink" title="TTWU_QUEUE"></a>TTWU_QUEUE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Queue remote wakeups on the target CPU and process them</span><br><span class="line"> * using the scheduler IPI. Reduces rq-&gt;lock contention&#x2F;bounces.</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(TTWU_QUEUE, true)</span><br></pre></td></tr></table></figure>
<p><code>TTWU_QUEUE</code> 主要是 使用 <code>IPI</code> 去唤醒 <code>remote queue</code> 上的task，而不是操作<code>rq-&gt;lock</code>，然后操作队列上的 entity，这会减少 <code>rq-&gt;lock</code>的争用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static bool ttwu_queue_wakelist(struct task_struct *p, int cpu, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	if (sched_feat(TTWU_QUEUE) &amp;&amp; ttwu_queue_cond(cpu, wake_flags)) &#123;</span><br><span class="line">		if (WARN_ON_ONCE(cpu &#x3D;&#x3D; smp_processor_id()))</span><br><span class="line">			return false;</span><br><span class="line"></span><br><span class="line">		sched_clock_cpu(cpu); &#x2F;* Sync clocks across CPUs *&#x2F;</span><br><span class="line">		__ttwu_queue_wakelist(p, cpu, wake_flags);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="SIS-PROP"><a href="#SIS-PROP" class="headerlink" title="SIS_PROP"></a>SIS_PROP</h3><h3 id="WARN-DOUBLE-CLOCK"><a href="#WARN-DOUBLE-CLOCK" class="headerlink" title="WARN_DOUBLE_CLOCK"></a>WARN_DOUBLE_CLOCK</h3><h3 id="RT-PUSH-IPI"><a href="#RT-PUSH-IPI" class="headerlink" title="RT_PUSH_IPI"></a>RT_PUSH_IPI</h3><h3 id="RT-RUNTIME-SHARE"><a href="#RT-RUNTIME-SHARE" class="headerlink" title="RT_RUNTIME_SHARE"></a>RT_RUNTIME_SHARE</h3><h3 id="LB-MIN"><a href="#LB-MIN" class="headerlink" title="LB_MIN"></a>LB_MIN</h3><h3 id="ATTACH-AGE-LOAD"><a href="#ATTACH-AGE-LOAD" class="headerlink" title="ATTACH_AGE_LOAD"></a>ATTACH_AGE_LOAD</h3><h3 id="WA-IDLE"><a href="#WA-IDLE" class="headerlink" title="WA_IDLE"></a>WA_IDLE</h3><h3 id="WA-WEIGHT"><a href="#WA-WEIGHT" class="headerlink" title="WA_WEIGHT"></a>WA_WEIGHT</h3><h3 id="WA-BIAS"><a href="#WA-BIAS" class="headerlink" title="WA_BIAS"></a>WA_BIAS</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-19T11:00:00.000Z" title="5/19/2021, 7:00:00 PM">2021-05-19</time>发表</span><span class="level-item"><time dateTime="2021-09-16T07:53:18.392Z" title="9/16/2021, 3:53:18 PM">2021-09-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">5 分钟读完 (大约718个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/19/schedule/stop_task/">stop_task</a></h1><div class="content"><h2 id="stop-task"><a href="#stop-task" class="headerlink" title="stop_task"></a>stop_task</h2><p><code>stop_task</code> 实现在 <code>kernel/sched/stop_task.c</code> 中，在所有调度类中<br><code>stop_sched_class</code>的优先级是最高的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define SCHED_DATA				\</span><br><span class="line">	STRUCT_ALIGN();				\</span><br><span class="line">	__begin_sched_classes &#x3D; .;		\</span><br><span class="line">	*(__idle_sched_class)			\</span><br><span class="line">	*(__fair_sched_class)			\</span><br><span class="line">	*(__rt_sched_class)			\</span><br><span class="line">	*(__dl_sched_class)			\</span><br><span class="line">	*(__stop_sched_class)			\</span><br><span class="line">	__end_sched_classes &#x3D; .;</span><br></pre></td></tr></table></figure>


<p>其实在 linux中一个 per cpu的 rq中，每个rq只会有一个 stop task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct rq &#123;</span><br><span class="line">	&#x2F;* runqueue lock: *&#x2F;</span><br><span class="line">	raw_spinlock_t		lock;</span><br><span class="line"></span><br><span class="line">	struct task_struct __rcu	*curr;</span><br><span class="line">	struct task_struct	*idle;</span><br><span class="line">	struct task_struct	*stop;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且 <code>stop task</code> never migrates，不会迁移，只会固定在某个 cpu上跑，所以 select_task_rq_stop 实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">select_task_rq_stop(struct task_struct *p, int cpu, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	return task_cpu(p); &#x2F;* stop tasks as never migrate *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且 <code>stop task</code> can not be preempted，不会被抢占，check_preempt_curr_stop 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">check_preempt_curr_stop(struct rq *rq, struct task_struct *p, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* we&#39;re never preempted *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>stop_task</code>， rq上只有一个stop_sched_class的 task，所以 pick_next_task_stop 实现很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct task_struct *pick_next_task_stop(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	if (!sched_stop_runnable(rq))</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	set_next_task_stop(rq, rq-&gt;stop, true);</span><br><span class="line">	return rq-&gt;stop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="外部模块使用"><a href="#外部模块使用" class="headerlink" title="外部模块使用"></a>外部模块使用</h2><p>在 soft lockup 检测模块中，就利用了stop_class 这个调度类。<br><code>watchdog.c</code> 中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* watchdog kicker functions *&#x2F;</span><br><span class="line">static enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long touch_ts, period_ts, now;</span><br><span class="line">	struct pt_regs *regs &#x3D; get_irq_regs();</span><br><span class="line">	int duration;</span><br><span class="line">	int softlockup_all_cpu_backtrace &#x3D; sysctl_softlockup_all_cpu_backtrace;</span><br><span class="line"></span><br><span class="line">	if (!watchdog_enabled)</span><br><span class="line">		return HRTIMER_NORESTART;</span><br><span class="line"></span><br><span class="line">	&#x2F;* kick the hardlockup detector *&#x2F;</span><br><span class="line">	watchdog_interrupt_count();</span><br><span class="line"></span><br><span class="line">	&#x2F;* kick the softlockup detector *&#x2F;</span><br><span class="line">	if (completion_done(this_cpu_ptr(&amp;softlockup_completion))) &#123;</span><br><span class="line">		reinit_completion(this_cpu_ptr(&amp;softlockup_completion));</span><br><span class="line">		stop_one_cpu_nowait(smp_processor_id(),</span><br><span class="line">				softlockup_fn, NULL,</span><br><span class="line">				this_cpu_ptr(&amp;softlockup_stop_work));</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>stop_one_cpu_nowait</code> 并不直接调用 <code>softlockup_fn</code>函数，只是将他 queue work 而已</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* queue @work to @stopper.  if offline, @work is completed immediately *&#x2F;</span><br><span class="line">static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)</span><br><span class="line">&#123;</span><br><span class="line">	struct cpu_stopper *stopper &#x3D; &amp;per_cpu(cpu_stopper, cpu);</span><br><span class="line">	DEFINE_WAKE_Q(wakeq);</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	bool enabled;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	raw_spin_lock_irqsave(&amp;stopper-&gt;lock, flags);</span><br><span class="line">	enabled &#x3D; stopper-&gt;enabled;</span><br><span class="line">	if (enabled)</span><br><span class="line">		__cpu_stop_queue_work(stopper, work, &amp;wakeq);</span><br><span class="line">	else if (work-&gt;done)</span><br><span class="line">		cpu_stop_signal_done(work-&gt;done);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;stopper-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	wake_up_q(&amp;wakeq);</span><br><span class="line">	preempt_enable();</span><br><span class="line"></span><br><span class="line">	return enabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,</span><br><span class="line">			struct cpu_stop_work *work_buf)</span><br><span class="line">&#123;</span><br><span class="line">	*work_buf &#x3D; (struct cpu_stop_work)&#123; .fn &#x3D; fn, .arg &#x3D; arg, .caller &#x3D; _RET_IP_, &#125;;</span><br><span class="line">	return cpu_stop_queue_work(cpu, work_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 stopper 是 <code>&amp;per_cpu(cpu_stopper, cpu)</code>, 定义是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct cpu_stopper &#123;</span><br><span class="line">	struct task_struct	*thread;</span><br><span class="line"></span><br><span class="line">	raw_spinlock_t		lock;</span><br><span class="line">	bool			enabled;	&#x2F;* is this stopper enabled? *&#x2F;</span><br><span class="line">	struct list_head	works;		&#x2F;* list of pending works *&#x2F;</span><br><span class="line"></span><br><span class="line">	struct cpu_stop_work	stop_work;	&#x2F;* for stop_cpus *&#x2F;</span><br><span class="line">	unsigned long		caller;</span><br><span class="line">	cpu_stop_fn_t		fn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);</span><br></pre></td></tr></table></figure>

<p>在 每个 CPU 上的 stop_class 进程是 <code>migration/x</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct smp_hotplug_thread cpu_stop_threads &#x3D; &#123;</span><br><span class="line">	.store			&#x3D; &amp;cpu_stopper.thread,</span><br><span class="line">	.thread_should_run	&#x3D; cpu_stop_should_run,</span><br><span class="line">	.thread_fn		&#x3D; cpu_stopper_thread,</span><br><span class="line">	.thread_comm		&#x3D; &quot;migration&#x2F;%u&quot;,</span><br><span class="line">	.create			&#x3D; cpu_stop_create,</span><br><span class="line">	.park			&#x3D; cpu_stop_park,</span><br><span class="line">	.selfparking		&#x3D; true,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>shell 可以看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:~&#x2F;workspace&#x2F;linux $ ps -aux | grep migration</span><br><span class="line">root          14  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;0]</span><br><span class="line">root          19  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;1]</span><br><span class="line">root          25  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;2]</span><br><span class="line">root          31  0.0  0.0      0     0 ?        S    9月03   0:04 [migration&#x2F;3]</span><br><span class="line">root          37  0.0  0.0      0     0 ?        S    9月03   0:04 [migration&#x2F;4]</span><br><span class="line">root          43  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;5]</span><br><span class="line">root          49  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;6]</span><br><span class="line">root          55  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;7]</span><br><span class="line">root          61  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;8]</span><br><span class="line">root          67  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;9]</span><br><span class="line">root          73  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;10]</span><br><span class="line">root          79  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;11]</span><br><span class="line">ubuntu     35458  0.0  0.0  12224   836 pts&#x2F;0    S+   15:26   0:00 grep --color&#x3D;auto migration</span><br><span class="line">ubuntu@zeku_server:~&#x2F;workspace&#x2F;linux $</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-01T11:00:00.000Z" title="5/1/2021, 7:00:00 PM">2021-05-01</time>发表</span><span class="level-item"><time dateTime="2021-05-18T09:28:05.668Z" title="5/18/2021, 5:28:05 PM">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">6 分钟读完 (大约877个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/01/schedule/uclamp/">uclamp</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p>uclamp(utilzation clamp) 是说 任务 cpu使用率夹钳，主要是 userspace 对 scheduler的一些hint。</p>
<ol>
<li>比如某个 task 对用户体验有直接的影响，此 task至少需要 20%cpu，那么计算 cpu使用率，select_rq的时候，必须考虑此task的 minimum “requested”，然后选择 <code>rq</code> 和 <code>freq</code>。</li>
<li>比如某个低优先级的 task 对用户体验没有影响，此 task最多需要 60%cpu（60% &lt; 1024），那么计算 cpu使用率，select_rq的时候，必须考虑此task的 maximum “requested”，然后选择 <code>rq</code> 和<code>freq</code>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sched&#x2F;cpufreq, sched&#x2F;uclamp: Add clamps for FAIR and RT tasks</span><br><span class="line"></span><br><span class="line">    Each time a frequency update is required via schedutil, a frequency is</span><br><span class="line">    selected to (possibly) satisfy the utilization reported by each</span><br><span class="line">    scheduling class and irqs. However, when utilization clamping is in use,</span><br><span class="line">    the frequency selection should consider userspace utilization clamping</span><br><span class="line">    hints.  This will allow, for example, to:</span><br><span class="line"></span><br><span class="line">     - boost tasks which are directly affecting the user experience</span><br><span class="line">       by running them at least at a minimum &quot;requested&quot; frequency</span><br><span class="line"></span><br><span class="line">     - cap low priority tasks not directly affecting the user experience</span><br><span class="line">       by running them only up to a maximum &quot;allowed&quot; frequency</span><br></pre></td></tr></table></figure>

<p>在uapi 的头文件<code>include/uapi/linux/sched/types.h</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> @sched_util_min	represents the minimum utilization</span><br><span class="line"> @sched_util_max	represents the maximum utilization</span><br><span class="line"></span><br><span class="line">Utilization is a value in the range [0..SCHED_CAPACITY_SCALE]. It</span><br><span class="line">represents the percentage of CPU time used by a task when running at the</span><br><span class="line">maximum frequency on the highest capacity CPU of the system. For example, a</span><br><span class="line">20% utilization task is a task running for 2ms every 10ms at maximum</span><br><span class="line">frequency.</span><br><span class="line"></span><br><span class="line">A task with a min utilization value bigger than 0 is more likely scheduled</span><br><span class="line">on a CPU with a capacity big enough to fit the specified value.</span><br><span class="line">A task with a max utilization value smaller than 1024 is more likely</span><br><span class="line">scheduled on a CPU with no more capacity than the specified value.</span><br></pre></td></tr></table></figure>

<p>uclamp 的min..max 指的都是最大 freq下 的cpu使用率， 20%使用率 说的是在最大频率下，task 每10ms需要运行2ms。</p>
<h2 id="data-structure"><a href="#data-structure" class="headerlink" title="data structure"></a>data structure</h2><p>uclamp 分为<code>per sched_entity</code> 和 <code>per rq</code> 两种，分别使用 <code>struct uclamp_se</code>  <code>struct uclamp_rq</code>来描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct uclamp_se &#123;</span><br><span class="line">	unsigned int value		: bits_per(SCHED_CAPACITY_SCALE);</span><br><span class="line">	unsigned int bucket_id		: bits_per(UCLAMP_BUCKETS);</span><br><span class="line">	unsigned int active		: 1;</span><br><span class="line">	unsigned int user_defined	: 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct uclamp_rq &#123;</span><br><span class="line">	unsigned int value;</span><br><span class="line">	struct uclamp_bucket bucket[UCLAMP_BUCKETS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct rq &#123;</span><br><span class="line">	&#x2F;* runqueue lock: *&#x2F;</span><br><span class="line">	raw_spinlock_t		lock;</span><br><span class="line">#ifdef CONFIG_UCLAMP_TASK</span><br><span class="line">	&#x2F;* Utilization clamp values based on CPU&#39;s RUNNABLE tasks *&#x2F;</span><br><span class="line">	struct uclamp_rq	uclamp[UCLAMP_CNT] ____cacheline_aligned;</span><br><span class="line">	unsigned int		uclamp_flags;</span><br><span class="line">#define UCLAMP_FLAG_IDLE 0x01</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>per sched entity</code> 又分为两种，一种是 <code>per task</code>，一种是 <code>per task group</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">        ......</span><br><span class="line">#ifdef CONFIG_UCLAMP_TASK</span><br><span class="line">	&#x2F;* Clamp values requested for a scheduling entity *&#x2F;</span><br><span class="line">	struct uclamp_se		uclamp_req[UCLAMP_CNT];</span><br><span class="line">	&#x2F;* Effective clamp values used for a scheduling entity *&#x2F;</span><br><span class="line">	struct uclamp_se		uclamp[UCLAMP_CNT];</span><br><span class="line">#endif</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct task_group &#123;</span><br><span class="line">	struct cgroup_subsys_state css;</span><br><span class="line">#ifdef CONFIG_UCLAMP_TASK_GROUP</span><br><span class="line">	&#x2F;* The two decimal precision [%] value requested from user-space *&#x2F;</span><br><span class="line">	unsigned int		uclamp_pct[UCLAMP_CNT];</span><br><span class="line">	&#x2F;* Clamp values requested for a task group *&#x2F;</span><br><span class="line">	struct uclamp_se	uclamp_req[UCLAMP_CNT];</span><br><span class="line">	&#x2F;* Effective clamp values used for a task group *&#x2F;</span><br><span class="line">	struct uclamp_se	uclamp[UCLAMP_CNT];</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void __init init_uclamp(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct uclamp_se uc_max &#x3D; &#123;&#125;;</span><br><span class="line">	enum uclamp_id clamp_id;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;uclamp_mutex);</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(cpu)</span><br><span class="line">		init_uclamp_rq(cpu_rq(cpu));</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		uclamp_se_set(&amp;init_task.uclamp_req[clamp_id],</span><br><span class="line">			      uclamp_none(clamp_id), false);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* System defaults allow max clamp values for both indexes *&#x2F;</span><br><span class="line">	uclamp_se_set(&amp;uc_max, uclamp_none(UCLAMP_MAX), false);</span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		uclamp_default[clamp_id] &#x3D; uc_max;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="kernel-api"><a href="#kernel-api" class="headerlink" title="kernel api"></a>kernel api</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static inline void uclamp_rq_inc(struct rq *rq, struct task_struct *p) &#123; &#125;</span><br><span class="line">static inline void uclamp_rq_dec(struct rq *rq, struct task_struct *p) &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	if (!(flags &amp; ENQUEUE_NOCLOCK))</span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	if (!(flags &amp; ENQUEUE_RESTORE)) &#123;</span><br><span class="line">		sched_info_queued(rq, p);</span><br><span class="line">		psi_enqueue(p, flags &amp; ENQUEUE_WAKEUP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uclamp_rq_inc(rq, p);</span><br><span class="line">	p-&gt;sched_class-&gt;enqueue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	if (!(flags &amp; DEQUEUE_NOCLOCK))</span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	if (!(flags &amp; DEQUEUE_SAVE)) &#123;</span><br><span class="line">		sched_info_dequeued(rq, p);</span><br><span class="line">		psi_dequeue(p, flags &amp; DEQUEUE_SLEEP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uclamp_rq_dec(rq, p);</span><br><span class="line">	p-&gt;sched_class-&gt;dequeue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>enqueue_task</code> <code>dequeue_task</code> 中会 根据 此task是否 开启 uclamp来更改 <code>rq</code>的统计的<code>uclamp_rq</code> 数据。</p>
<h3 id="user-api"><a href="#user-api" class="headerlink" title="user api"></a>user api</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-30T11:00:00.000Z" title="4/30/2021, 7:00:00 PM">2021-04-30</time>发表</span><span class="level-item"><time dateTime="2021-05-18T09:28:05.668Z" title="5/18/2021, 5:28:05 PM">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/QCOM/">QCOM</a></span><span class="level-item">几秒读完 (大约0个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/30/schedule/Qcom%20kernel/core_ctl/">core_ctl</a></h1><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-30T11:00:00.000Z" title="4/30/2021, 7:00:00 PM">2021-04-30</time>发表</span><span class="level-item"><time dateTime="2021-05-18T09:28:05.668Z" title="5/18/2021, 5:28:05 PM">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">1 分钟读完 (大约204个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/30/schedule/fair/">fair</a></h1><div class="content"><h2 id="reweight-entity"><a href="#reweight-entity" class="headerlink" title="reweight_entity"></a>reweight_entity</h2><p>sched_init()-&gt;|<br>              |-&gt;set_load_weight(p, false)<br>sched_fork()-&gt;|</p>
<p>set_user_nice()———&gt;|<br>                         |-&gt;set_load_weight(p, true)-&gt;reweight_task()-&gt;reweight_entity()<br>__setscheduler_params()-&gt;|</p>
<p>只会在 cfs task改变 task nice值 或者 改变调度参数的时候会 调用到 <code>reweight_entity()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se,</span><br><span class="line">			    unsigned long weight, unsigned long runnable)</span><br><span class="line">&#123;</span><br><span class="line">	if (se-&gt;on_rq) &#123;</span><br><span class="line">		&#x2F;* commit outstanding execution time *&#x2F;</span><br><span class="line">		if (cfs_rq-&gt;curr &#x3D;&#x3D; se)</span><br><span class="line">			update_curr(cfs_rq);</span><br><span class="line">		account_entity_dequeue(cfs_rq, se);</span><br><span class="line">		dequeue_runnable_load_avg(cfs_rq, se);</span><br><span class="line">	&#125;</span><br><span class="line">	dequeue_load_avg(cfs_rq, se);</span><br><span class="line"></span><br><span class="line">	se-&gt;runnable_weight &#x3D; runnable;</span><br><span class="line">	update_load_set(&amp;se-&gt;load, weight);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	do &#123;</span><br><span class="line">		u32 divider &#x3D; LOAD_AVG_MAX - 1024 + se-&gt;avg.period_contrib;</span><br><span class="line"></span><br><span class="line">		se-&gt;avg.load_avg &#x3D; div_u64(se_weight(se) * se-&gt;avg.load_sum, divider);</span><br><span class="line">		se-&gt;avg.runnable_load_avg &#x3D;</span><br><span class="line">			div_u64(se_runnable(se) * se-&gt;avg.runnable_load_sum, divider);</span><br><span class="line">	&#125; while (0);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	enqueue_load_avg(cfs_rq, se);</span><br><span class="line">	if (se-&gt;on_rq) &#123;</span><br><span class="line">		account_entity_enqueue(cfs_rq, se);</span><br><span class="line">		enqueue_runnable_load_avg(cfs_rq, se);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于重新计算 load_weight，所以需要 xx_dequeue() and xx_enqueue()。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-30T11:00:00.000Z" title="4/30/2021, 7:00:00 PM">2021-04-30</time>发表</span><span class="level-item"><time dateTime="2021-05-19T08:41:21.380Z" title="5/19/2021, 4:41:21 PM">2021-05-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">11 分钟读完 (大约1612个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/30/schedule/util_est/">util_est</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p><code>struct util_est - Estimation utilization of FAIR tasks</code><br>这是一个评估 <code>fair</code> task的 utilization的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">It&#39;s worth noting that the estimated utilization is tracked only for</span><br><span class="line"> objects of interests, specifically:</span><br><span class="line"></span><br><span class="line">  - Tasks: to better support tasks placement decisions</span><br><span class="line">  - root cfs_rqs: to better support both tasks placement decisions as</span><br><span class="line">                  well as frequencies selection</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Moreover, the PELT utilization of a task can be updated every [ms], thus</span><br><span class="line"> making it a continuously changing value for certain longer running</span><br><span class="line"> tasks. This means that the instantaneous PELT utilization of a RUNNING</span><br><span class="line"> task is not really meaningful to properly support scheduler decisions.</span><br><span class="line"></span><br><span class="line"> For all these reasons, a more stable signal can do a better job of</span><br><span class="line"> representing the expected&#x2F;estimated utilization of a task&#x2F;cfs_rq.</span><br><span class="line"> Such a signal can be easily created on top of PELT by still using it as</span><br><span class="line"> an estimator which produces values to be aggregated on meaningful</span><br><span class="line"> events.</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct util_est - Estimation utilization of FAIR tasks</span><br><span class="line"> * @enqueued: instantaneous estimated utilization of a task&#x2F;cpu -- task的 瞬时的 util</span><br><span class="line"> * @ewma:     the Exponential Weighted Moving Average (EWMA)</span><br><span class="line"> *            utilization of a task                             -- task的 EWMA（移动加权平均） 的 util</span><br><span class="line"> *</span><br><span class="line"> * Support data structure to track an Exponential Weighted Moving Average</span><br><span class="line"> * (EWMA) of a FAIR task&#39;s utilization. New samples are added to the moving</span><br><span class="line"> * average each time a task completes an activation. Sample&#39;s weight is chosen</span><br><span class="line"> * so that the EWMA will be relatively insensitive to transient changes to the</span><br><span class="line"> * task&#39;s workload.</span><br><span class="line"> *</span><br><span class="line"> * The enqueued attribute has a slightly different meaning for tasks and cpus:</span><br><span class="line"> * - task:   the task&#39;s util_avg at last task dequeue time</span><br><span class="line"> * - cfs_rq: the sum of util_est.enqueued for each RUNNABLE task on that CPU</span><br><span class="line"> * Thus, the util_est.enqueued of a task represents the contribution on the</span><br><span class="line"> * estimated utilization of the CPU where that task is currently enqueued.</span><br><span class="line"> *</span><br><span class="line"> * Only for tasks we track a moving average of the past instantaneous</span><br><span class="line"> * estimated utilization. This allows to absorb sporadic drops in utilization</span><br><span class="line"> * of an otherwise almost periodic task.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct util_est &#123;</span><br><span class="line">	unsigned int			enqueued;</span><br><span class="line">	unsigned int			ewma;</span><br><span class="line">#define UTIL_EST_WEIGHT_SHIFT		2</span><br><span class="line">&#125; __attribute__((__aligned__(sizeof(u64))));</span><br></pre></td></tr></table></figure>

<p>当一个 <code>task</code> 完成一次激活（？？enqueue?）的时候，最新的采样会被 加权之后添加到 EWMA中；因为会对 <code>sample</code> 做一个加权，所以 <code>EWMA</code> 对 <code>task workload</code>的瞬时量不会态敏感。</p>
<p><code>.enqueue</code> 这个含义对 <code>task</code> 与 <code>cpu</code> 有些不一样:<br><code>task</code>: 在上次 dequeue时刻，task的 util_avg<br><code>cfs_rq</code>: 在 这个cpu上 所有 <code>RUNNABLE task</code>的 <code>util_est.enqueued</code>之和</p>
<p>我们只对 <code>tasks</code> 跟踪 过去瞬时的 util，不会对 <code>cpu</code>跟踪这个。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><code>util_est</code> 对外部只提供了四个API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline void util_est_enqueue(struct cfs_rq *cfs_rq,</span><br><span class="line">				    struct task_struct *p);</span><br><span class="line"></span><br><span class="line">static inline void util_est_dequeue(struct cfs_rq *cfs_rq,</span><br><span class="line">				    struct task_struct *p);</span><br><span class="line"></span><br><span class="line">static inline void util_est_update(struct cfs_rq *cfs_rq,</span><br><span class="line">				   struct task_struct *p,</span><br><span class="line">				   bool task_sleep);</span><br><span class="line"></span><br><span class="line">static inline void cfs_se_util_change(struct sched_avg *avg);</span><br></pre></td></tr></table></figure>


<p><code>util_est_enqueue</code> <code>util_est_dequeue</code> 都是只在 <code>enqueue_task_fair</code> <code>dequeue_task_fair</code> 中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct cfs_rq *cfs_rq;</span><br><span class="line">	struct sched_entity *se &#x3D; &amp;p-&gt;se;</span><br><span class="line">	int idle_h_nr_running &#x3D; task_has_idle_policy(p);</span><br><span class="line">	int task_new &#x3D; !(flags &amp; ENQUEUE_WAKEUP);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The code below (indirectly) updates schedutil which looks at</span><br><span class="line">	 * the cfs_rq utilization to select a frequency.</span><br><span class="line">	 * Let&#39;s add the task&#39;s estimated utilization to the cfs_rq&#39;s</span><br><span class="line">	 * estimated utilization, before we update schedutil.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	util_est_enqueue(&amp;rq-&gt;cfs, p);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct cfs_rq *cfs_rq;</span><br><span class="line">	struct sched_entity *se &#x3D; &amp;p-&gt;se;</span><br><span class="line">	int task_sleep &#x3D; flags &amp; DEQUEUE_SLEEP;</span><br><span class="line">	int idle_h_nr_running &#x3D; task_has_idle_policy(p);</span><br><span class="line">	bool was_sched_idle &#x3D; sched_idle_rq(rq);</span><br><span class="line"></span><br><span class="line">	util_est_dequeue(&amp;rq-&gt;cfs, p);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">dequeue_throttle:</span><br><span class="line">	util_est_update(&amp;rq-&gt;cfs, p, task_sleep);</span><br><span class="line">	hrtick_update(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>enqueue_task_fair</code> 中调用 <code>util_est_enqueue</code> 时，此时 task-&gt;entity 还未 入队<br><code>dequeue_task_fair</code> 中调用 <code>util_est_dequeue</code> 时，此时 task-&gt;entity 还未 出队</p>
<p>在 <code>enqueue_task_fair</code> <code>dequeue_task_fair</code> 中，会对 <code>entity</code> 进行 <code>enqueue_entity</code> 和 <code>dequeue_entity</code>，两个过程都需要 <code>update_load_avg</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static inline void cfs_se_util_change(struct sched_avg *avg)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int enqueued;</span><br><span class="line"></span><br><span class="line">	if (!sched_feat(UTIL_EST))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Avoid store if the flag has been already set *&#x2F;</span><br><span class="line">	enqueued &#x3D; avg-&gt;util_est.enqueued;</span><br><span class="line">	if (!(enqueued &amp; UTIL_AVG_UNCHANGED))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Reset flag to report util_avg has been updated *&#x2F;</span><br><span class="line">	enqueued &amp;&#x3D; ~UTIL_AVG_UNCHANGED;</span><br><span class="line">	WRITE_ONCE(avg-&gt;util_est.enqueued, enqueued);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __update_load_avg_se(u64 now, struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	if (___update_load_sum(now, &amp;se-&gt;avg, !!se-&gt;on_rq, se_runnable(se),</span><br><span class="line">				cfs_rq-&gt;curr &#x3D;&#x3D; se)) &#123;</span><br><span class="line"></span><br><span class="line">		___update_load_avg(&amp;se-&gt;avg, se_weight(se));</span><br><span class="line">		cfs_se_util_change(&amp;se-&gt;avg);</span><br><span class="line">		trace_pelt_se_tp(se);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void update_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	u64 now &#x3D; cfs_rq_clock_pelt(cfs_rq);</span><br><span class="line">	int decayed;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Track task load average for carrying it to new CPU after migrated, and</span><br><span class="line">	 * track group sched_entity load average for task_h_load calc in migration</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (se-&gt;avg.last_update_time &amp;&amp; !(flags &amp; SKIP_AGE_LOAD))</span><br><span class="line">		__update_load_avg_se(now, cfs_rq, se);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以一个 task <code>enqueue</code> <code>dequeue</code> 两个过程 和 util_est相关的流程是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">enqueue_task_fair</span><br><span class="line">    |</span><br><span class="line">    util_est_enqueue</span><br><span class="line">    |</span><br><span class="line">    enqueue_entity</span><br><span class="line">        |</span><br><span class="line">        update_load_avg</span><br><span class="line">            |</span><br><span class="line">            __update_load_avg_se</span><br><span class="line">                |</span><br><span class="line">                cfs_se_util_change</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">dequeue_task_fair</span><br><span class="line">    |</span><br><span class="line">    util_est_dequeue</span><br><span class="line">    |</span><br><span class="line">    enqueue_entity</span><br><span class="line">        |</span><br><span class="line">        update_load_avg</span><br><span class="line">            |</span><br><span class="line">            __update_load_avg_se</span><br><span class="line">                |</span><br><span class="line">                cfs_se_util_change</span><br><span class="line">    |</span><br><span class="line">    util_est_update</span><br></pre></td></tr></table></figure>

<p>都是先要经过 <code>cfs_se_util_change</code> 然后再经过 <code>dequeue_task_fair</code> 中的<code>util_est_update</code> ，在 <code>util_est_update</code> 中更新 EWMA的值。</p>
<p>内部实现使用了 <code>UTIL_AVG_UNCHANGED</code> 这个变量来同步这两个过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * When a task is dequeued, its estimated utilization should not be update if</span><br><span class="line"> * its util_avg has not been updated at least once.</span><br><span class="line"> * This flag is used to synchronize util_avg updates with util_est updates.</span><br><span class="line"> * We map this information into the LSB bit of the utilization saved at</span><br><span class="line"> * dequeue time (i.e. util_est.dequeued).</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="EWMA是啥？"><a href="#EWMA是啥？" class="headerlink" title="EWMA是啥？"></a>EWMA是啥？</h2><p>参考<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/EWMA">EWMA</a></p>
<p>EWMA - Exponential Weighted Moving Average 指数加权移动平均。</p>
<p>ewma(t) = w *  task_util(p) + (1-w) * ewma(t-1)<br>        = w *  task_util(p) +         ewma(t-1)  - w * ewma(t-1)<br>        = w * (task_util(p) -         ewma(t-1)) +     ewma(t-1)<br>        = w * (      last_ewma_diff            ) +     ewma(t-1)<br>        = w * (last_ewma_diff  +  ewma(t-1) / w)</p>
<p>其中 w = 0.25 = 1 / 4</p>
<p>ewma(t) = (last_ewma_diff + ewma(t-1) &lt;&lt; 2)   &gt;&gt; 2<br>        = (last_ewma_diff + ewma(t-1) &lt;&lt; UTIL_EST_WEIGHT_SHIFT)   &gt;&gt; UTIL_EST_WEIGHT_SHIFT</p>
<p>当前 采样周期只占用到了 (1 / 4) 权重</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>为了更快追踪负载的变化，util_est 作者引入了另一个 feature <code>UTIL_EST_FASTUP</code>, 用来加速 util上升</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sched&#x2F;fair&#x2F;util_est: Implement faster ramp-up EWMA on utilization increases</span><br><span class="line"></span><br><span class="line">The estimated utilization for a task:</span><br><span class="line"></span><br><span class="line">   util_est &#x3D; max(util_avg, est.enqueue, est.ewma)</span><br><span class="line"></span><br><span class="line">is defined based on:</span><br><span class="line"></span><br><span class="line"> - util_avg: the PELT defined utilization</span><br><span class="line"> - est.enqueued: the util_avg at the end of the last activation</span><br><span class="line"> - est.ewma:     a exponential moving average on the est.enqueued samples</span><br><span class="line"></span><br><span class="line">According to this definition, when a task suddenly changes its bandwidth</span><br><span class="line">requirements from small to big, the EWMA will need to collect multiple</span><br><span class="line">samples before converging up to track the new big utilization.</span><br><span class="line"></span><br><span class="line">This slow convergence towards bigger utilization values is not</span><br><span class="line">aligned to the default scheduler behavior, which is to optimize for</span><br><span class="line">performance. Moreover, the est.ewma component fails to compensate for</span><br><span class="line">temporarely utilization drops which spans just few est.enqueued samples.</span><br><span class="line"></span><br><span class="line">To let util_est do a better job in the scenario depicted above, change</span><br><span class="line">its definition by making util_est directly follow upward motion and</span><br><span class="line">only decay the est.ewma on downward.</span><br></pre></td></tr></table></figure>

<p>主要改动是这里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--- a&#x2F;kernel&#x2F;sched&#x2F;fair.c</span><br><span class="line">+++ b&#x2F;kernel&#x2F;sched&#x2F;fair.c</span><br><span class="line">@@ -3768,11 +3768,22 @@ util_est_dequeue(struct cfs_rq *cfs_rq, struct task_struct *p, bool task_sleep)</span><br><span class="line">        if (ue.enqueued &amp; UTIL_AVG_UNCHANGED)</span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">+       &#x2F;*</span><br><span class="line">+        * Reset EWMA on utilization increases, the moving average is used only</span><br><span class="line">+        * to smooth utilization decreases.</span><br><span class="line">+        *&#x2F;</span><br><span class="line">+       ue.enqueued &#x3D; (task_util(p) | UTIL_AVG_UNCHANGED);</span><br><span class="line">+       if (sched_feat(UTIL_EST_FASTUP)) &#123;</span><br><span class="line">+               if (ue.ewma &lt; ue.enqueued) &#123;</span><br><span class="line">+                       ue.ewma &#x3D; ue.enqueued;</span><br><span class="line">+                       goto done;</span><br><span class="line">+               &#125;</span><br><span class="line">+       &#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>
<p>开启 <code>UTIL_EST_FASTUP</code> 之后， 如果检测到 ewma(t-1) &lt; .enqueued 直接用当前的 负载util 替换掉<br>历史负载 ewma.</p>
<p>这样task 在 <code>small_to_big</code> 的时候可以更快的跟踪负载，从而更好地 调频与 升核。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-28T11:00:00.000Z" title="4/28/2021, 7:00:00 PM">2021-04-28</time>发表</span><span class="level-item"><time dateTime="2021-05-18T09:28:05.664Z" title="5/18/2021, 5:28:05 PM">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/QCOM/">QCOM</a></span><span class="level-item">8 分钟读完 (大约1243个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/28/schedule/Qcom%20kernel/boost/">boost</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p>Scheduler boost 是一个机制：将task放到capacity比自己需求大很多 cpu上的机制，<br>开启 <code>boost</code> 的entity也需要为他结束负责。</p>
<p>boost机制 主要是给上层 or framework层写文件节点的，改变<code>boost机制</code>，是<code>整个系统生效的</code>，并不是针对于某单个thread。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scheduler boost is a mechanism to temporarily place tasks on CPUs</span><br><span class="line">with higher capacity than those where a task would have normally</span><br><span class="line">ended up with their load characteristics. Any entity enabling</span><br><span class="line">boost is responsible for disabling it as well.</span><br></pre></td></tr></table></figure>


<h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h2><h2 id="boost-基本概念"><a href="#boost-基本概念" class="headerlink" title="boost 基本概念"></a>boost 基本概念</h2><p>boost type 分为以下几种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define NO_BOOST 0</span><br><span class="line">#define FULL_THROTTLE_BOOST 1</span><br><span class="line">#define CONSERVATIVE_BOOST 2</span><br><span class="line">#define RESTRAINED_BOOST 3</span><br><span class="line">#define FULL_THROTTLE_BOOST_DISABLE -1</span><br><span class="line">#define CONSERVATIVE_BOOST_DISABLE -2</span><br><span class="line">#define RESTRAINED_BOOST_DISABLE -3</span><br><span class="line">#define MAX_NUM_BOOST_TYPE (RESTRAINED_BOOST+1)</span><br></pre></td></tr></table></figure>

<p>可以通过<code>sched_boost()</code>获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern unsigned int sched_boost_type;</span><br><span class="line">static inline int sched_boost(void)</span><br><span class="line">&#123;</span><br><span class="line">	return sched_boost_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>boost policy 分为以下几种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum sched_boost_policy &#123;</span><br><span class="line">	SCHED_BOOST_NONE,</span><br><span class="line">	SCHED_BOOST_ON_BIG,</span><br><span class="line">	SCHED_BOOST_ON_ALL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>sched_boost_policy()</code>获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern enum sched_boost_policy boost_policy;</span><br><span class="line">static inline enum sched_boost_policy sched_boost_policy(void)</span><br><span class="line">&#123;</span><br><span class="line">	return boost_policy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>每个boost type有相关的<code>enter</code>，<code>exit</code>方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct sched_boost_data &#123;</span><br><span class="line">	int refcount;</span><br><span class="line">	void (*enter)(void);</span><br><span class="line">	void (*exit)(void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct sched_boost_data sched_boosts[] &#x3D; &#123;</span><br><span class="line">	[NO_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_no_boost_nop,</span><br><span class="line">		.exit &#x3D; sched_no_boost_nop,</span><br><span class="line">	&#125;,</span><br><span class="line">	[FULL_THROTTLE_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_full_throttle_boost_enter,</span><br><span class="line">		.exit &#x3D; sched_full_throttle_boost_exit,</span><br><span class="line">	&#125;,</span><br><span class="line">	[CONSERVATIVE_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_conservative_boost_enter,</span><br><span class="line">		.exit &#x3D; sched_conservative_boost_exit,</span><br><span class="line">	&#125;,</span><br><span class="line">	[RESTRAINED_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_restrained_boost_enter,</span><br><span class="line">		.exit &#x3D; sched_restrained_boost_exit,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p>写<code>/proc</code> 文件节点 最后调用到<code>sched_boost_handler()</code>–&gt;<code>_sched_set_boost()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void _sched_set_boost(int type)</span><br><span class="line">&#123;</span><br><span class="line">	if (type &#x3D;&#x3D; 0)</span><br><span class="line">		sched_boost_disable_all();</span><br><span class="line">	else if (type &gt; 0)</span><br><span class="line">		sched_boost_enable(type);</span><br><span class="line">	else</span><br><span class="line">		sched_boost_disable(-type);</span><br><span class="line"></span><br><span class="line">	sched_boost_type &#x3D; sched_effective_boost();</span><br><span class="line">	sysctl_sched_boost &#x3D; sched_boost_type;</span><br><span class="line">	set_boost_policy(sysctl_sched_boost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sched_boost_handler(struct ctl_table *table, int write,</span><br><span class="line">		void __user *buffer, size_t *lenp,</span><br><span class="line">		loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	mutex_lock(&amp;boost_mutex);</span><br><span class="line">	_sched_set_boost(*data);</span><br><span class="line">done:</span><br><span class="line">	mutex_unlock(&amp;boost_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_sched_set_boost(int type) type可能是以下一种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define NO_BOOST 0</span><br><span class="line">#define FULL_THROTTLE_BOOST 1</span><br><span class="line">#define CONSERVATIVE_BOOST 2</span><br><span class="line">#define RESTRAINED_BOOST 3</span><br><span class="line">#define FULL_THROTTLE_BOOST_DISABLE -1</span><br><span class="line">#define CONSERVATIVE_BOOST_DISABLE -2</span><br><span class="line">#define RESTRAINED_BOOST_DISABLE -3</span><br></pre></td></tr></table></figure>
<p>type == NO_BOOST ==&gt; disable all<br>type &gt; NO_BOOST ==&gt; enable one boost<br>type &lt; NO_BOOST ==&gt; disable one boost</p>
<p>sched_boosts 使用了refcount机制，已经开启的boost_type的 <code>refcount &gt; 0</code>，如果使能多个<code>boost type</code>，则哪个值大，生效哪个，可以重复开启某一个type的 boost，由于有refcount，所以也需要多次disable。</p>
<p><code>sched_boost_disable_all()</code>，直接调用所有<code>refcount &gt; 0</code>的 boost type的 <code>.exit()</code>方法，然后 <code>refcount = 0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void sched_boost_disable_all(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; SCHED_BOOST_START; i &lt; SCHED_BOOST_END; i++) &#123;</span><br><span class="line">		if (sched_boosts[i].refcount &gt; 0) &#123;</span><br><span class="line">			sched_boosts[i].exit();</span><br><span class="line">			sched_boosts[i].refcount &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sched_boost_enable()</code> 首先<code>refcount++</code>，最终调用到 <code>.enter()</code>方法然后实现enable。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void sched_boost_enable(int type)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_boost_data *sb &#x3D; &amp;sched_boosts[type];</span><br><span class="line">	int next_boost, prev_boost &#x3D; sched_boost_type;</span><br><span class="line"></span><br><span class="line">	sb-&gt;refcount++;</span><br><span class="line"></span><br><span class="line">	if (sb-&gt;refcount !&#x3D; 1) &#x2F;&#x2F; 如果已经处于这种模式了，那就直接返回</span><br><span class="line">		return;</span><br><span class="line">	next_boost &#x3D; sched_effective_boost();</span><br><span class="line">	if (next_boost &#x3D;&#x3D; prev_boost)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	sched_boosts[prev_boost].exit();</span><br><span class="line">	sched_boosts[next_boost].enter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boost-type实现"><a href="#boost-type实现" class="headerlink" title="boost type实现"></a>boost type实现</h2><p>针对于每种<code>boost type</code>，Q实现了其 <code>struct sched_boost_data</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sched_boost_data &#123;</span><br><span class="line">	int refcount;</span><br><span class="line">	void (*enter)(void);</span><br><span class="line">	void (*exit)(void);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="NO-BOOST"><a href="#NO-BOOST" class="headerlink" title="NO_BOOST"></a>NO_BOOST</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct sched_boost_data sched_boosts[] &#x3D; &#123;</span><br><span class="line">	[NO_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_no_boost_nop,</span><br><span class="line">		.exit &#x3D; sched_no_boost_nop,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sched_no_boost_nop() 就是 nop空函数</p>
<h3 id="FULL-THROTTLE-BOOST"><a href="#FULL-THROTTLE-BOOST" class="headerlink" title="FULL_THROTTLE_BOOST"></a>FULL_THROTTLE_BOOST</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct sched_boost_data sched_boosts[] &#x3D; &#123;</span><br><span class="line">	[FULL_THROTTLE_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_full_throttle_boost_enter,</span><br><span class="line">		.exit &#x3D; sched_full_throttle_boost_exit,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>.enter()</code> <code>.exit()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void sched_full_throttle_boost_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">	core_ctl_set_boost(true); &#x2F;&#x2F; 与 core_ctl强相关，后面再看</span><br><span class="line">	walt_enable_frequency_aggregation(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void sched_full_throttle_boost_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	core_ctl_set_boost(false);</span><br><span class="line">	walt_enable_frequency_aggregation(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CONSERVATIVE-BOOST"><a href="#CONSERVATIVE-BOOST" class="headerlink" title="CONSERVATIVE_BOOST"></a>CONSERVATIVE_BOOST</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct sched_boost_data sched_boosts[] &#x3D; &#123;</span><br><span class="line">	[CONSERVATIVE_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_conservative_boost_enter,</span><br><span class="line">		.exit &#x3D; sched_conservative_boost_exit,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>.enter()</code> <code>.exit()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void sched_conservative_boost_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">	update_cgroup_boost_settings();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void sched_conservative_boost_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	restore_cgroup_boost_settings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RESTRAINED-BOOST"><a href="#RESTRAINED-BOOST" class="headerlink" title="RESTRAINED_BOOST"></a>RESTRAINED_BOOST</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct sched_boost_data sched_boosts[] &#x3D; &#123;</span><br><span class="line">	[RESTRAINED_BOOST] &#x3D; &#123;</span><br><span class="line">		.refcount &#x3D; 0,</span><br><span class="line">		.enter &#x3D; sched_restrained_boost_enter,</span><br><span class="line">		.exit &#x3D; sched_restrained_boost_exit,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>.enter()</code> <code>.exit()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void sched_restrained_boost_enter(void)</span><br><span class="line">&#123;</span><br><span class="line">	walt_enable_frequency_aggregation(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void sched_restrained_boost_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	walt_enable_frequency_aggregation(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Full throttle： FULL_THROTTLE_BOOST</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、通过core control，将所有cpu都进行unisolation</span><br><span class="line">2、通过freq聚合，将load计算放大。从而触发提升freq，或者迁移等</span><br><span class="line">3、通过设置boost policy&#x3D; SCHED_BOOST_ON_BIG，迁移挑选target cpu时，只会选择大核</span><br><span class="line">最终效果应该尽可能把任务都放在大核运行（除了cpuset中有限制）</span><br></pre></td></tr></table></figure>

<p>Conservative： CONSERVATIVE_BOOST</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、通过更新group boost配置，仅让top-app和foreground组进行task placement boost</span><br><span class="line">2、提高min_task_util的门限，让进行up migrate的条件更苛刻。只有load较大（&gt;1ms）的task，会进行up migrate。</span><br><span class="line">2、同上，更改min_task_util门限后，会提醒系统task与cpu是misfit，需要进行迁移。</span><br><span class="line">3、通过设置boost policy&#x3D; SCHED_BOOST_ON_BIG，迁移挑选target cpu时，只会选择大核</span><br><span class="line">最终效果：top-app和foreground的一些task会迁移到大核运行</span><br></pre></td></tr></table></figure>

<p>Restrained： RESTRAINED_BOOST</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、通过freq聚合，将load计算放大。从而触发提升freq，或者迁移等</span><br><span class="line">load放大后，仍遵循基本EAS。提升freq或者迁移，视情况而定。</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-28T11:00:00.000Z" title="4/28/2021, 7:00:00 PM">2021-04-28</time>发表</span><span class="level-item"><time dateTime="2021-05-18T09:28:05.668Z" title="5/18/2021, 5:28:05 PM">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/QCOM/">QCOM</a></span><span class="level-item">12 分钟读完 (大约1823个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/28/schedule/Qcom%20kernel/walt/">walt</a></h1><div class="content"><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h2><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p>walt (Windows Assisted load tracking–窗口协助负载跟踪算法)，主要是跟踪过去一段时间内 entity，rq的负载，给++调频、预测负载、负载均衡++ 等一些调度行为提供一些参考。</p>
<h2 id="walt-数据结构"><a href="#walt-数据结构" class="headerlink" title="walt 数据结构"></a>walt 数据结构</h2><p><code>struct walt_task_struct</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">struct walt_task_struct &#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * &#39;mark_start&#39; marks the beginning of an event (task waking up, task</span><br><span class="line">	 * starting to execute, task being preempted) within a window</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;sum&#39; represents how runnable a task has been within current</span><br><span class="line">	 * window. It incorporates both running time and wait time and is</span><br><span class="line">	 * frequency scaled.</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;sum_history&#39; keeps track of history of &#39;sum&#39; seen over previous</span><br><span class="line">	 * RAVG_HIST_SIZE windows. Windows where task was entirely sleeping are</span><br><span class="line">	 * ignored.</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;demand&#39; represents maximum sum seen over previous</span><br><span class="line">	 * sysctl_sched_ravg_hist_size windows. &#39;demand&#39; could drive frequency</span><br><span class="line">	 * demand for tasks.</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;curr_window_cpu&#39; represents task&#39;s contribution to cpu busy time on</span><br><span class="line">	 * various CPUs in the current window</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;prev_window_cpu&#39; represents task&#39;s contribution to cpu busy time on</span><br><span class="line">	 * various CPUs in the previous window</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;curr_window&#39; represents the sum of all entries in curr_window_cpu</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;prev_window&#39; represents the sum of all entries in prev_window_cpu</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;pred_demand&#39; represents task&#39;s current predicted cpu busy time</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;busy_buckets&#39; groups historical busy time into different buckets</span><br><span class="line">	 * used for prediction</span><br><span class="line">	 *</span><br><span class="line">	 * &#39;demand_scaled&#39; represents task&#39;s demand scaled to 1024</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	u64				mark_start; &#x2F;&#x2F; beginning of events(task start executing or waking up)</span><br><span class="line">	u32				sum; &#x2F;&#x2F; runnable time within a window</span><br><span class="line">	u32				demand; &#x2F;&#x2F; max sum in past serval(sysctl_sched_ravg_hist_size &#x3D;&#x3D; 5) windows</span><br><span class="line">	u32				coloc_demand;</span><br><span class="line">	u32				sum_history[RAVG_HIST_SIZE_MAX];</span><br><span class="line">	u32				*curr_window_cpu, *prev_window_cpu;</span><br><span class="line">	u32				curr_window, prev_window;</span><br><span class="line">	u32				pred_demand;</span><br><span class="line">	u8				busy_buckets[NUM_BUSY_BUCKETS];</span><br><span class="line">	u16				demand_scaled;</span><br><span class="line">	u16				pred_demand_scaled;</span><br><span class="line">	u64				active_time;</span><br><span class="line">	int				boost;</span><br><span class="line">	bool				wake_up_idle;</span><br><span class="line">	bool				misfit;</span><br><span class="line">	bool				rtg_high_prio;</span><br><span class="line">	u8				low_latency;</span><br><span class="line">	u64				boost_period;</span><br><span class="line">	u64				boost_expires;</span><br><span class="line">	u64				last_sleep_ts;</span><br><span class="line">	u32				init_load_pct;</span><br><span class="line">	u32				unfilter;</span><br><span class="line">	u64				last_wake_ts;</span><br><span class="line">	u64				last_enqueued_ts;</span><br><span class="line">	struct walt_related_thread_group __rcu	*grp;</span><br><span class="line">	struct list_head		grp_list;</span><br><span class="line">	u64				cpu_cycles;</span><br><span class="line">	cpumask_t			cpus_requested;</span><br><span class="line">	bool				iowaited;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct task_struct &#123;</span><br><span class="line">	......</span><br><span class="line">	struct sched_entity		se;</span><br><span class="line">	struct sched_rt_entity		rt;</span><br><span class="line">#ifdef CONFIG_SCHED_WALT</span><br><span class="line">	struct walt_task_struct		wts;</span><br><span class="line">#endif</span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><code>struct walt_rq</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct walt_rq &#123;</span><br><span class="line">	struct task_struct	*push_task;</span><br><span class="line">	struct walt_sched_cluster *cluster;</span><br><span class="line">	struct cpumask		freq_domain_cpumask;</span><br><span class="line">	struct walt_sched_stats walt_stats;</span><br><span class="line"></span><br><span class="line">	u64			window_start;</span><br><span class="line">	u32			prev_window_size;</span><br><span class="line">	unsigned long		walt_flags;</span><br><span class="line"></span><br><span class="line">	u64			avg_irqload;</span><br><span class="line">	u64			last_irq_window;</span><br><span class="line">	u64			prev_irq_time;</span><br><span class="line">	struct task_struct	*ed_task;</span><br><span class="line">	u64			task_exec_scale;</span><br><span class="line">	u64			old_busy_time;</span><br><span class="line">	u64			old_estimated_time;</span><br><span class="line">	u64			curr_runnable_sum;</span><br><span class="line">	u64			prev_runnable_sum;</span><br><span class="line">	u64			nt_curr_runnable_sum;</span><br><span class="line">	u64			nt_prev_runnable_sum;</span><br><span class="line">	u64			cum_window_demand_scaled;</span><br><span class="line">	struct group_cpu_time	grp_time;</span><br><span class="line">	struct load_subtractions load_subs[NUM_TRACKED_WINDOWS];</span><br><span class="line">	DECLARE_BITMAP_ARRAY(top_tasks_bitmap,</span><br><span class="line">			NUM_TRACKED_WINDOWS, NUM_LOAD_INDICES);</span><br><span class="line">	u8			*top_tasks[NUM_TRACKED_WINDOWS];</span><br><span class="line">	u8			curr_table;</span><br><span class="line">	int			prev_top;</span><br><span class="line">	int			curr_top;</span><br><span class="line">	bool			notif_pending;</span><br><span class="line">	bool			high_irqload;</span><br><span class="line">	u64			last_cc_update;</span><br><span class="line">	u64			cycles;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct rq &#123;</span><br><span class="line">#ifdef CONFIG_SCHED_WALT</span><br><span class="line">	struct walt_rq		wrq;</span><br><span class="line">#endif &#x2F;* CONFIG_SCHED_WALT *&#x2F;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










<h2 id="walt-api使用"><a href="#walt-api使用" class="headerlink" title="walt api使用"></a>walt api使用</h2><ol>
<li><p>init</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void walt_sched_init_rq(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	int j;</span><br><span class="line"></span><br><span class="line">	if (cpu_of(rq) &#x3D;&#x3D; 0)</span><br><span class="line">		walt_init_once();</span><br><span class="line"></span><br><span class="line">	cpumask_set_cpu(cpu_of(rq), &amp;rq-&gt;wrq.freq_domain_cpumask);</span><br><span class="line"></span><br><span class="line">	rq-&gt;wrq.walt_stats.cumulative_runnable_avg_scaled &#x3D; 0;</span><br><span class="line">	rq-&gt;wrq.prev_window_size &#x3D; sched_ravg_window;</span><br><span class="line">	rq-&gt;wrq.window_start &#x3D; 0;</span><br><span class="line">	rq-&gt;wrq.walt_stats.nr_big_tasks &#x3D; 0;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __init sched_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">	for_each_possible_cpu(i) &#123;</span><br><span class="line">		struct rq *rq;</span><br><span class="line"> 		walt_sched_init_rq(rq);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>set_start()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void set_window_start(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	static int sync_cpu_available;</span><br><span class="line"></span><br><span class="line">	if (likely(rq-&gt;wrq.window_start))</span><br><span class="line">		return;</span><br><span class="line">	if (!sync_cpu_available) &#123;</span><br><span class="line">		rq-&gt;wrq.window_start &#x3D; 1;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>‘</p>
</li>
<li><p>a</p>
</li>
<li></li>
</ol>
<h3 id="WALT-TIME"><a href="#WALT-TIME" class="headerlink" title="WALT TIME"></a>WALT TIME</h3><p>由于存在多个cluster，不同 cluster的频率 和架构都不一样，所以同一 task在不同 cluster上运行，<br>需要的时间是不一样的。为了更好衡量一个 task的负载或者需求，我们必须考虑 cpu freq 和 ipc的差异，<br>所以需要将不同cpu 上运行的task时间 归一化 到同一个度量尺子上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; delta 是 task实际 运行时间</span><br><span class="line">&#x2F;&#x2F; task_exec_scale 是task 执行时间的 刻度，每次在 update_task_rq_cpu_cycles 中更新</span><br><span class="line">static inline u64 scale_exec_time(u64 delta, struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	return (delta * rq-&gt;wrq.task_exec_scale) &gt;&gt; 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned long topology_get_cpu_scale(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	return per_cpu(cpu_scale, cpu);</span><br><span class="line">&#125;</span><br><span class="line">#define arch_scale_cpu_capacity topology_get_cpu_scale</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">update_task_rq_cpu_cycles(struct task_struct *p, struct rq *rq, int event,</span><br><span class="line">			  u64 wallclock, u64 irqtime)</span><br><span class="line">&#123;</span><br><span class="line">      rq-&gt;wrq.task_exec_scale &#x3D; DIV64_U64_ROUNDUP(cpu_cur_freq(cpu) *</span><br><span class="line">         	arch_scale_cpu_capacity(cpu),</span><br><span class="line">         	rq-&gt;wrq.cluster-&gt;max_possible_freq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>        cur_freq</code></pre>
<p>task_exec_scale  =    ———— * scale_capacity<br>            max_freq</p>
<pre><code>            cur_freq</code></pre>
<p>scale_exec_time  =  delta *   ———— * scale_capacity<br>                max_freq</p>
<p><code>scale_capacity</code> 是driver 初始化的时候设置的。</p>
<h3 id="WALT-update"><a href="#WALT-update" class="headerlink" title="WALT update"></a>WALT update</h3><p><code>walt_update_task_ravg()</code> 是 walt的最主要输入，在各种<code>event</code> 下更新负载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">enum task_event &#123;</span><br><span class="line">	PUT_PREV_TASK   &#x3D; 0,</span><br><span class="line">	PICK_NEXT_TASK  &#x3D; 1,</span><br><span class="line">	TASK_WAKE       &#x3D; 2,</span><br><span class="line">	TASK_MIGRATE    &#x3D; 3,</span><br><span class="line">	TASK_UPDATE     &#x3D; 4,</span><br><span class="line">	IRQ_UPDATE      &#x3D; 5,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* Reflect task activity on its demand and cpu&#39;s busy time statistics *&#x2F;</span><br><span class="line">void walt_update_task_ravg(struct task_struct *p, struct rq *rq, int event,</span><br><span class="line">						u64 wallclock, u64 irqtime)</span><br><span class="line">&#123;</span><br><span class="line">	u64 old_window_start;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; rq没有初始化 or task的 mark_start 与 wallclock相等&#x3D;&#x3D;&gt;刚刚才更新过</span><br><span class="line">	if (!rq-&gt;wrq.window_start || p-&gt;wts.mark_start &#x3D;&#x3D; wallclock)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	old_window_start &#x3D; update_window_start(rq, wallclock, event); &#x2F;&#x2F; 更新 rq-&gt;wrq.window_start，方便后面计算</span><br><span class="line"></span><br><span class="line">	if (!p-&gt;wts.mark_start) &#123;</span><br><span class="line">		update_task_cpu_cycles(p, cpu_of(rq), wallclock);</span><br><span class="line">		goto done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	update_task_rq_cpu_cycles(p, rq, event, wallclock, irqtime); &#x2F;&#x2F; 更新 task_exec_scale</span><br><span class="line">	&#x2F;&#x2F; 更新 task的 demand 和 perd_demand 期望下一个window 的运行时间</span><br><span class="line">	update_task_demand(p, rq, event, wallclock);</span><br><span class="line">	update_cpu_busy_time(p, rq, event, wallclock, irqtime); &#x2F;&#x2F;</span><br><span class="line">	update_task_pred_demand(rq, p, event);</span><br><span class="line">	if (event &#x3D;&#x3D; PUT_PREV_TASK &amp;&amp; p-&gt;state)</span><br><span class="line">		p-&gt;wts.iowaited &#x3D; p-&gt;in_iowait;</span><br><span class="line"></span><br><span class="line">	trace_sched_update_task_ravg(p, rq, event, wallclock, irqtime,</span><br><span class="line">				&amp;rq-&gt;wrq.grp_time);</span><br><span class="line">	trace_sched_update_task_ravg_mini(p, rq, event, wallclock, irqtime,</span><br><span class="line">				&amp;rq-&gt;wrq.grp_time);</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	p-&gt;wts.mark_start &#x3D; wallclock;</span><br><span class="line">&#x2F;&#x2F;	void walt_irq_work(struct irq_work *irq_work)</span><br><span class="line">	run_walt_irq_work(old_window_start, rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面关注<code>update_task_demand()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">static u64 update_task_demand(struct task_struct *p, struct rq *rq,</span><br><span class="line">			       int event, u64 wallclock)</span><br><span class="line">&#123;</span><br><span class="line">	u64 mark_start &#x3D; p-&gt;wts.mark_start;</span><br><span class="line">	u64 delta, window_start &#x3D; rq-&gt;wrq.window_start;</span><br><span class="line">	int new_window, nr_full_windows;</span><br><span class="line">	u32 window_size &#x3D; sched_ravg_window;</span><br><span class="line">	u64 runtime;</span><br><span class="line"></span><br><span class="line">	new_window &#x3D; mark_start &lt; window_start;</span><br><span class="line">	&#x2F;&#x2F; window_start &#x3D; rq-&gt;wrq.window_start 在之前俩函数已经更新过了，</span><br><span class="line">	&#x2F;&#x2F; 正常如果经历了新的window，new_window &#x3D;1</span><br><span class="line">	if (!account_busy_for_task_demand(rq, p, event)) &#123;</span><br><span class="line">		if (new_window)</span><br><span class="line">			&#x2F;*</span><br><span class="line">			 * If the time accounted isn&#39;t being accounted as</span><br><span class="line">			 * busy time, and a new window started, only the</span><br><span class="line">			 * previous window need be closed out with the</span><br><span class="line">			 * pre-existing demand. Multiple windows may have</span><br><span class="line">			 * elapsed, but since empty windows are dropped,</span><br><span class="line">			 * it is not necessary to account those.</span><br><span class="line">			 *&#x2F;</span><br><span class="line">			update_history(rq, p, p-&gt;wts.sum, 1, event);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; case: 没有经历新的window，p-&gt;wts.sum +&#x3D; delta， sum是保存所有不满一个 window的时间</span><br><span class="line">	if (!new_window) &#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * The simple case - busy time contained within the existing</span><br><span class="line">		 * window.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		return add_to_task_demand(rq, p, wallclock - mark_start);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Busy time spans at least two windows. Temporarily rewind</span><br><span class="line">	 * window_start to first window boundary after mark_start.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	delta &#x3D; window_start - mark_start;</span><br><span class="line">	nr_full_windows &#x3D; div64_u64(delta, window_size);</span><br><span class="line">	window_start -&#x3D; (u64)nr_full_windows * (u64)window_size;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Process (window_start - mark_start) first *&#x2F;</span><br><span class="line">	runtime &#x3D; add_to_task_demand(rq, p, window_start - mark_start);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Push new sample(s) into task&#39;s demand history *&#x2F;</span><br><span class="line">	update_history(rq, p, p-&gt;wts.sum, 1, event);</span><br><span class="line">	if (nr_full_windows) &#123;</span><br><span class="line">		u64 scaled_window &#x3D; scale_exec_time(window_size, rq);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 为啥这里没有 add_to_task_demand()? ,因为 更新demand也只是更新 p-&gt;wts.sum， 这里</span><br><span class="line">		&#x2F;&#x2F; 因为涉及多个 window，所以 sum肯定会超过一个window的时间。</span><br><span class="line">		&#x2F;&#x2F; 关注 update_history() 中的 p-&gt;wts.sum &#x3D; 0;</span><br><span class="line">		update_history(rq, p, scaled_window, nr_full_windows, event);</span><br><span class="line">		runtime +&#x3D; nr_full_windows * scaled_window;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Roll window_start back to current to process any remainder</span><br><span class="line">	 * in current window.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	window_start +&#x3D; (u64)nr_full_windows * (u64)window_size;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Process (wallclock - window_start) next *&#x2F;</span><br><span class="line">	mark_start &#x3D; window_start;</span><br><span class="line">	runtime +&#x3D; add_to_task_demand(rq, p, wallclock - mark_start);</span><br><span class="line"></span><br><span class="line">	return runtime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>add_to_task_demand()</code> 只是在 <code>scale-invariant</code>的尺度上将当前运行时间累计到 <code>task-&gt;wts.sum</code>上，<code>update_history()</code> 是 更新 <code>p-&gt;wts.sum_history[5]</code> 这个历史窗口的数据，类似不停地滚动，<code>update_history()</code>参数<code>runtime</code>也是 scale之后的，demand是根据不同的WINDOW_STATS_XXX决定的；然后根据 <code>predict_and_update_buckets()</code> 来预测 perd_demand需求，这里用到了buckets算法（不是重点）。</p>
<p>freq_policy_load() – __cpu_util_freq_walt() – cpu_util_freq_walt() – schedutil 使用此接口去获得 cpu使用率</p>
<h3 id="walt-输出api"><a href="#walt-输出api" class="headerlink" title="walt 输出api"></a>walt 输出api</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task_util()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以can_migrate_task()函数为例：</span><br><span class="line"></span><br><span class="line">通过task_util()获取该task的demand，即task级负载</span><br><span class="line"></span><br><span class="line">cpu_util_cum()获取cpu rq的累计demand，即cpu级负载</span><br><span class="line"></span><br><span class="line">如果 dst_cpu累计demand + task_demand &gt; src_cpu累计demand + task_demand，那么说明不满足迁移条件。</span><br></pre></td></tr></table></figure></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/2/">上一页</a></div><div class="pagination-next"><a href="/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link is-current" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/11/">11</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Hui Su"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Hui Su</p><p class="is-size-6 is-block">liulangren bolg</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">101</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">130</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liulangrenaaa" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liulangrenaaa"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.google.com.hk/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Google</span></span><span class="level-right"><span class="level-item tag">www.google.com.hk</span></span></a></li><li><a class="level is-mobile" href="https://lkml.org/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">LKML</span></span><span class="level-right"><span class="level-item tag">lkml.org</span></span></a></li><li><a class="level is-mobile" href="https://mail.google.com/mail" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gmail</span></span><span class="level-right"><span class="level-item tag">mail.google.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhihu.com/explore" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/contest/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 剑指offer</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 周赛</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://tongji.baidu.com/web/32051076/overview/index?siteId=16230094" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">百度分析</span></span><span class="level-right"><span class="level-item tag">tongji.baidu.com</span></span></a></li><li><a class="level is-mobile" href="https://analytics.google.com/analytics/web/#/a187909645p259761261/admin/streams/table/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">google分析</span></span><span class="level-right"><span class="level-item tag">analytics.google.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BRK/"><span class="tag">BRK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KASAN/"><span class="tag">KASAN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OOM/"><span class="tag">OOM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QCOM/"><span class="tag">QCOM</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aarch64/"><span class="tag">aarch64</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpf/"><span class="tag">bpf</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpftrace/"><span class="tag">bpftrace</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup/"><span class="tag">cgroup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v1/"><span class="tag">cgroup v1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v2/"><span class="tag">cgroup v2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/crash/"><span class="tag">crash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dd/"><span class="tag">dd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/deadlock/"><span class="tag">deadlock</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debugfs/"><span class="tag">debugfs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/double-free/"><span class="tag">double free</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/drop-caches/"><span class="tag">drop_caches</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dumpe2fs/"><span class="tag">dumpe2fs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/event-trace/"><span class="tag">event trace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ext2/"><span class="tag">ext2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-attr/"><span class="tag">file attr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-hole/"><span class="tag">file hole</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/filesystem/"><span class="tag">filesystem</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fsck/"><span class="tag">fsck</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ftrace/"><span class="tag">ftrace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gdb/"><span class="tag">gdb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hardlockup/"><span class="tag">hardlockup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hrtimer/"><span class="tag">hrtimer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hugepage/"><span class="tag">hugepage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hungtask/"><span class="tag">hungtask</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/interrupt/"><span class="tag">interrupt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt/"><span class="tag">intrrrupt</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt-storm/"><span class="tag">intrrrupt storm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/irq/"><span class="tag">irq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kdump/"><span class="tag">kdump</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kernel-patch/"><span class="tag">kernel patch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kfence/"><span class="tag">kfence</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kmemleak/"><span class="tag">kmemleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kprobes/"><span class="tag">kprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kretprobes/"><span class="tag">kretprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ksoftirqd/"><span class="tag">ksoftirqd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kthread/"><span class="tag">kthread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvm/"><span class="tag">kvm</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvmtool/"><span class="tag">kvmtool</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/launch-json/"><span class="tag">launch.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-kernel/"><span class="tag">linux kernel</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-native-aio/"><span class="tag">linux native aio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lockdep/"><span class="tag">lockdep</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/makedumpfile/"><span class="tag">makedumpfile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memleak/"><span class="tag">memleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory/"><span class="tag">memory</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory-direct-reclaim/"><span class="tag">memory direct reclaim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mount/"><span class="tag">mount</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/namespace/"><span class="tag">namespace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oom/"><span class="tag">oom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oops/"><span class="tag">oops</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-cache/"><span class="tag">page_cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-owner/"><span class="tag">page_owner</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pagecache/"><span class="tag">pagecache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/panic/"><span class="tag">panic</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/per-cpu/"><span class="tag">per-cpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/perf/"><span class="tag">perf</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pid-namespace/"><span class="tag">pid namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preempt-count/"><span class="tag">preempt_count</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preemption/"><span class="tag">preemption</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pressure/"><span class="tag">pressure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psi/"><span class="tag">psi</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psoix-aio/"><span class="tag">psoix aio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/randomize-va-space/"><span class="tag">randomize_va_space</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rcu/"><span class="tag">rcu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/read-code/"><span class="tag">read code</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sched-latency/"><span class="tag">sched latency</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/schedule/"><span class="tag">schedule</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slab/"><span class="tag">slab</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub/"><span class="tag">slub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub-debug/"><span class="tag">slub_debug</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/softlockup/"><span class="tag">softlockup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stack-overflow/"><span class="tag">stack_overflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-key/"><span class="tag">static_key</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sync/"><span class="tag">sync</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systemTap/"><span class="tag">systemTap</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-json/"><span class="tag">task.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-struct/"><span class="tag">task_struct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tasklet/"><span class="tag">tasklet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thread-info/"><span class="tag">thread_info</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tracepoint/"><span class="tag">tracepoint</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ubuntu/"><span class="tag">ubuntu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/use-after-free/"><span class="tag">use after free</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uts-namespace/"><span class="tag">uts namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/valgrind/"><span class="tag">valgrind</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vdso/"><span class="tag">vdso</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmstat/"><span class="tag">vmstat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmtouch/"><span class="tag">vmtouch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vscode/"><span class="tag">vscode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/x86/"><span class="tag">x86</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xattr/"><span class="tag">xattr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zone/"><span class="tag">zone</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%B6%8A%E7%95%8C/"><span class="tag">内存泄漏越界</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"><span class="tag">内存泄露</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内核内存泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C/"><span class="tag">内核内存越界</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"><span class="tag">内核同步</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0/"><span class="tag">内核抢占</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%A0%88%E6%BA%A2%E5%87%BA/"><span class="tag">内核栈溢出</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E7%AE%A1%E7%AE%A1%E7%90%86/"><span class="tag">内管管理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"><span class="tag">函数调用</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E9%9A%8F%E6%9C%BA%E5%8C%96/"><span class="tag">地址空间布局随机化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/"><span class="tag">性能稳定性</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B3%84%E6%BC%8F/"><span class="tag">文件描述符泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><span class="tag">文件系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E9%A1%B9/"><span class="tag">杂项</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%88/"><span class="tag">栈</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/"><span class="tag">死锁检测</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="tag">生活感悟</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%A8%E6%88%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">用户内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A9%BA%E6%8C%87%E9%92%88/"><span class="tag">空指针</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F/"><span class="tag">虚拟地址空间泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F/"><span class="tag">资源泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%B8%AD%E6%96%AD/"><span class="tag">软中断</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"><span class="tag">进程调度</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/"><span class="tag">通用寄存器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81%E7%B2%92%E5%BA%A6/"><span class="tag">锁粒度</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E7%B3%BB%E7%BB%9F/"><span class="tag">问题系统</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/QCOM/"><span class="level-start"><span class="level-item">QCOM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/cgroup-v1/"><span class="level-start"><span class="level-item">cgroup v1</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/cgroup-v1/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/kernel-debug/"><span class="level-start"><span class="level-item">kernel debug</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-kernel/"><span class="level-start"><span class="level-item">linux kernel</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/"><span class="level-start"><span class="level-item">linux schedule</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/deadline-schedule/"><span class="level-start"><span class="level-item">deadline schedule</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/"><span class="level-start"><span class="level-item">frequency governer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/schedule-util/"><span class="level-start"><span class="level-item">schedule util</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/idle/"><span class="level-start"><span class="level-item">idle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/linux%E5%86%85%E6%A0%B8/"><span class="level-start"><span class="level-item">linux内核</span></span><span class="level-end"><span class="level-item tag">58</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/"><span class="level-start"><span class="level-item">namespace</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/namespace/pid-namespace/"><span class="level-start"><span class="level-item">pid namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/uts-namespace/"><span class="level-start"><span class="level-item">uts namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/qemu/"><span class="level-start"><span class="level-item">qemu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/server/"><span class="level-start"><span class="level-item">server</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/shell%E8%84%9A%E6%9C%AC/"><span class="level-start"><span class="level-item">shell脚本</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="level-start"><span class="level-item">生活感悟</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-23T11:00:00.000Z">2021-09-23</time></p><p class="title"><a href="/2021/09/23/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E9%9A%8F%E6%9C%BA%E5%8C%96/">地址空间布局随机化</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-14T11:00:00.000Z">2021-09-14</time></p><p class="title"><a href="/2021/09/14/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/static_key%E6%9C%BA%E5%88%B6/">static_key机制</a></p><p class="categories"><a href="/categories/kernel-debug/">kernel debug</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-14T11:00:00.000Z">2021-09-14</time></p><p class="title"><a href="/2021/09/14/%E7%BC%96%E8%AF%91%E5%99%A8/gnu%20built_in/">gnu built_in</a></p><p class="categories"><a href="/categories/kernel-debug/">kernel debug</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-14T11:00:00.000Z">2021-09-14</time></p><p class="title"><a href="/2021/09/14/interrupt/aarch64%20%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/">aarch64 中断处理</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-14T11:00:00.000Z">2021-09-14</time></p><p class="title"><a href="/2021/09/14/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/tracepoint%20%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/">tracepoint 原理与使用</a></p><p class="categories"><a href="/categories/kernel-debug/">kernel debug</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Su Hui</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>