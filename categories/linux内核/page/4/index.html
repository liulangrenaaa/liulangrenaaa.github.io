<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: linux内核 - liulangren Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="liulangren blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="liulangren blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="liulangren Blog"><meta property="og:url" content="https://liulangrenaaa.github.io/"><meta property="og:site_name" content="liulangren Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liulangrenaaa.github.io/img/og_image.png"><meta property="article:author" content="Su Hui"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liulangrenaaa.github.io"},"headline":"liulangren Blog","image":["https://liulangrenaaa.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Su Hui"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cabdc5b9b70bb83fa919a6ebeb439f93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=PTKX6HMR55" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'PTKX6HMR55');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">linux内核</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-23T11:00:00.000Z" title="1/23/2021, 7:00:00 PM">2021-01-23</time>发表</span><span class="level-item"><time dateTime="2021-01-22T08:51:22.401Z" title="1/22/2021, 4:51:22 PM">2021-01-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">14 分钟读完 (大约2161个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/23/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E4%BD%BF%E8%83%BDlock_dep%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/">使能lock_dep解决死锁问题</a></h1><div class="content"><p>lockdep 就是 <code>lock dependencies</code> 缩写，翻译是 <code>锁依赖</code>。</p>
<h2 id="如何使能-lockdep"><a href="#如何使能-lockdep" class="headerlink" title="如何使能 lockdep"></a>如何使能 lockdep</h2><p>在 <code>make menuconfig</code> 使能 <code>lockdep</code> 之后，会自动增加如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;CONFIG_LOCKUP_DETECTOR&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">echo &quot;CONFIG_SOFTLOCKUP_DETECTOR&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">echo &quot;CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">echo &quot;CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE&#x3D;1&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">echo &quot;CONFIG_HARDLOCKUP_DETECTOR_PERF&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">echo &quot;CONFIG_HARDLOCKUP_DETECTOR&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">echo &quot;CONFIG_BOOTPARAM_HARDLOCKUP_PANIC&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">echo &quot;CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE&#x3D;1&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br></pre></td></tr></table></figure>
<p>配置之后重新编译运行，会发现在 <code>/proc/lockdep</code> 目录下多出几个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;lock_stat--------置位则可以查看&#x2F;proc&#x2F;lock_stat统计信息，清楚则关闭lockdep统计信息。</span><br><span class="line">&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;max_lock_depth---</span><br><span class="line">&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;prove_locking</span><br><span class="line">&#x2F;proc&#x2F;locks</span><br><span class="line">&#x2F;proc&#x2F;lock_stat-------------------关于锁的使用统计信息</span><br><span class="line">&#x2F;proc&#x2F;lockdep---------------------存在依赖关系的锁</span><br><span class="line">&#x2F;proc&#x2F;lockdep_stats---------------存在依赖关系锁的统计信息</span><br><span class="line">&#x2F;proc&#x2F;lockdep_chains--------------依赖关系锁链表</span><br></pre></td></tr></table></figure>

<h2 id="lockdep-原理"><a href="#lockdep-原理" class="headerlink" title="lockdep 原理"></a>lockdep 原理</h2><p>常见的死锁有如下两种：</p>
<ol>
<li>递归死锁：中断等延迟操作中使用了锁，和外面的锁构成了递归死锁。</li>
<li>AB-BA死锁：多个锁因处理不当而引发死锁，多个内核路径上的所处理顺序不一致也会导致死锁。</li>
</ol>
<p>Linux内核提供死锁调试模块Lockdep，跟踪每个锁的自身状态和各个锁之间的依赖关系，经过一系列的验<br>证规则来确保锁之间依赖关系是正确的。</p>
<p>先看代码注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * this code maps all the lock dependencies as they occur in a live kernel</span><br><span class="line"> * and will warn about the following classes of locking bugs:</span><br><span class="line"> *</span><br><span class="line"> * - lock inversion scenarios</span><br><span class="line"> * - circular lock dependencies</span><br><span class="line"> * - hardirq&#x2F;softirq safe&#x2F;unsafe locking bugs</span><br><span class="line"> *</span><br><span class="line"> * Bugs are reported even if the current locking scenario does not cause</span><br><span class="line"> * any deadlock at this point.</span><br><span class="line"> *</span><br><span class="line"> * I.e. if anytime in the past two locks were taken in a different order,</span><br><span class="line"> * even if it happened for another task, even if those were different</span><br><span class="line"> * locks (but of the same class as this lock), this code will detect it.</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<p>翻译就是可以解决如下的问题</p>
<ol>
<li>锁定反转方案 – ABBA</li>
<li>循环锁依赖性 – 递归锁</li>
<li>hardirq / softirq安全/不安全的锁定错误</li>
</ol>
<h2 id="lockdep-案例"><a href="#lockdep-案例" class="headerlink" title="lockdep 案例"></a>lockdep 案例</h2><p>写了一个<code>ABBA型</code> 基于 spinlock的 deadlock demo。参考 <a target="_blank" rel="noopener" href="https://github.com/liulangrenaaa/test_modules/blob/main/lock_race/lockdep_test/lockdep_test.c">代码</a><br>其实这个demo 会触发多个问题</p>
<ol>
<li>deadlock 被检测出来。</li>
<li>由于是基于 <code>spinlock</code> 的，所以在等待lock的时候一直处于<code>spin</code>，导致 <code>rcu stall</code></li>
<li>等待 <code>20s</code> 之后，由于基于 <code>spinlock</code>的，所以两个cpu一直未调度，发生 <code>soft lockup</code>，然后 panic.</li>
</ol>
<p>编译安装之后，kmsg 显示如下问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[  147.475517] lockdep_test: loading out-of-tree module taints kernel.</span><br><span class="line">[  157.769995]</span><br><span class="line">[  157.770640] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[  157.770683] WARNING: possible circular locking dependency detected</span><br><span class="line">[  157.770683] 5.11.0-rc4+ #5 Tainted: G           O</span><br><span class="line">[  157.770683] ------------------------------------------------------</span><br><span class="line">[  157.770683] krace_0&#x2F;3755 is trying to acquire lock:</span><br><span class="line">[  157.770683] ffffffffc0527468 (&amp;g_lockdep_test.lock_A)&#123;+.+.&#125;-&#123;2:2&#125;, at: klockdep_test_BA+0x2e&#x2F;0x80 [lockdep_test]</span><br><span class="line">[  157.770683]</span><br><span class="line">               but task is already holding lock:</span><br><span class="line">[  157.770683] ffffffffc05274a8 (&amp;g_lockdep_test.lock_B)&#123;+.+.&#125;-&#123;2:2&#125;, at: klockdep_test_BA+0x18&#x2F;0x80 [lockdep_test]</span><br><span class="line">[  157.770683]</span><br><span class="line">               which lock already depends on the new lock.</span><br><span class="line"></span><br><span class="line">[  157.770683]</span><br><span class="line">               the existing dependency chain (in reverse order) is:</span><br><span class="line">[  157.770683]</span><br><span class="line">               -&gt; #1 (&amp;g_lockdep_test.lock_B)&#123;+.+.&#125;-&#123;2:2&#125;:</span><br><span class="line">[  157.770683]        _raw_spin_lock+0x27&#x2F;0x40</span><br><span class="line">[  157.770683]        klockdep_test_AB+0x2e&#x2F;0x80 [lockdep_test]</span><br><span class="line">[  157.770683]        kthread+0x10a&#x2F;0x140</span><br><span class="line">[  157.770683]        ret_from_fork+0x22&#x2F;0x30</span><br><span class="line">[  157.770683]</span><br><span class="line">               -&gt; #0 (&amp;g_lockdep_test.lock_A)&#123;+.+.&#125;-&#123;2:2&#125;:</span><br><span class="line">[  157.770683]        __lock_acquire+0x139e&#x2F;0x28a0</span><br><span class="line">[  157.770683]        lock_acquire+0xbd&#x2F;0x360</span><br><span class="line">[  157.770683]        _raw_spin_lock+0x27&#x2F;0x40</span><br><span class="line">[  157.770683]        klockdep_test_BA+0x2e&#x2F;0x80 [lockdep_test]</span><br><span class="line">[  157.770683]        kthread+0x10a&#x2F;0x140</span><br><span class="line">[  157.770683]        ret_from_fork+0x22&#x2F;0x30</span><br><span class="line">[  157.770683]</span><br><span class="line">               other info that might help us debug this:</span><br><span class="line"></span><br><span class="line">[  157.770683]  Possible unsafe locking scenario:</span><br><span class="line"></span><br><span class="line">[  157.770683]        CPU0                    CPU1</span><br><span class="line">[  157.770683]        ----                    ----</span><br><span class="line">[  157.770683]   lock(&amp;g_lockdep_test.lock_B);</span><br><span class="line">[  157.770683]                                lock(&amp;g_lockdep_test.lock_A);</span><br><span class="line">[  157.770683]                                lock(&amp;g_lockdep_test.lock_B);</span><br><span class="line">[  157.770683]   lock(&amp;g_lockdep_test.lock_A);</span><br><span class="line">[  157.770683]</span><br><span class="line">                *** DEADLOCK ***</span><br><span class="line">[  157.770683] 1 lock held by krace_0&#x2F;3755:</span><br><span class="line">[  157.770683]  #0: ffffffffc05274a8 (&amp;g_lockdep_test.lock_B)&#123;+.+.&#125;-&#123;2:2&#125;, at: klockdep_test_BA+0x18&#x2F;0x80 [lockdep_test]</span><br><span class="line">[  157.770683]</span><br><span class="line">               stack backtrace:</span><br><span class="line">[  157.770683] CPU: 1 PID: 3755 Comm: krace_0 Kdump: loaded Tainted: G           O      5.11.0-rc4+ #5</span><br><span class="line">[  157.770683] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1 04&#x2F;01&#x2F;2014</span><br><span class="line">[  157.770683] Call Trace:</span><br><span class="line">[  157.770683]  dump_stack+0x77&#x2F;0x97</span><br><span class="line">[  157.770683]  check_noncircular+0xfe&#x2F;0x110</span><br><span class="line">[  157.770683]  ? find_held_lock+0x2b&#x2F;0x80</span><br><span class="line">[  157.770683]  __lock_acquire+0x139e&#x2F;0x28a0</span><br><span class="line">[  157.770683]  lock_acquire+0xbd&#x2F;0x360</span><br><span class="line">[  157.770683]  ? klockdep_test_BA+0x2e&#x2F;0x80 [lockdep_test]</span><br><span class="line">[  157.770683]  ? klockdep_test_AB+0x80&#x2F;0x80 [lockdep_test]</span><br><span class="line">[  157.770683]  _raw_spin_lock+0x27&#x2F;0x40</span><br><span class="line">[  157.770683]  ? klockdep_test_BA+0x2e&#x2F;0x80 [lockdep_test]</span><br><span class="line">[  157.770683]  klockdep_test_BA+0x2e&#x2F;0x80 [lockdep_test]</span><br><span class="line">[  157.770683]  kthread+0x10a&#x2F;0x140</span><br><span class="line">[  157.770683]  ? kthread_park+0x80&#x2F;0x80</span><br><span class="line">[  157.770683]  ret_from_fork+0x22&#x2F;0x30</span><br></pre></td></tr></table></figure>

<p>其中可以很明显看到如下提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[  157.770683]        CPU0                    CPU1</span><br><span class="line">[  157.770683]        ----                    ----</span><br><span class="line">[  157.770683]   lock(&amp;g_lockdep_test.lock_B);</span><br><span class="line">[  157.770683]                                lock(&amp;g_lockdep_test.lock_A);</span><br><span class="line">[  157.770683]                                lock(&amp;g_lockdep_test.lock_B);</span><br><span class="line">[  157.770683]   lock(&amp;g_lockdep_test.lock_A);</span><br></pre></td></tr></table></figure>

<p>这个提示简直无敌，完美显示了 <code>deadlock</code> 的原因</p>
<p>写了一个<code>ABBA型</code> 基于 mutex 的 deadlock demo。参考 <a target="_blank" rel="noopener" href="https://github.com/liulangrenaaa/test_modules/blob/main/lock_race/lockdep_test_mutex/lockdep_test_mutex.c">代码</a><br>其实这个demo 会触发多个问题</p>
<ol>
<li>deadlock 被检测出来。</li>
<li>等待 <code>120s</code> 之后，由于基于 <code>mutex</code>的，所以发生死锁的俩线程都是 <code>D状态</code>，所以检测到发生 <code>hung_task</code>，然后 panic.</li>
</ol>
<p>为啥 <code>mutex</code> 的waiter会 处于 <code>D状态</code> ？看看代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static noinline void __sched</span><br><span class="line">__mutex_lock_slowpath(struct mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">	__mutex_lock(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __sched mutex_lock(struct mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">	if (!__mutex_trylock_fast(lock))</span><br><span class="line">		__mutex_lock_slowpath(lock);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(mutex_lock);</span><br></pre></td></tr></table></figure>
<p>发现等待 mutex的线程都会被设置成 <code>TASK_UNINTERRUPTIBLE</code>，也就是 <code>D状态</code>。</p>
<p>也可以通过 hung_task 之后panic 的现场看出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; ps | grep UN</span><br><span class="line">   3193      2   2  ffff9127bb82b240  UN   0.0       0      0  [krace_0]</span><br><span class="line">   3194      2   0  ffff9127c3458040  UN   0.0       0      0  [krace_1]</span><br><span class="line">crash&gt; bt 3193</span><br><span class="line">PID: 3193   TASK: ffff9127bb82b240  CPU: 2   COMMAND: &quot;krace_0&quot;</span><br><span class="line"> #0 [ffffb557007efd78] __schedule at ffffffff8c319af2</span><br><span class="line"> #1 [ffffb557007efe08] schedule at ffffffff8c31a1e6</span><br><span class="line"> #2 [ffffb557007efe20] schedule_preempt_disabled at ffffffff8c31a53c</span><br><span class="line"> #3 [ffffb557007efe28] __mutex_lock at ffffffff8c31bcd5</span><br><span class="line"> #4 [ffffb557007eff08] klockdep_test_mutex_BA at ffffffffc02990b2 [lockdep_test_mutex]</span><br><span class="line"> #5 [ffffb557007eff10] kthread at ffffffff8b6930da</span><br><span class="line"> #6 [ffffb557007eff50] ret_from_fork at ffffffff8b601ae2</span><br><span class="line">crash&gt;</span><br><span class="line">crash&gt; bt 3194</span><br><span class="line">PID: 3194   TASK: ffff9127c3458040  CPU: 0   COMMAND: &quot;krace_1&quot;</span><br><span class="line"> #0 [ffffb557004c3d78] __schedule at ffffffff8c319af2</span><br><span class="line"> #1 [ffffb557004c3e08] schedule at ffffffff8c31a1e6</span><br><span class="line"> #2 [ffffb557004c3e20] schedule_preempt_disabled at ffffffff8c31a53c</span><br><span class="line"> #3 [ffffb557004c3e28] __mutex_lock at ffffffff8c31bcd5</span><br><span class="line"> #4 [ffffb557004c3f08] klockdep_test_mutex_AB at ffffffffc0299032 [lockdep_test_mutex]</span><br><span class="line"> #5 [ffffb557004c3f10] kthread at ffffffff8b6930da</span><br><span class="line"> #6 [ffffb557004c3f50] ret_from_fork at ffffffff8b601ae2</span><br><span class="line">crash&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>krace_0</code> <code>krace_1</code> 线程都是处于 <code>UN</code> 状态，这也导致此时系统负载有<code>2</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; sys</span><br><span class="line">      KERNEL: vmlinux</span><br><span class="line">    DUMPFILE: dump.202101221553  [PARTIAL DUMP]</span><br><span class="line">        CPUS: 4</span><br><span class="line">        DATE: Fri Jan 22 15:53:16 CST 2021</span><br><span class="line">      UPTIME: 00:04:06</span><br><span class="line">LOAD AVERAGE: 1.96, 1.10, 0.46</span><br></pre></td></tr></table></figure>

<p>再看一下 检测到的死锁日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">[   60.151205] lockdep_test_mutex: loading out-of-tree module taints kernel.</span><br><span class="line">[   70.216063]</span><br><span class="line">[   70.216623] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[   70.216866] WARNING: possible circular locking dependency detected</span><br><span class="line">[   70.216866] 5.11.0-rc4+ #5 Tainted: G           O</span><br><span class="line">[   70.216866] ------------------------------------------------------</span><br><span class="line">[   70.216866] krace_0&#x2F;3193 is trying to acquire lock:</span><br><span class="line">[   70.216866] ffffffffc029b4b8 (&amp;g_lockdep_test_mutex.lock_A)&#123;+.+.&#125;-&#123;3:3&#125;, at: klockdep_test_mutex_BA+0x32&#x2F;0x80 [lockdep_test_mutex]</span><br><span class="line">[   70.216866]</span><br><span class="line">               but task is already holding lock:</span><br><span class="line">[   70.216866] ffffffffc029b548 (&amp;g_lockdep_test_mutex.lock_B)&#123;+.+.&#125;-&#123;3:3&#125;, at: klockdep_test_mutex_BA+0x1a&#x2F;0x80 [lockdep_test_mutex]</span><br><span class="line">[   70.216866]</span><br><span class="line">               which lock already depends on the new lock.</span><br><span class="line"></span><br><span class="line">[   70.216866]</span><br><span class="line">               the existing dependency chain (in reverse order) is:</span><br><span class="line">[   70.216866]</span><br><span class="line">               -&gt; #1 (&amp;g_lockdep_test_mutex.lock_B)&#123;+.+.&#125;-&#123;3:3&#125;:</span><br><span class="line">[   70.216866]        __mutex_lock+0x8d&#x2F;0x920</span><br><span class="line">[   70.216866]        klockdep_test_mutex_AB+0x32&#x2F;0x80 [lockdep_test_mutex]</span><br><span class="line">[   70.216866]        kthread+0x10a&#x2F;0x140</span><br><span class="line">[   70.216866]        ret_from_fork+0x22&#x2F;0x30</span><br><span class="line">[   70.216866]</span><br><span class="line">               -&gt; #0 (&amp;g_lockdep_test_mutex.lock_A)&#123;+.+.&#125;-&#123;3:3&#125;:</span><br><span class="line">[   70.216866]        __lock_acquire+0x139e&#x2F;0x28a0</span><br><span class="line">[   70.216866]        lock_acquire+0xbd&#x2F;0x360</span><br><span class="line">[   70.216866]        __mutex_lock+0x8d&#x2F;0x920</span><br><span class="line">[   70.216866]        klockdep_test_mutex_BA+0x32&#x2F;0x80 [lockdep_test_mutex]</span><br><span class="line">[   70.216866]        kthread+0x10a&#x2F;0x140</span><br><span class="line">[   70.216866]        ret_from_fork+0x22&#x2F;0x30</span><br><span class="line">[   70.216866]</span><br><span class="line">               other info that might help us debug this:</span><br><span class="line"></span><br><span class="line">[   70.216866]  Possible unsafe locking scenario:</span><br><span class="line"></span><br><span class="line">[   70.216866]        CPU0                    CPU1</span><br><span class="line">[   70.216866]        ----                    ----</span><br><span class="line">[   70.216866]   lock(&amp;g_lockdep_test_mutex.lock_B);</span><br><span class="line">[   70.216866]                                lock(&amp;g_lockdep_test_mutex.lock_A);</span><br><span class="line">[   70.216866]                                lock(&amp;g_lockdep_test_mutex.lock_B);</span><br><span class="line">[   70.216866]   lock(&amp;g_lockdep_test_mutex.lock_A);</span><br><span class="line">[   70.216866]</span><br><span class="line">                *** DEADLOCK ***</span><br><span class="line"></span><br><span class="line">[   70.216866] 1 lock held by krace_0&#x2F;3193:</span><br><span class="line">[   70.216866]  #0: ffffffffc029b548 (&amp;g_lockdep_test_mutex.lock_B)&#123;+.+.&#125;-&#123;3:3&#125;, at: klockdep_test_mutex_BA+0x1a&#x2F;0x80 [lockdep_test_mutex]</span><br><span class="line">[   70.216866]</span><br><span class="line">               stack backtrace:</span><br><span class="line">[   70.216866] CPU: 2 PID: 3193 Comm: krace_0 Kdump: loaded Tainted: G           O      5.11.0-rc4+ #5</span><br><span class="line">[   70.216866] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1 04&#x2F;01&#x2F;2014</span><br><span class="line">[   70.216866] Call Trace:</span><br><span class="line">[   70.216866]  dump_stack+0x77&#x2F;0x97</span><br><span class="line">[   70.216866]  check_noncircular+0xfe&#x2F;0x110</span><br><span class="line">[   70.216866]  __lock_acquire+0x139e&#x2F;0x28a0</span><br><span class="line">[   70.216866]  lock_acquire+0xbd&#x2F;0x360</span><br><span class="line">[   70.216866]  ? klockdep_test_mutex_BA+0x32&#x2F;0x80 [lockdep_test_mutex]</span><br><span class="line">[   70.216866]  ? lockdep_hardirqs_on_prepare+0xd4&#x2F;0x170</span><br><span class="line">[   70.216866]  ? _raw_spin_unlock_irqrestore+0x34&#x2F;0x40</span><br><span class="line">[   70.216866]  __mutex_lock+0x8d&#x2F;0x920</span><br><span class="line">[   70.216866]  ? klockdep_test_mutex_BA+0x32&#x2F;0x80 [lockdep_test_mutex]</span><br><span class="line">[   70.216866]  ? find_held_lock+0x2b&#x2F;0x80</span><br><span class="line">[   70.216866]  ? klockdep_test_mutex_BA+0x32&#x2F;0x80 [lockdep_test_mutex]</span><br><span class="line">[   70.216866]  ? __next_timer_interrupt+0x100&#x2F;0x100</span><br><span class="line">[   70.216866]  ? klockdep_test_mutex_AB+0x80&#x2F;0x80 [lockdep_test_mutex]</span><br><span class="line">[   70.216866]  ? klockdep_test_mutex_BA+0x32&#x2F;0x80 [lockdep_test_mutex]</span><br><span class="line">[   70.216866]  ? klockdep_test_mutex_AB+0x80&#x2F;0x80 [lockdep_test_mutex]</span><br><span class="line">[   70.216866]  klockdep_test_mutex_BA+0x32&#x2F;0x80 [lockdep_test_mutex]</span><br><span class="line">[   70.216866]  kthread+0x10a&#x2F;0x140</span><br><span class="line">[   70.216866]  ? kthread_park+0x80&#x2F;0x80</span><br><span class="line">[   70.216866]  ret_from_fork+0x22&#x2F;0x30</span><br></pre></td></tr></table></figure>

<p>同样也是 给出了很详细出错位置，对于找出问题代码一如反掌。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[   70.216866]        CPU0                    CPU1</span><br><span class="line">[   70.216866]        ----                    ----</span><br><span class="line">[   70.216866]   lock(&amp;g_lockdep_test_mutex.lock_B);</span><br><span class="line">[   70.216866]                                lock(&amp;g_lockdep_test_mutex.lock_A);</span><br><span class="line">[   70.216866]                                lock(&amp;g_lockdep_test_mutex.lock_B);</span><br><span class="line">[   70.216866]   lock(&amp;g_lockdep_test_mutex.lock_A);</span><br></pre></td></tr></table></figure>

<h2 id="lockdep-代码"><a href="#lockdep-代码" class="headerlink" title="lockdep 代码"></a>lockdep 代码</h2><p>之后填坑</p>
<h2 id="死锁带来的影响"><a href="#死锁带来的影响" class="headerlink" title="死锁带来的影响"></a>死锁带来的影响</h2><p>对于线程自身</p>
<ol>
<li><code>spinlock</code> 的死锁可以带来 线程一直在<code>spin</code>，占用cpu且无法恢复.</li>
<li><code>mutex</code> <code>semaphore</code> <code>rwsem</code> 的死锁会在<code>slowpath</code> 中让线程进入了<br><code>TASK_UNINTERRUPTIBLE</code> 状态，导致不响应外部信号，也无法使用 <code>kill</code> 去杀死</li>
</ol>
<p>对于系统</p>
<ol>
<li><code>spinlock</code> 的死锁可以带来 <code>rcu stall</code> <code>soft lockup</code> <code>hard lockup</code>问题，如果对应项<br>设置了 panic 选项，就会导致 kernel panic.</li>
<li><code>mutex</code> <code>semaphore</code> <code>rwsem</code> 的死锁会带来系统的 load升高，因为都在 <code>slowpath</code> 中让线<br>程进入了<code>TASK_UNINTERRUPTIBLE</code> 状态，会被统计为系统负载，最后会导致 hung_task 发生，如果对应项设置了 panic 选项，就会导致 kernel panic.</li>
</ol>
<p>不同锁进入slowpath的行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mutex:</span><br><span class="line">static noinline void __sched</span><br><span class="line">__mutex_lock_slowpath(struct mutex *lock)</span><br><span class="line">&#123;</span><br><span class="line">	__mutex_lock(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">semaphore:</span><br><span class="line">static noinline void __sched __down(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">	__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">semaphore:</span><br><span class="line">static noinline void __sched __down(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">	__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rwsem:</span><br><span class="line">static inline void __down_write(struct rw_semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">	__down_write_common(sem, TASK_UNINTERRUPTIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以参考：<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20892822/how-to-use-lockdep-feature-in-linux-kernel-for-deadlock-detection">stack overflow提问</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/arnoldlu/p/8580387.html">博客园文章</a><br><a target="_blank" rel="noopener" href="http://kernel.meizu.com/linux-dead-lock-detect-lockdep.html">魅族内核团队文章</a><br><a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/locking/">内核文档</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-21T07:00:00.000Z" title="1/21/2021, 3:00:00 PM">2021-01-21</time>发表</span><span class="level-item"><time dateTime="2021-01-21T11:15:12.397Z" title="1/21/2021, 7:15:12 PM">2021-01-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">8 分钟读完 (大约1209个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/21/crash%E4%B8%93%E9%A2%98/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A9%BA%E6%8C%87%E9%92%88oops/">最简单的空指针oops</a></h1><div class="content"><p>只是做一个记录，为了演示最简单的空指针case, 写了一个demo, 可以参考<a target="_blank" rel="noopener" href="https://github.com/liulangrenaaa/test_modules/blob/main/null_pointer/01_null_pointer/01_null_pointer.c">github 代码</a></p>
<h2 id="用-crash-分析"><a href="#用-crash-分析" class="headerlink" title="用 crash 分析"></a>用 <code>crash</code> 分析</h2><p><code>insmod</code> 出错之后已经生成了相关 <code>dump</code>文件。<br>下面直接使用 <code>crash</code> 工具分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">stable_kernel@kernel: &#x2F;var&#x2F;crash&#x2F;202101211201# sudo crash vmlinux dump</span><br><span class="line">crash 7.2.9++</span><br><span class="line">GNU gdb (GDB) 7.6</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-unknown-linux-gnu&quot;...</span><br><span class="line">WARNING: kernel relocated [704MB]: patching 137170 gdb minimal_symbol values</span><br><span class="line"></span><br><span class="line">      KERNEL: vmlinux</span><br><span class="line">    DUMPFILE: dump.202101211201  [PARTIAL DUMP]</span><br><span class="line">        CPUS: 4</span><br><span class="line">        DATE: Thu Jan 21 12:00:56 CST 2021</span><br><span class="line">      UPTIME: 00:12:53</span><br><span class="line">LOAD AVERAGE: 0.16, 0.11, 0.10</span><br><span class="line">       TASKS: 454</span><br><span class="line">    NODENAME: rlk-Standard-PC-i440FX-PIIX-1996</span><br><span class="line">     RELEASE: 5.11.0-rc4+</span><br><span class="line">     VERSION: #5 SMP Wed Jan 20 20:41:47 CST 2021</span><br><span class="line">     MACHINE: x86_64  (3692 Mhz)</span><br><span class="line">      MEMORY: 2 GB</span><br><span class="line">       PANIC: &quot;Oops: 0002 [#1] SMP NOPTI&quot; (check log for details)</span><br><span class="line">         PID: 3605</span><br><span class="line">     COMMAND: &quot;krace_thread&quot;</span><br><span class="line">        TASK: ffffa1b006754b40  [THREAD_INFO: ffffa1b006754b40]</span><br><span class="line">         CPU: 2</span><br><span class="line">       STATE: TASK_RUNNING (PANIC)</span><br><span class="line"></span><br><span class="line">crash&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到 发生问题的 kernel 版本是 <code>5.11.0-rc4+</code>，编译时间是 <code>#5 SMP Wed Jan 20 20:41:47 CST 2021</code>，内存大小是 <code>2G</code>，出问题时刻的负载是<code>0.16, 0.11, 0.10</code></p>
<p>PANIC 原因是<code>&quot;Oops: 0002 [#1] SMP NOPTI&quot; (check log for details)</code>，CPU:2 上的TASK（krace_thread-3605）: <code>ffffa1b006754b40</code>发生了 oops，具体原因需要看 日志来得到。</p>
<h2 id="bt-查看出问题的task"><a href="#bt-查看出问题的task" class="headerlink" title="bt 查看出问题的task"></a><code>bt</code> 查看出问题的task</h2><p>crash 运行之后默认的task是出问题的task，可以通过 <code>set</code> 查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; set</span><br><span class="line">    PID: 3605</span><br><span class="line">COMMAND: &quot;krace_thread&quot;</span><br><span class="line">   TASK: ffffa1b006754b40  [THREAD_INFO: ffffa1b006754b40]</span><br><span class="line">    CPU: 2</span><br><span class="line">  STATE: TASK_RUNNING (PANIC)</span><br></pre></td></tr></table></figure>

<p>bt 可以查看当前追踪的task的 <code>backtrace</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; bt</span><br><span class="line">PID: 3605   TASK: ffffa1b006754b40  CPU: 2   COMMAND: &quot;krace_thread&quot;</span><br><span class="line"> #0 [ffffbbbf004ebc40] machine_kexec at ffffffffad04d87c</span><br><span class="line"> #1 [ffffbbbf004ebc88] __crash_kexec at ffffffffad1283b8</span><br><span class="line"> #2 [ffffbbbf004ebd50] crash_kexec at ffffffffad1290d0</span><br><span class="line"> #3 [ffffbbbf004ebd60] oops_end at ffffffffad021d75</span><br><span class="line"> #4 [ffffbbbf004ebd80] no_context at ffffffffad0570e0</span><br><span class="line"> #5 [ffffbbbf004ebdf0] __bad_area_nosemaphore at ffffffffad0572c7</span><br><span class="line"> #6 [ffffbbbf004ebe38] exc_page_fault at ffffffffadd16b67</span><br><span class="line"> #7 [ffffbbbf004ebe60] asm_exc_page_fault at ffffffffade00ace</span><br><span class="line"> #8 [ffffbbbf004ebee8] create_oops at ffffffffc0371027 [01_null_pointer]</span><br><span class="line"> #9 [ffffbbbf004ebf10] kthread at ffffffffad0930da</span><br><span class="line">#10 [ffffbbbf004ebf50] ret_from_fork at ffffffffad001ae2</span><br></pre></td></tr></table></figure>
<p><code>bt -c 1</code>： 可以查看 cpu:1 上当前运行的线程的backtrace<br><code>bt -a</code>  ： 可以查看 当前所有 cpu上运行的线程的backtrace</p>
<p>这个case 十分显然，是 <code>create_oops</code> 这里出现了问题。</p>
<h2 id="dis-查看bug地址"><a href="#dis-查看bug地址" class="headerlink" title="dis 查看bug地址"></a>dis 查看bug地址</h2><p><code>dis</code> 是 disassemble 反汇编的缩写，可以</p>
<ol>
<li>查看出问题 <code>text</code> 地址内容</li>
<li>某个函数 <code>symbol</code> 符号内容</li>
<li>某个函数 <code>symbol</code> 符号 + 偏移的内容</li>
<li>某个符号 或者 <code>text</code> 与 代码行显示在一起（如果是<code>module</code> 中crash需要加载 module.ko）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; dis ffffffffc0371027</span><br><span class="line">0xffffffffc0371027 &lt;create_oops+39&gt;:    movl   $0x0,0x0</span><br><span class="line">crash&gt;</span><br><span class="line">crash&gt; dis create_oops</span><br><span class="line">0xffffffffc0371000 &lt;create_oops&gt;:       mov    $0x1388,%edi</span><br><span class="line">0xffffffffc0371005 &lt;create_oops+5&gt;:     callq  0xffffffffad104b80 &lt;msleep&gt;</span><br><span class="line">0xffffffffc037100a &lt;create_oops+10&gt;:    mov    $0xffffffffc037203c,%rdi</span><br><span class="line">0xffffffffc0371011 &lt;create_oops+17&gt;:    callq  0xffffffffadcc96da &lt;printk&gt;</span><br><span class="line">0xffffffffc0371016 &lt;create_oops+22&gt;:    mov    $0x1388,%edi</span><br><span class="line">0xffffffffc037101b &lt;create_oops+27&gt;:    callq  0xffffffffad104b80 &lt;msleep&gt;</span><br><span class="line">0xffffffffc0371020 &lt;create_oops+32&gt;:    mov    $0xffffffffc037204f,%rdi</span><br><span class="line">0xffffffffc0371027 &lt;create_oops+39&gt;:    movl   $0x0,0x0</span><br><span class="line">0xffffffffc0371032 &lt;create_oops+50&gt;:    callq  0xffffffffadcc96da &lt;printk&gt;</span><br><span class="line">0xffffffffc0371037 &lt;create_oops+55&gt;:    xor    %eax,%eax</span><br><span class="line">0xffffffffc0371039 &lt;create_oops+57&gt;:    retq</span><br><span class="line">crash&gt; dis create_oops+39</span><br><span class="line">0xffffffffc0371027 &lt;create_oops+39&gt;:    movl   $0x0,0x0</span><br><span class="line">crash&gt;</span><br></pre></td></tr></table></figure>

<p>直接可以看出问题是，将立即数<code>$0x0</code> 赋值到 地址<code>0x0</code>中，所以直接 oops了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xffffffffc0371027 &lt;create_oops+39&gt;:    movl   $0x0,0x0</span><br></pre></td></tr></table></figure>


<p>但是在哪一行呢，这就需要加载 ko文件了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; lsmod</span><br><span class="line">     MODULE       NAME              SIZE  OBJECT FILE</span><br><span class="line">ffffffffc0373000  01_null_pointer  16384  (not loaded)  [CONFIG_KALLSYMS]</span><br><span class="line">crash&gt;</span><br><span class="line">crash&gt;</span><br><span class="line">crash&gt; mod -s 01_null_pointer &#x2F;tmp&#x2F;share&#x2F;test_modules&#x2F;null_pointer&#x2F;01_null_pointer&#x2F;01_null_pointer.ko</span><br><span class="line">     MODULE       NAME              SIZE  OBJECT FILE</span><br><span class="line">ffffffffc0373000  01_null_pointer  16384  &#x2F;tmp&#x2F;share&#x2F;test_modules&#x2F;null_pointer&#x2F;01_null_pointer&#x2F;01_null_pointer.ko</span><br><span class="line">crash&gt;</span><br><span class="line">crash&gt; lsmod</span><br><span class="line">     MODULE       NAME              SIZE  OBJECT FILE</span><br><span class="line">ffffffffc0373000  01_null_pointer  16384  &#x2F;tmp&#x2F;share&#x2F;test_modules&#x2F;null_pointer&#x2F;01_null_pointer&#x2F;01_null_pointer.ko</span><br><span class="line">crash&gt;</span><br></pre></td></tr></table></figure>

<p>加载 ko文件之后，直接 <code>dis -l</code> 反汇编 出问题的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; dis -l create_oops</span><br><span class="line">&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share&#x2F;test_modules&#x2F;null_pointer&#x2F;01_null_pointer&#x2F;01_null_pointer.c: 12</span><br><span class="line">0xffffffffc0371000 &lt;create_oops&gt;:       mov    $0x1388,%edi</span><br><span class="line">0xffffffffc0371005 &lt;create_oops+5&gt;:     callq  0xffffffffad104b80 &lt;msleep&gt;</span><br><span class="line">&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share&#x2F;test_modules&#x2F;null_pointer&#x2F;01_null_pointer&#x2F;01_null_pointer.c: 13</span><br><span class="line">0xffffffffc037100a &lt;create_oops+10&gt;:    mov    $0xffffffffc037203c,%rdi</span><br><span class="line">0xffffffffc0371011 &lt;create_oops+17&gt;:    callq  0xffffffffadcc96da &lt;printk&gt;</span><br><span class="line">&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share&#x2F;test_modules&#x2F;null_pointer&#x2F;01_null_pointer&#x2F;01_null_pointer.c: 14</span><br><span class="line">0xffffffffc0371016 &lt;create_oops+22&gt;:    mov    $0x1388,%edi</span><br><span class="line">0xffffffffc037101b &lt;create_oops+27&gt;:    callq  0xffffffffad104b80 &lt;msleep&gt;</span><br><span class="line">&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share&#x2F;test_modules&#x2F;null_pointer&#x2F;01_null_pointer&#x2F;01_null_pointer.c: 16</span><br><span class="line">0xffffffffc0371020 &lt;create_oops+32&gt;:    mov    $0xffffffffc037204f,%rdi</span><br><span class="line">0xffffffffc0371027 &lt;create_oops+39&gt;:    movl   $0x0,0x0</span><br><span class="line">&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share&#x2F;test_modules&#x2F;null_pointer&#x2F;01_null_pointer&#x2F;01_null_pointer.c: 17</span><br><span class="line">0xffffffffc0371032 &lt;create_oops+50&gt;:    callq  0xffffffffadcc96da &lt;printk&gt;</span><br><span class="line">&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share&#x2F;test_modules&#x2F;null_pointer&#x2F;01_null_pointer&#x2F;01_null_pointer.c: 18</span><br><span class="line">0xffffffffc0371037 &lt;create_oops+55&gt;:    xor    %eax,%eax</span><br><span class="line">0xffffffffc0371039 &lt;create_oops+57&gt;:    retq</span><br></pre></td></tr></table></figure>

<p>直接定位到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01_null_pointer.c: 16</span><br><span class="line">0xffffffffc0371020 &lt;create_oops+32&gt;:    mov    $0xffffffffc037204f,%rdi</span><br><span class="line">0xffffffffc0371027 &lt;create_oops+39&gt;:    movl   $0x0,0x0</span><br></pre></td></tr></table></figure>

<p>代码中看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(int *)0 &#x3D; 0;</span><br></pre></td></tr></table></figure>

<p>问题很快解决了。</p>
<h2 id="试着查看x86-如何调用函数传参的"><a href="#试着查看x86-如何调用函数传参的" class="headerlink" title="试着查看x86 如何调用函数传参的"></a>试着查看x86 如何调用函数传参的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share&#x2F;test_modules&#x2F;null_pointer&#x2F;01_null_pointer&#x2F;01_null_pointer.c: 12</span><br><span class="line">0xffffffffc0371000 &lt;create_oops&gt;:       mov    $0x1388,%edi</span><br><span class="line">0xffffffffc0371005 &lt;create_oops+5&gt;:     callq  0xffffffffad104b80 &lt;msleep&gt;</span><br></pre></td></tr></table></figure>

<p>对应代码是，<code>0x1388</code> 就是十六进制的 <code>5000</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msleep(5000);</span><br></pre></td></tr></table></figure>
<p>是不是第一个整形参数是存在 <code>edi</code> 寄存器中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share&#x2F;test_modules&#x2F;null_pointer&#x2F;01_null_pointer&#x2F;01_null_pointer.c: 13</span><br><span class="line">0xffffffffc037100a &lt;create_oops+10&gt;:    mov    $0xffffffffc037203c,%rdi</span><br><span class="line">0xffffffffc0371011 &lt;create_oops+17&gt;:    callq  0xffffffffadcc96da &lt;printk&gt;</span><br></pre></td></tr></table></figure>

<p>对应的代码是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(&quot;create_oops start\n&quot;);</span><br></pre></td></tr></table></figure>

<p><code>0xffffffffc037203c</code> 是啥呢？可以使用 <code>rd</code> 命令读取一下，原来是字符串的起始的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crash&gt; rd 0xffffffffc037203c 4</span><br><span class="line">ffffffffc037203c:  6f5f657461657263 726174732073706f   create_oops star</span><br><span class="line">ffffffffc037204c:  7461657263000a74 652073706f6f5f65   t..create_oops e</span><br><span class="line">crash&gt;</span><br></pre></td></tr></table></figure>
<p>是不是 第一个地址型参数是存放在 <code>rdi</code> 中的呢？</p>
<p>后面会用不同个数参数，不同类型参数的函数 crash，来实验一下这个是不是对～</p>
<p>找到<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27339191">一篇讲解x86-64寄存器和函数调用的文章</a>，上面说的猜想就是扯淡。。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-17T11:00:00.000Z" title="1/17/2021, 7:00:00 PM">2021-01-17</time>发表</span><span class="level-item"><time dateTime="2021-01-21T09:06:22.284Z" title="1/21/2021, 5:06:22 PM">2021-01-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">12 分钟读完 (大约1859个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/17/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/valgrind%20%E5%AE%9A%E4%BD%8D%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">valgrind 定位用户空间内存泄漏</a></h1><div class="content"><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h2><p>在实际开发中，某个应用程序如果存在内存泄露，且是长时间运行的程序，就会导致比较严重的后果。<br>在一些业务场景的长跑测试中，这些问题往往会充分暴露出来。</p>
<p>一般情况下这种内存泄漏都是以 OOM Kill 而结尾的。 kmsg log 往往只有 这个进程确实消耗了大量进<br>程的证据，但是无法确切知道是哪里的内存泄漏，这里就需要一个工具来帮助检测，如果是发生内存泄漏之后<br>仅仅通过人肉去分析代码，往往很困难。</p>
<p>valgrind 就是这样一款 强大的工具：</p>
<ol>
<li>检查用户空间内存泄漏</li>
<li>检查</li>
</ol>
<h2 id="valdrind-原理"><a href="#valdrind-原理" class="headerlink" title="valdrind 原理"></a>valdrind 原理</h2><h2 id="valdrind-安装，使用"><a href="#valdrind-安装，使用" class="headerlink" title="valdrind 安装，使用"></a>valdrind 安装，使用</h2><p>直接安装， ubuntu 官方软件源已经包含了，其他平台可以通过源码编译安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@100ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak# sudo apt install valgrind</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following packages were automatically installed and are no longer required:</span><br><span class="line">  openbsd-inetd openjdk-11-jdk-headless tcpd update-inetd</span><br><span class="line">Use &#39;sudo apt autoremove&#39; to remove them.</span><br><span class="line">Suggested packages:</span><br><span class="line">  valgrind-dbg valgrind-mpi kcachegrind alleyoop valkyrie</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  valgrind</span><br><span class="line">0 upgraded, 1 newly installed, 0 to remove and 231 not upgraded.</span><br><span class="line">Need to get 20.3 MB of archives.</span><br><span class="line">After this operation, 90.0 MB of additional disk space will be used.</span><br><span class="line">Get:1 https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu focal-updates&#x2F;main amd64 valgrind amd64 1:3.15.0-1ubuntu9.1 [20.3 MB]</span><br><span class="line">48% [1 valgrind 12.2 MB&#x2F;20.3 MB 60%]</span><br><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak# ls</span><br></pre></td></tr></table></figure>

<p>使用如下代码检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int i &#x3D; 3;</span><br><span class="line">        char *p &#x3D; NULL;</span><br><span class="line">        p &#x3D; malloc(1024 * 1024);</span><br><span class="line">        if (!p)</span><br><span class="line">                printf(&quot;malloc failed,just wait!!\n&quot;);</span><br><span class="line"></span><br><span class="line">        printf(&quot;malloc sucess,just wait!!\n&quot;);</span><br><span class="line"></span><br><span class="line">        while(i--) &#123;</span><br><span class="line">                usleep(1000 * 1000);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于 valgrind 不好的地方在于：</p>
<ol>
<li><p>对于想使用 valgrind来检查内存泄漏的业务来说，必须从开始 用valgrind 启动，意味着对于业务<br>需要重启。还有比如很难复现的内存泄漏，等你重启业务用 valgrind来启动，说不定又不复现了。。</p>
</li>
<li><p>对于 valgrind 启动的业务来说，会比直接启动有一些性能损失。</p>
</li>
</ol>
<h3 id="userspace-memleak-demo"><a href="#userspace-memleak-demo" class="headerlink" title="userspace memleak demo"></a>userspace memleak demo</h3><p>使用上面代码 直接用 <code>valgrind</code> 启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak# valgrind .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Command: .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;</span><br><span class="line">malloc sucess,just wait!!</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;     in use at exit: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;   total heap usage: 2 allocs, 1 frees, 1,049,600 bytes allocated</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; LEAK SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;    definitely lost: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;    still reachable: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;         suppressed: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Rerun with --leak-check&#x3D;full to see details of leaked memory</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>HEAP SUMMARY:</code> 中写了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;     in use at exit: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;   total heap usage: 2 allocs, 1 frees, 1,049,600 bytes allocated</span><br></pre></td></tr></table></figure>
<p>在进程退出时，仍然有 <code>1048576 bytes</code> 内存在使用中，这部分就是泄漏的内存。但是我们仍然不能确<br>定到底是哪里泄漏的内存，按照他的建议 加上 <code>-leak-check=full</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak# valgrind  --leak-check&#x3D;full  .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; Command: .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;</span><br><span class="line">malloc sucess,just wait!!</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;     in use at exit: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;   total heap usage: 2 allocs, 1 frees, 1,049,600 bytes allocated</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D; 1,048,576 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    by 0x1091AD: main (in &#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak&#x2F;a.out)</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; LEAK SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    definitely lost: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    still reachable: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;         suppressed: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span><br><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak#</span><br></pre></td></tr></table></figure>

<p>可以看到这次， <code>valgrind</code> 已经将泄漏的具体位置打印了出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2813434&#x3D; 1,048,576 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    by 0x1091AD: main (in &#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak&#x2F;a.out)</span><br></pre></td></tr></table></figure>

<p>可以用 <code>gcc -g</code> 重新编译一下带上符号表信息，再次用 valgrind 定位，可以得到更详细信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2822695&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2822695&#x3D;&#x3D;    by 0x1091AD: main (user_space_memleak.c:9)</span><br></pre></td></tr></table></figure>
<p>这次直接将 在 哪个文件 哪一行都直接打印出来了。</p>
<h3 id="out-of-bounds-access-demo"><a href="#out-of-bounds-access-demo" class="headerlink" title="out of bounds access demo"></a>out of bounds access demo</h3><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int i &#x3D; 3;</span><br><span class="line">        char *p &#x3D; NULL;</span><br><span class="line">        p &#x3D; malloc(1024);</span><br><span class="line">        if (!p)</span><br><span class="line">                printf(&quot;malloc failed,just wait!!\n&quot;);</span><br><span class="line"></span><br><span class="line">        printf(&quot;malloc sucess,just wait!!*(p + 10) &#x3D; %d\n&quot;, *(p + 10));</span><br><span class="line">        *(p + 1023) &#x3D; *(p + 1024);</span><br><span class="line">        *(p + 1024) &#x3D; 1;</span><br><span class="line">        while(i--) &#123;</span><br><span class="line">                usleep(1000 * 1000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free(p);</span><br><span class="line">        free(p + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gcc -g</code> 编译之偶 用 <code>valgrind ./a.out</code> 跑一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;valgrind# valgrind .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Command: .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D; Use of uninitialised value of size 8</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    at 0x48B681B: _itoa_word (_itoa.c:179)</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    by 0x48D26F4: __vfprintf_internal (vfprintf-internal.c:1687)</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    by 0x48BCEBE: printf (printf.c:33)</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    by 0x109225: main (out_of_bounds_access.c:13)</span><br><span class="line">malloc sucess,just wait!!</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Invalid read of size 1</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x109200: main (out_of_bounds_access.c:14)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;  Address 0x4a4d440 is 0 bytes after a block of size 1,024 alloc&#39;d</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    by 0x1091CD: main (out_of_bounds_access.c:9)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Invalid write of size 1</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x109213: main (out_of_bounds_access.c:15)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;  Address 0x4a4d440 is 0 bytes after a block of size 1,024 alloc&#39;d</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    by 0x1091CD: main (out_of_bounds_access.c:9)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D; Invalid free() &#x2F; delete &#x2F; delete[] &#x2F; realloc()</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    at 0x483CA3F: free (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    by 0x10927F: main (out_of_bounds_access.c:21)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;  Address 0x4a4d041 is 1 bytes inside a block of size 1,024 free&#39;d</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    at 0x483CA3F: free (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    by 0x10926F: main (out_of_bounds_access.c:20)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;  Block was alloc&#39;d at</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    by 0x1091ED: main (out_of_bounds_access.c:9)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;   total heap usage: 2 allocs, 3 frees, 2,048 bytes allocated</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; All heap blocks were freed -- no leaks are possible</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<p>也是直接指出了 一次引用未初始化的内存, 两次越界访问, 一次非法 free：</p>
<ol>
<li><p>一次引用为初始化的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D; Use of uninitialised value of size 8</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    at 0x48B681B: _itoa_word (_itoa.c:179)</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    by 0x48D26F4: __vfprintf_internal (vfprintf-internal.c:1687)</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    by 0x48BCEBE: printf (printf.c:33)</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    by 0x109225: main (out_of_bounds_access.c:13)</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次越界读访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Invalid read of size 1</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x109200: main (out_of_bounds_access.c:14)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;  Address 0x4a4d440 is 0 bytes after a block of size 1,024 alloc&#39;d</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    by 0x1091CD: main (out_of_bounds_access.c:9)</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次越界写访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Invalid write of size 1</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x109213: main (out_of_bounds_access.c:15)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;  Address 0x4a4d440 is 0 bytes after a block of size 1,024 alloc&#39;d</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    by 0x1091CD: main (out_of_bounds_access.c:9)</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次 invaild free</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D; Invalid free() &#x2F; delete &#x2F; delete[] &#x2F; realloc()</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    at 0x483CA3F: free (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    by 0x10927F: main (out_of_bounds_access.c:21)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;  Address 0x4a4d041 is 1 bytes inside a block of size 1,024 free&#39;d</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    at 0x483CA3F: free (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    by 0x10926F: main (out_of_bounds_access.c:20)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;  Block was alloc&#39;d at</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    by 0x1091ED: main (out_of_bounds_access.c:9)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际项目中应用的内存泄漏往往比这要复杂很多，可能代码考虑了正常情况下的 free，异常情况下没有<br>free等， <code>valgrind</code> 是很强大，有很多参数，但也只能帮助我们在出现问题之后定位，还是需要养成良<br>好的编码习惯，减少杜绝这类问题</p>
<p>参考<a target="_blank" rel="noopener" href="http://senlinzhan.github.io/2017/12/31/valgrind/">文章1</a><br>参考<a target="_blank" rel="noopener" href="https://www.cprogramming.com/debugging/valgrind.html">文章2</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-16T11:00:00.000Z" title="1/16/2021, 7:00:00 PM">2021-01-16</time>发表</span><span class="level-item"><time dateTime="2021-01-31T09:47:29.081Z" title="1/31/2021, 5:47:29 PM">2021-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">7 分钟读完 (大约1122个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/16/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/kmemleak%20%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">kmemleak 定位内存泄露</a></h1><div class="content"><h2 id="kmemleak-原理"><a href="#kmemleak-原理" class="headerlink" title="kmemleak 原理"></a>kmemleak 原理</h2><p>Basic Algorithm<br>The memory allocations via kmalloc(), vmalloc(), kmem_cache_alloc() and friends are traced and the pointers, together with additional information like size and stack trace, are stored in a rbtree. The corresponding freeing function calls are tracked and the pointers removed from the kmemleak data structures.</p>
<p>An allocated block of memory is considered orphan if no pointer to its start address or to any location inside the block can be found by scanning the memory (including saved registers). This means that there might be no way for the kernel to pass the address of the allocated block to a freeing function and therefore the block is considered a memory leak.</p>
<p>The scanning algorithm steps:</p>
<p>mark all objects as white (remaining white objects will later be considered orphan)<br>scan the memory starting with the data section and stacks, checking the values against the addresses stored in the rbtree. If a pointer to a white object is found, the object is added to the gray list<br>scan the gray objects for matching addresses (some white objects can become gray and added at the end of the gray list) until the gray set is finished<br>the remaining white objects are considered orphan and reported via /sys/kernel/debug/kmemleak<br>Some allocated memory blocks have pointers stored in the kernel’s internal data structures and they cannot be detected as orphans. To avoid this, kmemleak can also store the number of values pointing to an address inside the block address range that need to be found so that the block is not considered a leak. One example is __vmalloc().</p>
<h2 id="kmemleak-使用"><a href="#kmemleak-使用" class="headerlink" title="kmemleak 使用"></a>kmemleak 使用</h2><p>kmemleak 功能一开始默认是不开启的，需要配置如下选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [ $debug_kmemleak &#x3D;&#x3D; 1 ]</span><br><span class="line">then</span><br><span class="line">## kmemleak detect and panic start</span><br><span class="line">	echo &quot;CONFIG_DEBUG_KMEMLEAK&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">	echo &quot;CONFIG_DEBUG_KMEMLEAK_MEM_POOL_SIZE&#x3D;16000&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">	echo &quot;CONFIG_DEBUG_KMEMLEAK_AUTO_SCAN&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">	echo &quot;CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE&#x3D;1&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">## kmemleak detect and panic end</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>参考<a target="_blank" rel="noopener" href="https://github.com/liulangrenaaa/test_modules/blob/main/resource_leak/kmemleak/kmemleak.c">test code</a></p>
<p>一开始遇到了无法安装的问题，后来发现是因为模块名 一样导致的问题。。<br>参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16360689/invalid-parameters-error-when-trying-to-insert-module-that-accesses-exported-s">bug</a></p>
<p>触发开始扫描，这是个同步过程，内存比较大的话可能比较耗时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# echo scan &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;kmemleak</span><br><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug#</span><br></pre></td></tr></table></figure>

<p>查看扫描结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# cat kmemleak</span><br><span class="line">unreferenced object 0xffff8da0cac1c500 (size 32):</span><br><span class="line">  comm &quot;insmod&quot;, pid 3529, jiffies 4294873584 (age 562.798s)</span><br><span class="line">  hex dump (first 32 bytes):</span><br><span class="line">    6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class="line">    6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5  kkkkkkkkkkkkkkk.</span><br><span class="line">  backtrace:</span><br><span class="line">    [&lt;00000000ae5c9724&gt;] 0xffffffffc030702d</span><br><span class="line">    [&lt;00000000afc3b54e&gt;] do_one_initcall+0x56&#x2F;0x2b0</span><br><span class="line">    [&lt;000000000724192e&gt;] do_init_module+0x56&#x2F;0x200</span><br><span class="line">    [&lt;00000000996ecfff&gt;] load_module+0x2348&#x2F;0x26e0</span><br><span class="line">    [&lt;000000004fa63e1a&gt;] __do_sys_finit_module+0xa0&#x2F;0xe0</span><br><span class="line">    [&lt;00000000cddcb6e5&gt;] do_syscall_64+0x33&#x2F;0x40</span><br><span class="line">    [&lt;00000000a0266b85&gt;] entry_SYSCALL_64_after_hwframe+0x44&#x2F;0xa9</span><br><span class="line">unreferenced object 0xffff8da0d2371000 (size 1024):</span><br><span class="line">  comm &quot;insmod&quot;, pid 3529, jiffies 4294873584 (age 562.798s)</span><br><span class="line">  hex dump (first 32 bytes):</span><br><span class="line">    6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class="line">    6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class="line">  backtrace:</span><br><span class="line">    [&lt;0000000079fd2c9c&gt;] 0xffffffffc030709c</span><br><span class="line">    [&lt;00000000afc3b54e&gt;] do_one_initcall+0x56&#x2F;0x2b0</span><br><span class="line">    [&lt;000000000724192e&gt;] do_init_module+0x56&#x2F;0x200</span><br><span class="line">    [&lt;00000000996ecfff&gt;] load_module+0x2348&#x2F;0x26e0</span><br><span class="line">    [&lt;000000004fa63e1a&gt;] __do_sys_finit_module+0xa0&#x2F;0xe0</span><br><span class="line">    [&lt;00000000cddcb6e5&gt;] do_syscall_64+0x33&#x2F;0x40</span><br><span class="line">    [&lt;00000000a0266b85&gt;] entry_SYSCALL_64_after_hwframe+0x44&#x2F;0xa9</span><br><span class="line">unreferenced object 0xffff8da0ca534000 (size 4096):</span><br><span class="line">  comm &quot;insmod&quot;, pid 3529, jiffies 4294873584 (age 562.862s)</span><br><span class="line">  hex dump (first 32 bytes):</span><br><span class="line">    6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class="line">    6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class="line">  backtrace:</span><br><span class="line">    [&lt;000000000526120c&gt;] 0xffffffffc0307130</span><br><span class="line">    [&lt;00000000afc3b54e&gt;] do_one_initcall+0x56&#x2F;0x2b0</span><br><span class="line">    [&lt;000000000724192e&gt;] do_init_module+0x56&#x2F;0x200</span><br><span class="line">    [&lt;00000000996ecfff&gt;] load_module+0x2348&#x2F;0x26e0</span><br><span class="line">    [&lt;000000004fa63e1a&gt;] __do_sys_finit_module+0xa0&#x2F;0xe0</span><br><span class="line">    [&lt;00000000cddcb6e5&gt;] do_syscall_64+0x33&#x2F;0x40</span><br><span class="line">    [&lt;00000000a0266b85&gt;] entry_SYSCALL_64_after_hwframe+0x44&#x2F;0xa9</span><br><span class="line">unreferenced object 0xffffaa50801fb000 (size 4096):</span><br><span class="line">  comm &quot;insmod&quot;, pid 3529, jiffies 4294873584 (age 562.862s)</span><br><span class="line">  hex dump (first 32 bytes):</span><br><span class="line">    27 94 40 81 50 aa ff ff 27 04 00 00 00 00 00 00  &#39;.@.P...&#39;.......</span><br><span class="line">    7c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  |...............</span><br><span class="line">  backtrace:</span><br><span class="line">    [&lt;00000000854ee6a4&gt;] __vmalloc_node_range+0x236&#x2F;0x270</span><br><span class="line">    [&lt;00000000a355227b&gt;] __vmalloc_node+0x3f&#x2F;0x60</span><br><span class="line">    [&lt;0000000039b16a7e&gt;] 0xffffffffc0307149</span><br><span class="line">    [&lt;00000000afc3b54e&gt;] do_one_initcall+0x56&#x2F;0x2b0</span><br><span class="line">    [&lt;000000000724192e&gt;] do_init_module+0x56&#x2F;0x200</span><br><span class="line">    [&lt;00000000996ecfff&gt;] load_module+0x2348&#x2F;0x26e0</span><br><span class="line">    [&lt;000000004fa63e1a&gt;] __do_sys_finit_module+0xa0&#x2F;0xe0</span><br><span class="line">    [&lt;00000000cddcb6e5&gt;] do_syscall_64+0x33&#x2F;0x40</span><br><span class="line">    [&lt;00000000a0266b85&gt;] entry_SYSCALL_64_after_hwframe+0x44&#x2F;0xa9</span><br><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug#</span><br></pre></td></tr></table></figure>
<p>可以比较清楚的看到 可能leak的 object点，且有详细调用栈，排查起来十分方便</p>
<p>清除之前扫描结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# echo clear  &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;kmemleak</span><br><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# cat kmemleak</span><br><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug#</span><br></pre></td></tr></table></figure>

<h2 id="kmemleak-代码"><a href="#kmemleak-代码" class="headerlink" title="kmemleak 代码"></a>kmemleak 代码</h2><p>后续填坑</p>
<h2 id="kmemleak-overhead"><a href="#kmemleak-overhead" class="headerlink" title="kmemleak overhead"></a>kmemleak overhead</h2><p>当然假设我们场景允许 使能kmemleak之后，重新编译 kernel，也要关心 kmemleak 所带来的<br>overhead是否允许，如果你的场景本来就是一个高负载的已经80%多的CPU使用率了，然后开启<br>kmemleak,是很可能出问题的。</p>
<p>在 公司 一款三核心的 Cortex-A7 的产品中测试结果：<br>        disabled        enabled     Per Core增加%       换算成单核CPU%<br>User:     3.54%          7.63%          4.09%            12.27%<br>Sys:      10.68%         23.76%         13.08%           38.7%<br>Idle:     84.6%          67.68%         17.02%           -50.76%</p>
<p>在我自己 qemu 虚拟机中测试结果是：</p>
<pre><code>    disabled        enabled     Per Core增加%       换算成单核CPU%</code></pre>
<p>User:     3.54%          7.63%                           12.27%<br>Sys:      10.68%         23.76%                          38.7%<br>Idle:     84.6%          67.68%                          -50.76%</p>
<p>参考<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/dev-tools/kmemleak.html">内核文档</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-16T11:00:00.000Z" title="1/16/2021, 7:00:00 PM">2021-01-16</time>发表</span><span class="level-item"><time dateTime="2021-01-31T11:03:31.205Z" title="1/31/2021, 7:03:31 PM">2021-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">4 分钟读完 (大约585个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/16/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/page_owner%20%E5%AE%9A%E4%BD%8D%20buddy%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">page_owner 定位 buddy 内存泄漏</a></h1><div class="content"><h2 id="page-owner-原理"><a href="#page-owner-原理" class="headerlink" title="page_owner 原理"></a>page_owner 原理</h2><p>主要是通过给 每个分配出去的page 记录调用栈</p>
<h2 id="page-owner-使用"><a href="#page-owner-使用" class="headerlink" title="page_owner 使用"></a>page_owner 使用</h2><p>从mm/makefile 看，需要如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if [ $debug_page_owner &#x3D;&#x3D; 1 ]</span><br><span class="line">then</span><br><span class="line">## page_owner detect and panic start</span><br><span class="line">	echo &quot;CONFIG_STACKDEPOT&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">	echo &quot;CONFIG_PAGE_EXTENSION&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">	echo &quot;CONFIG_PAGE_OWNER&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">## page_owner detect and panic end</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>重新编译之后，启动qemu, 需要加上 <code>page_owner=on</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-x86_64 \</span><br><span class="line">	-kernel &#x2F;tmp&#x2F;bzImage \</span><br><span class="line">	-hda &#x2F;home&#x2F;ubuntu&#x2F;myspace&#x2F;qemu_build&#x2F;stable_ubuntu.img \</span><br><span class="line">	-append &quot;root&#x3D;&#x2F;dev&#x2F;sda5 console&#x3D;ttyS0 crashkernel&#x3D;256M page_owner&#x3D;on&quot; \</span><br><span class="line">	-smp 4 \</span><br><span class="line">	-m 2048 \</span><br><span class="line">	--enable-kvm \</span><br><span class="line">	-net nic \</span><br><span class="line">	-net user,hostfwd&#x3D;tcp::2222-:22 \</span><br><span class="line">	--nographic \</span><br><span class="line">	-fsdev local,id&#x3D;fs1,path&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share,security_model&#x3D;none \</span><br><span class="line">	-device virtio-9p-pci,fsdev&#x3D;fs1,mount_tag&#x3D;host_share</span><br></pre></td></tr></table></figure>

<p>查看 <code>/sys/kernel/debug/page_owner</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# cat page_owner | wc -l</span><br><span class="line">4363829</span><br><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug#</span><br></pre></td></tr></table></figure>
<p>记录的信息非常多，然后需要一些工具来帮助检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# cat page_owner &gt; &#x2F;home&#x2F;rlk&#x2F;page_owner.txt</span><br><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# cp &#x2F;tmp&#x2F;share&#x2F;test_modules&#x2F;resource_leak&#x2F;page_alloc_leak&#x2F;page_owner_sort &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">stable_kernel@kernel: ~# page_owner_sort .&#x2F;page_owner.txt sorted_page_owner.txt</span><br><span class="line">loaded 398724</span><br><span class="line">sorting ....</span><br><span class="line">culling</span><br><span class="line">stable_kernel@kernel: ~# cat sorted_page_owner.txt| wc -l</span><br><span class="line">5470295</span><br><span class="line">stable_kernel@kernel: ~# cat page_owner.txt| wc -l</span><br><span class="line">5472954</span><br><span class="line">stable_kernel@kernel: ~#</span><br></pre></td></tr></table></figure>

<p>看一下详细信息，<code>order</code> <code>mask</code>详细信息都有，对于debug 页面内存泄露用处很大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">stable_kernel@kernel: ~# cat page_owner.txt | head -n 80</span><br><span class="line">Page allocated via order 2, mask 0xd20c1(GFP_DMA|__GFP_IO|__GFP_FS|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_NOMEMALLOC), pid 62, ts 121463164s</span><br><span class="line">PFN 1024 type Unmovable Block 2 type Unmovable Flags 0x10200(slab|head)</span><br><span class="line"> prep_new_page+0xcf&#x2F;0xf0</span><br><span class="line"> get_page_from_freelist+0xd8a&#x2F;0x1230</span><br><span class="line"> __alloc_pages_nodemask+0x170&#x2F;0x330</span><br><span class="line"> allocate_slab+0x24f&#x2F;0x2f0</span><br><span class="line"> ___slab_alloc+0x480&#x2F;0x6b0</span><br><span class="line"> __slab_alloc+0x50&#x2F;0x60</span><br><span class="line"> kmem_cache_alloc_trace+0x1fb&#x2F;0x230</span><br><span class="line"> sr_probe+0x213&#x2F;0x5e0</span><br><span class="line"> really_probe+0xd6&#x2F;0x2e0</span><br><span class="line"> driver_probe_device+0x4a&#x2F;0xa0</span><br><span class="line"> bus_for_each_drv+0x7c&#x2F;0xc0</span><br><span class="line"> __device_attach+0xe8&#x2F;0x150</span><br><span class="line"> bus_probe_device+0x9a&#x2F;0xb0</span><br><span class="line"> device_add+0x39b&#x2F;0x850</span><br><span class="line"> scsi_sysfs_add_sdev+0x89&#x2F;0x280</span><br><span class="line"> scsi_probe_and_add_lun+0x81e&#x2F;0xb90</span><br><span class="line"></span><br><span class="line">Page allocated via order 0, mask 0x0(), pid 1, ts 285099088 ns</span><br><span class="line">PFN 4096 type Unmovable Block 8 type Unmovable Flags 0x100000000000000()</span><br><span class="line"> register_early_stack+0x23&#x2F;0x60</span><br><span class="line"> init_page_owner+0x27&#x2F;0x290</span><br><span class="line"> kernel_init_freeable+0x158&#x2F;0x273</span><br><span class="line"> kernel_init+0x5&#x2F;0x101</span><br><span class="line"></span><br><span class="line">Page allocated via order 0, mask 0x0(), pid 1, ts 285099128 ns</span><br><span class="line">PFN 4097 type Unmovable Block 8 type Unmovable Flags 0x100000000000000()</span><br><span class="line"> register_early_stack+0x23&#x2F;0x60</span><br><span class="line"> init_page_owner+0x27&#x2F;0x290</span><br><span class="line"> kernel_init_freeable+0x158&#x2F;0x273</span><br><span class="line"> kernel_init+0x5&#x2F;0x101</span><br></pre></td></tr></table></figure>


<h2 id="page-owner-代码"><a href="#page-owner-代码" class="headerlink" title="page_owner 代码"></a>page_owner 代码</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个工具 运行 overhead较大，在线上可能不能开启，只能在debug时开启。</p>
<p>参考<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/vm/page_owner.html">内核文档</a><br>参考<a target="_blank" rel="noopener" href="https://lwn.net/Articles/121656/">LWN 文章</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T11:00:00.000Z" title="1/15/2021, 7:00:00 PM">2021-01-15</time>发表</span><span class="level-item"><time dateTime="2021-01-21T16:39:25.597Z" title="1/22/2021, 12:39:25 AM">2021-01-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">14 分钟读完 (大约2084个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/15/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F/">进程虚拟地址空间泄漏问题</a></h1><div class="content"><h2 id="虚拟内存泄漏"><a href="#虚拟内存泄漏" class="headerlink" title="虚拟内存泄漏"></a>虚拟内存泄漏</h2><p>一般情况我们说 内存泄漏，都是指的是物理内存泄漏，毕竟物理内存是实实在在的，一个进程泄漏了，那么整个系统中的可用内存就会变少。</p>
<p>但是linux的虚拟内存空间是各个进程之间相互隔离的，在arm64系统中 有 T,在 arm32系统中也有3G<br>多。但是否意味着这种 虚拟内存我们就不需要关心呢？</p>
<h2 id="尝试复现"><a href="#尝试复现" class="headerlink" title="尝试复现"></a>尝试复现</h2><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        char *p &#x3D; NULL;</span><br><span class="line">        for (i &#x3D; 0; i &lt; 1024 * 1024 * 64; i++) &#123;</span><br><span class="line">                p &#x3D; malloc(1024 * 1024);</span><br><span class="line">                if (!p) &#123;printf(&quot;malloc failed,p &#x3D; %p, i &#x3D; %d\n&quot;, p, i); break;&#125;</span><br><span class="line">                else    &#123;printf(&quot;malloc sucess.p &#x3D; %p, i &#x3D; %d\n&quot;, p, i);&#125;</span><br><span class="line">                usleep(1000 * 10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;malloc failed,just wait!!\n&quot;);</span><br><span class="line">        while(1) &#123;</span><br><span class="line">                usleep(1000 * 10);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次尝试需分配 1G的虚拟内存，但是不会去使用，也就是不会去申请物理内存</p>
<h2 id="x86-64-平台"><a href="#x86-64-平台" class="headerlink" title="x86_64 平台"></a>x86_64 平台</h2><p>我一开始尝试在腾讯云 服务器上复现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@130ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;process_virtual_address_memleak# .&#x2F;a.out</span><br><span class="line">malloc sucess. p &#x3D; 0x7f8e3f5c6010, i &#x3D; 0</span><br><span class="line">malloc sucess. p &#x3D; 0x7f8e3f4c5010, i &#x3D; 1</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0x56771e4ba6e0, i &#x3D; 461827</span><br><span class="line">malloc sucess. p &#x3D; 0x56771e5ba6f0, i &#x3D; 461828</span><br><span class="line">[1]    2721866 killed     .&#x2F;a.out</span><br></pre></td></tr></table></figure>

<p>直到最后分配到 <code>461828 MB</code> 内存的时候，<code>a.out</code> 被OOM kill了。</p>
<p>到底是为啥呢？？？毕竟我也没有去往 <code>malloc</code> 的虚拟地址中写数据，也不应该会分配物理页面。<br>从 <code>top</code> 命令看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">top - 15:47:46 up 3 days, 15:06,  2 users,  load average: 0.24, 0.16, 0.10</span><br><span class="line">Tasks: 157 total,   1 running, 156 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  3.3 us,  3.6 sy,  0.0 ni, 92.7 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :   1987.9 total,     70.5 free,   1660.6 used,    256.8 buff&#x2F;cache</span><br><span class="line">MiB Swap:   2048.0 total,   1499.9 free,    548.1 used.    162.0 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">2783846 ubuntu    20   0  173.4g 683692   1380 S   0.3  33.6   0:06.86 a.out</span><br><span class="line">   1378 jenkins   20   0 2510448 176168   2924 S   0.7   8.7   7:05.12 java</span><br><span class="line">2779920 ubuntu    20   0  925684 107776  15196 S   1.0   5.3   0:21.10 node</span><br><span class="line">2703822 ubuntu    20   0 1611828  41268  11624 S   0.3   2.0   0:24.40 node</span><br><span class="line">2773158 ubuntu    20   0  702408  39436  12496 S   0.7   1.9   0:15.87</span><br></pre></td></tr></table></figure>

<p>已经分配了 <code>173G</code> 虚拟内存，但是同时可以发现 驻留在物理内存中的页面也达到了 <code>683692kb</code>.<br>这到底是什么？</p>
<p>通过对比 运行 <code>mytest</code> 前后的 <code>/proc/meminfo</code> 文件，发现差异主要在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">系统正常</span><br><span class="line">Active(anon):     243372 kB</span><br><span class="line">Inactive(anon):   267836 kB</span><br><span class="line"></span><br><span class="line">mytest运行之后</span><br><span class="line">Active(anon):     550888 kB</span><br><span class="line">Inactive(anon):   576840 kB</span><br></pre></td></tr></table></figure>
<p>说明确实是 mytest 消耗了大量的内存 用作匿名页面<br>接下来就需要查看具体是哪种页面消耗了物理内存了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;2798128# cat smaps | grep heap -A 40</span><br><span class="line">7fbca3ff9000-7fc69e600000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">Size:           41850908 kB</span><br><span class="line">KernelPageSize:        4 kB</span><br><span class="line">MMUPageSize:           4 kB</span><br><span class="line">Rss:              162844 kB</span><br><span class="line">Pss:              162844 kB</span><br><span class="line">Shared_Clean:          0 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:         0 kB</span><br><span class="line">Private_Dirty:    162844 kB</span><br><span class="line">Referenced:       162844 kB</span><br><span class="line">Anonymous:        162844 kB</span><br><span class="line">LazyFree:              0 kB</span><br><span class="line"></span><br><span class="line">此时top 输出</span><br><span class="line">top - 16:05:47 up 3 days, 15:24,  4 users,  load average: 0.14, 0.09, 0.10</span><br><span class="line">Tasks: 157 total,   1 running, 156 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  3.0 us,  2.7 sy,  0.0 ni, 94.0 id,  0.0 wa,  0.0 hi,  0.3 si,  0.0 st</span><br><span class="line">MiB Mem :   1987.9 total,    786.6 free,    917.0 used,    284.2 buff&#x2F;cache</span><br><span class="line">MiB Swap:   2048.0 total,   1512.2 free,    535.8 used.    912.0 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">2798128 ubuntu    20   0   45.1g 185412   1408 S   0.7   9.1   0:01.66 a.out</span><br><span class="line">......</span><br><span class="line">等待3min</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;2798128# cat smaps | grep heap -A 40</span><br><span class="line">7fb68e600000-7fc69e600000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">Size:           67371008 kB</span><br><span class="line">KernelPageSize:        4 kB</span><br><span class="line">MMUPageSize:           4 kB</span><br><span class="line">Rss:              262144 kB</span><br><span class="line">Pss:              262144 kB</span><br><span class="line">Shared_Clean:          0 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:         0 kB</span><br><span class="line">Private_Dirty:    262144 kB</span><br><span class="line">Referenced:       262144 kB</span><br><span class="line">Anonymous:        262144 kB</span><br><span class="line">LazyFree:              0 kB</span><br><span class="line">AnonHugePages:         0 kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此时top 输出</span><br><span class="line">top - 16:09:43 up 3 days, 15:27,  4 users,  load average: 0.24, 0.12, 0.10</span><br><span class="line">Tasks: 159 total,   1 running, 158 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.7 us,  3.4 sy,  0.0 ni, 90.3 id,  3.7 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :   1987.9 total,    585.4 free,   1072.9 used,    329.5 buff&#x2F;cache</span><br><span class="line">MiB Swap:   2048.0 total,   1523.9 free,    524.1 used.    754.9 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">2798128 ubuntu    20   0   67.9g 278604   1408 S   0.3  13.7   0:02.55 a.out</span><br></pre></td></tr></table></figure>

<p>可以看到虽然 没有往堆内存中写入数据，但是还是消耗了较多的物理内存？这是怎么回事？</p>
<ol>
<li><p>猜想一， 可能是一直连续分配虚拟内存，导致 <code>vma</code> 使用很多？<br>通过查看 /proc/slabinfo 和 /proc/pid/maps 看堆内存就一块，基本没有分块的，kernel中也有<br><code>vma_merge</code> 的操作，所以应该不是vma 占用的内存</p>
</li>
<li><p>??？<br>我还没有其他头绪，为什么会占用物理内存</p>
</li>
</ol>
<h2 id="arm32-平台"><a href="#arm32-平台" class="headerlink" title="arm32 平台"></a>arm32 平台</h2><p>然后想了想，x86_64平台可能是虚拟内存太大，复现时间成本有点高<br>就使用了公司的板子，重新编译了一遍，在一个 <code>arm32</code> 板子上运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">root@device_gls:&#x2F; # mytest</span><br><span class="line">malloc sucess. p &#x3D; 0xb6b00000, i &#x3D; 0</span><br><span class="line">malloc sucess. p &#x3D; 0xb6a00000, i &#x3D; 1</span><br><span class="line">malloc sucess. p &#x3D; 0xb6900000, i &#x3D; 2</span><br><span class="line">malloc sucess. p &#x3D; 0xb6800000, i &#x3D; 3</span><br><span class="line">malloc sucess. p &#x3D; 0xb6700000, i &#x3D; 4</span><br><span class="line">malloc sucess. p &#x3D; 0xb6600000, i &#x3D; 5</span><br><span class="line">malloc sucess. p &#x3D; 0xb6500000, i &#x3D; 6</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0x10380000, i &#x3D; 2663</span><br><span class="line">malloc sucess. p &#x3D; 0x10280000, i &#x3D; 2664</span><br><span class="line">malloc sucess. p &#x3D; 0x10180000, i &#x3D; 2665</span><br><span class="line">malloc sucess. p &#x3D; 0x10080000, i &#x3D; 2666</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0xff80000, i &#x3D; 2667</span><br><span class="line">malloc sucess. p &#x3D; 0xfe80000, i &#x3D; 2668</span><br><span class="line">malloc sucess. p &#x3D; 0xfd80000, i &#x3D; 2669</span><br><span class="line">malloc sucess. p &#x3D; 0xfc80000, i &#x3D; 2670</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0x4180000, i &#x3D; 2857</span><br><span class="line">malloc sucess. p &#x3D; 0x4080000, i &#x3D; 2858</span><br><span class="line">malloc sucess. p &#x3D; 0x3f80000, i &#x3D; 2859</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0x1080000, i &#x3D; 2906</span><br><span class="line">malloc sucess. p &#x3D; 0xf80000, i &#x3D; 2907</span><br><span class="line">malloc sucess. p &#x3D; 0xe80000, i &#x3D; 2908</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0x80000, i &#x3D; 2922</span><br><span class="line">malloc sucess. p &#x3D; 0xb6f80000, i &#x3D; 2923</span><br><span class="line">malloc sucess. p &#x3D; 0xb7080000, i &#x3D; 2924</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0xbe880000, i &#x3D; 3044</span><br><span class="line">malloc sucess. p &#x3D; 0xbe980000, i &#x3D; 3045</span><br><span class="line">malloc sucess. p &#x3D; 0xbea80000, i &#x3D; 3046</span><br><span class="line">malloc sucess. p &#x3D; 0xbed80000, i &#x3D; 3047</span><br><span class="line">malloc failed, p &#x3D; 0x0, i &#x3D; 3048</span><br><span class="line">malloc failed,just wait!!</span><br></pre></td></tr></table></figure>


<p>可以看到，<code>arm32</code> 平台在分配了 <code>3038MB</code> 虚拟内存之后，在分配第3039块1MB的内存时，由于虚拟地<br>址空间用完了，不能再继续分配虚拟内存？</p>
<p>可以看到此时 <code>mytest</code> 进程的地址空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">root@device_gls:&#x2F;proc&#x2F;1293 # cat maps</span><br><span class="line">00080000-7f580000 rw-p 00000000 00:00 0          [anon:libc_malloc]</span><br><span class="line">7f5cd000-7f5d0000 r-xp 00000000 103:0f 1523      &#x2F;system&#x2F;bin&#x2F;mytest</span><br><span class="line">7f5d0000-7f5d1000 r--p 00002000 103:0f 1523      &#x2F;system&#x2F;bin&#x2F;mytest</span><br><span class="line">7f5d1000-7f5d2000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">7f600000-b6d00000 rw-p 00000000 00:00 0          [anon:libc_malloc]</span><br><span class="line">b6d64000-b6d68000 r-xp 00000000 103:0f 1428      &#x2F;system&#x2F;lib&#x2F;libnetd_client.so</span><br><span class="line">b6d68000-b6d69000 r--p 00003000 103:0f 1428      &#x2F;system&#x2F;lib&#x2F;libnetd_client.so</span><br><span class="line">b6d69000-b6d6a000 rw-p 00004000 103:0f 1428      &#x2F;system&#x2F;lib&#x2F;libnetd_client.so</span><br><span class="line">b6d6a000-b6d8a000 r--s 00000000 00:0f 11859      &#x2F;dev&#x2F;__properties__</span><br><span class="line">b6d8a000-b6d8b000 rw-p 00000000 00:00 0          [anon:linker_alloc_vector]</span><br><span class="line">b6d8c000-b6d8d000 rw-p 00000000 00:00 0          [anon:linker_alloc_vector]</span><br><span class="line">b6d8d000-b6dac000 r-xp 00000000 103:0f 1421      &#x2F;system&#x2F;lib&#x2F;libm.so</span><br><span class="line">b6dac000-b6dad000 ---p 00000000 00:00 0</span><br><span class="line">b6dad000-b6dae000 r--p 0001f000 103:0f 1421      &#x2F;system&#x2F;lib&#x2F;libm.so</span><br><span class="line">b6dae000-b6daf000 rw-p 00020000 103:0f 1421      &#x2F;system&#x2F;lib&#x2F;libm.so</span><br><span class="line">b6daf000-b6e23000 r-xp 00000000 103:0f 1355      &#x2F;system&#x2F;lib&#x2F;libc.so</span><br><span class="line">b6e23000-b6e27000 r--p 00073000 103:0f 1355      &#x2F;system&#x2F;lib&#x2F;libc.so</span><br><span class="line">b6e27000-b6e2a000 rw-p 00077000 103:0f 1355      &#x2F;system&#x2F;lib&#x2F;libc.so</span><br><span class="line">b6e2a000-b6e34000 rw-p 00000000 00:00 0</span><br><span class="line">b6e34000-b6ebc000 r-xp 00000000 103:0f 1354      &#x2F;system&#x2F;lib&#x2F;libc++.so</span><br><span class="line">b6ebc000-b6ebd000 ---p 00000000 00:00 0</span><br><span class="line">b6ebd000-b6ec1000 r--p 00088000 103:0f 1354      &#x2F;system&#x2F;lib&#x2F;libc++.so</span><br><span class="line">b6ec1000-b6ec2000 rw-p 0008c000 103:0f 1354      &#x2F;system&#x2F;lib&#x2F;libc++.so</span><br><span class="line">b6ec2000-b6ec3000 rw-p 00000000 00:00 0</span><br><span class="line">b6ec3000-b6ec4000 r--p 00000000 00:00 0</span><br><span class="line">b6ec4000-b6ec5000 r--p 00000000 00:00 0          [anon:linker_alloc]</span><br><span class="line">b6ec5000-b6ec6000 rw-p 00000000 00:00 0          [anon:linker_alloc]</span><br><span class="line">b6ec6000-b6ec7000 rw-p 00000000 00:00 0          [anon:linker_alloc_vector]</span><br><span class="line">b6ec7000-b6ec8000 rw-p 00000000 00:00 0          [anon:linker_alloc_32]</span><br><span class="line">b6ec8000-b6ec9000 r--p 00000000 00:00 0          [anon:linker_alloc]</span><br><span class="line">b6ec9000-b6ee9000 r--s 00000000 00:0f 11859      &#x2F;dev&#x2F;__properties__</span><br><span class="line">b6ee9000-b6eea000 r--p 00000000 00:00 0</span><br><span class="line">b6eea000-b6eeb000 ---p 00000000 00:00 0</span><br><span class="line">b6eeb000-b6eed000 rw-p 00000000 00:00 0          [anon:thread signal stack]</span><br><span class="line">b6eed000-b6f0a000 r-xp 00000000 103:0f 170       &#x2F;system&#x2F;bin&#x2F;linker</span><br><span class="line">b6f0a000-b6f0b000 r--p 0001c000 103:0f 170       &#x2F;system&#x2F;bin&#x2F;linker</span><br><span class="line">b6f0b000-b6f0d000 rw-p 0001d000 103:0f 170       &#x2F;system&#x2F;bin&#x2F;linker</span><br><span class="line">b6f0d000-b6f0f000 rw-p 00000000 00:00 0</span><br><span class="line">b6f80000-beb80000 rw-p 00000000 00:00 0          [anon:libc_malloc]</span><br><span class="line">bed01000-bed22000 rw-p 00000000 00:00 0          [stack]</span><br><span class="line">bed80000-bee80000 rw-p 00000000 00:00 0          [anon:libc_malloc]</span><br><span class="line">bef66000-bef67000 r-xp 00000000 00:00 0          [sigpage]</span><br><span class="line">bef67000-bef68000 r--p 00000000 00:00 0          [vvar]</span><br><span class="line">bef68000-bef69000 r-xp 00000000 00:00 0          [vdso]</span><br><span class="line">ffff0000-ffff1000 r-xp 00000000 00:00 0          [vectors]</span><br><span class="line">root@device_gls:&#x2F;proc&#x2F;1293 #</span><br></pre></td></tr></table></figure>


<p>我们看 <code>libc_malloc</code> 区域的 的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00080000-7f580000 rw-p 00000000 00:00 0          [anon:libc_malloc]  &#x3D;&#x3D; 2037MB</span><br><span class="line">7f600000-b6d00000 rw-p 00000000 00:00 0          [anon:libc_malloc]  &#x3D;&#x3D; 887MB</span><br><span class="line">b6f80000-beb80000 rw-p 00000000 00:00 0          [anon:libc_malloc]  &#x3D;&#x3D; 124MB</span><br><span class="line">bed80000-bee80000 rw-p 00000000 00:00 0          [anon:libc_malloc]  &#x3D;&#x3D; 1MB</span><br></pre></td></tr></table></figure>
<p>总和是 <code>2037 + 887 + 124 + 1 = 3049MB</code></p>
<p>这是项目中一个实际的bug，场景是 直播盒子 做长跑测试的时候，每到7天左右，直播业务就会因<br>为malloc失败而导致失败，但是由于业务代码写的问题，没有检查 malloc返回值的原因，导致业<br>务应用会crash, 现象是空指针错误。。很难联想到是因为进程虚拟地址空间全部泄漏导致的问题。<br>业务的小伙伴差了一个多月都没有头绪。。</p>
<p>在 <code>arm32</code> 设备上，<br>User 14 + Nice 0 + Sys 49 + Idle 246 + IOW 1 + IRQ 0 + SIRQ 0 = 310</p>
<p>  PID PR CPU% S  #THR     VSS     RSS PCY UID      Name<br> 3592  0   0% S     1 3124044K   1688K  fg root     mytest</p>
<p>RSS 也占用了一些，但是远没 X86设备上夸张</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@ubuntu: ~&#x2F;workspace# cat &#x2F;tmp&#x2F;123 | grep Rss</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                  12 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                 256 kB</span><br><span class="line">Rss:                  16 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                  28 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                  64 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                 460 kB</span><br><span class="line">Rss:                  16 kB</span><br><span class="line">Rss:                  12 kB</span><br><span class="line">Rss:                  28 kB</span><br><span class="line">Rss:                 536 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                  16 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                  28 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                 116 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   8 kB</span><br><span class="line">Rss:                   8 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                   8 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   0 kB</span><br></pre></td></tr></table></figure>
<p>其中 malloc 的 rss 只占用 <code>256Kb</code>,大部分是 libc, libc++ libm的代码段占用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">7f680000-b6d80000 rw-p 00000000 00:00 0          [anon:libc_malloc]</span><br><span class="line">Name:           [anon:libc_malloc]</span><br><span class="line">Size:             908288 kB</span><br><span class="line">Rss:                 256 kB</span><br><span class="line">Pss:                 256 kB</span><br><span class="line">Shared_Clean:          0 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:         0 kB</span><br><span class="line">Private_Dirty:       256 kB</span><br><span class="line">Referenced:          256 kB</span><br><span class="line">Anonymous:           256 kB</span><br></pre></td></tr></table></figure>

<p>由此可见</p>
<ol>
<li><p>进程虚拟地址空间泄漏还是有可能会存在的，尽管可能概率非常低，对系统危害也比物理内存泄漏小很<br>多。但是一旦发生，他的危害对于业务本身也是致命的，必须重启业务或者系统来恢复。</p>
</li>
<li><p>编程习惯养好，一定需要检查函数返回值。</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T11:00:00.000Z" title="1/15/2021, 7:00:00 PM">2021-01-15</time>发表</span><span class="level-item"><time dateTime="2021-01-18T06:07:42.051Z" title="1/18/2021, 2:07:42 PM">2021-01-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">7 分钟读完 (大约992个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/15/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/">文件资源泄漏问题</a></h1><div class="content"><h2 id="资源泄漏"><a href="#资源泄漏" class="headerlink" title="资源泄漏"></a>资源泄漏</h2><p>资源泄漏在实际编程中是一不小心就会遇到的一个问题，最常见的就是 <code>内存泄漏</code>。<br>内存泄漏：对于短时间存在的进程，线程即使存在内存泄漏，往往也不会变现出来，开发人员也很难感知到。<br>但是一旦是长时间运行的进程，线程存在内存泄漏的问题，那将是一个灾难，要么过一会被OOM KILL，要么<br>自己重启，更严重的就是重启机器。</p>
<p>内存泄漏是指内存被分配出来，但是后续一直未使用，且失去了这个内存的引用，一直无法释放的问题。</p>
<p>但是除了最常见内存泄漏之外，还有其他各种资源泄漏的问题，比如这次的 <code>进程文件资源泄漏</code>。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>虽然是嵌入式平台，也有一些业务需要做压力测试连续几天到一个月不关机长时间跑测试。</p>
<p>某个业务在运行两天之后就会出现进程挂掉的问题。</p>
<h2 id="代码复现"><a href="#代码复现" class="headerlink" title="代码复现"></a>代码复现</h2><p>如果能用简单代码复现的问题，都不大</p>
<p><a target="_blank" rel="noopener" href="https://github.com/liulangrenaaa/test_modules/tree/main">代码</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#define DIR_NAME        &quot;&#x2F;tmp&#x2F;asdf&quot;</span><br><span class="line"></span><br><span class="line">int sync_dir(char *dir)</span><br><span class="line">&#123;</span><br><span class="line">        if(!dir) return -1;</span><br><span class="line">        int fd &#x3D; open(dir, O_ASYNC);</span><br><span class="line">        if (-1 &#x3D;&#x3D; fd) return -1;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int ret &#x3D; -1;</span><br><span class="line">        for (i &#x3D; 0; i &lt; 1024 * 1024 * 64; i++) &#123;</span><br><span class="line">                ret &#x3D; sync_dir(DIR_NAME);</span><br><span class="line">                if (ret)        printf(&quot;sync_dir failed. i &#x3D; %d, ret &#x3D; %d\n&quot;, i, ret);</span><br><span class="line">                else            printf(&quot;sync_dir sucess. i &#x3D; %d\n&quot;, i);</span><br><span class="line">                usleep(1000 * 10);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>嵌入式设备上的资源限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@device_gls:&#x2F;proc&#x2F;sys&#x2F;fs # cat file-nr</span><br><span class="line">800     0       21378</span><br><span class="line">root@device_gls:&#x2F;proc&#x2F;sys&#x2F;fs #</span><br></pre></td></tr></table></figure>
<p>意思是当前系统允许打开 <code>21378</code> 个文件，已经打开了 <code>800</code>个文件了</p>
<p>我选择用 <code>ubuntu</code> 系统去复现，先将 系统 fd上限制调制与设备一样的水平</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-max</span><br><span class="line">9223372036854775807</span><br><span class="line">tencent_clould@1ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# sudo su</span><br><span class="line">VM-0-11-ubuntu# echo 21378 &gt; file-max</span><br><span class="line">VM-0-11-ubuntu# exit</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-max</span><br><span class="line">21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs#</span><br></pre></td></tr></table></figure>

<p>尝试复现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@130ubuntu: ~&#x2F;workspace&#x2F;hexo_blog&#x2F;source&#x2F;_posts&#x2F;资源管理# .&#x2F;a.out</span><br><span class="line">sync_dir sucess. i &#x3D; 0</span><br><span class="line">sync_dir sucess. i &#x3D; 1</span><br><span class="line">....</span><br><span class="line">sync_dir sucess. i &#x3D; 5</span><br><span class="line">sync_dir sucess. i &#x3D; 18194</span><br><span class="line">sync_dir sucess. i &#x3D; 18195</span><br><span class="line">...</span><br><span class="line">sync_dir failed. i &#x3D; 18196, ret &#x3D; -1</span><br></pre></td></tr></table></figure>


<p>同时观察 <code> /proc/sys/fs/file-nr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">4704    0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">9824    0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">17760   0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">20224   0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">21024   0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">21216   0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">zsh: pipe failed: too many open files in system</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">zsh: pipe failed: too many open files in system</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>a.out</code> 最后无法 通过 <code>open</code> 打开文件了，且同时 <code>zsh</code> shell 都无法打开<br><code>file-nr</code>了。</p>
<p>与此同时，看到 <code>dmesg</code> 的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[57615.006011] VFS: file-max limit 21378 reached</span><br><span class="line">[57616.671617] VFS: file-max limit 21378 reached</span><br></pre></td></tr></table></figure>
<p>也可以比较容易定位出来。</p>
<p>这个问题困扰了当时开发同事很久，最后发现原来是 系统 <code>fd</code> 资源全部泄漏殆尽导致的。</p>
<h2 id="其他限制资源使用的方式"><a href="#其他限制资源使用的方式" class="headerlink" title="其他限制资源使用的方式"></a>其他限制资源使用的方式</h2><ol>
<li>其实还有其他方式限制资源 如 <code>ulimit</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# ulimit -a</span><br><span class="line">-t: cpu time (seconds)              unlimited</span><br><span class="line">-f: file size (blocks)              unlimited</span><br><span class="line">-d: data seg size (kbytes)          unlimited</span><br><span class="line">-s: stack size (kbytes)             8192</span><br><span class="line">-c: core file size (blocks)         0</span><br><span class="line">-m: resident set size (kbytes)      unlimited</span><br><span class="line">-u: processes                       7582</span><br><span class="line">-n: file descriptors                1024</span><br><span class="line">-l: locked-in-memory size (kbytes)  65536</span><br><span class="line">-v: address space (kbytes)          unlimited</span><br><span class="line">-x: file locks                      unlimited</span><br><span class="line">-i: pending signals                 7582</span><br><span class="line">-q: bytes in POSIX msg queues       819200</span><br><span class="line">-e: max nice                        0</span><br><span class="line">-r: max rt priority                 0</span><br><span class="line">-N 15:                              unlimited</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs#</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>/proc/pid/limits<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat &#x2F;proc&#x2F;4833&#x2F;limits</span><br><span class="line">Limit                     Soft Limit           Hard Limit           Units</span><br><span class="line">Max cpu time              unlimited            unlimited            seconds</span><br><span class="line">Max file size             unlimited            unlimited            bytes</span><br><span class="line">Max data size             unlimited            unlimited            bytes</span><br><span class="line">Max stack size            8388608              unlimited            bytes</span><br><span class="line">Max core file size        0                    unlimited            bytes</span><br><span class="line">Max resident set          unlimited            unlimited            bytes</span><br><span class="line">Max processes             7582                 7582                 processes</span><br><span class="line">Max open files            1024                 1048576              files</span><br><span class="line">Max locked memory         67108864             67108864             bytes</span><br><span class="line">Max address space         unlimited            unlimited            bytes</span><br><span class="line">Max file locks            unlimited            unlimited            locks</span><br><span class="line">Max pending signals       7582                 7582                 signals</span><br><span class="line">Max msgqueue size         819200               819200               bytes</span><br><span class="line">Max nice priority         0                    0</span><br><span class="line">Max realtime priority     0                    0</span><br><span class="line">Max realtime timeout      unlimited            unlimited            us</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs#</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><code>/etc/security/limits.conf</code></li>
</ol>
<p>这里可以预先配置。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-09T02:00:40.000Z" title="1/9/2021, 10:00:40 AM">2021-01-09</time>发表</span><span class="level-item"><time dateTime="2021-01-14T16:53:25.527Z" title="1/15/2021, 12:53:25 AM">2021-01-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">31 分钟读完 (大约4592个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/09/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/systemTap/How%20to%20Use%20system%20Tap/">How to Use system Tap</a></h1><div class="content"><p>SystemTap允许使用者监控Linux系统当前的运行情况，以便进一步分析。这将有助于运维或开发人员缉查bug或性能问题的罪魁祸首。<br>SystemTap提供了一门领域特定语言，使得用户可以编写自定义脚本，调查和监控各种内核函数、系统调用，<br>和其它发生在内核空间的事件。</p>
<p>就此而言，SystemTap不仅仅是个工具，它是一个让你能够自定义内核取证和监控工具的生态系统。</p>
<p>当前版本的SystemTap提供的探测内核空间事件的众多选项，可以在不同版本的内核下使用。<br>然而，SystemTap对探测用户空间事件的支持依赖于内核的支持（需要uprobe机制），而多数内核缺乏这一支持。<br>结果是，仅有部分内核上的SystemTap版本支持用户空间探测。</p>
<h2 id="安装SystemTap"><a href="#安装SystemTap" class="headerlink" title="安装SystemTap"></a>安装SystemTap</h2><p>安装 systemtap 软件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@ubuntu: &#x2F;var&#x2F;crash# sudo apt install systemtap</span><br><span class="line">Inspiron-5548@ubuntu: &#x2F;var&#x2F;crash# sudo apt install systemtap-runtime</span><br></pre></td></tr></table></figure>

<p>安装 kernel debug info</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@ubuntu: &#x2F;var&#x2F;crash# sudo apt install systemtap</span><br><span class="line">Inspiron-5548@ubuntu: &#x2F;var&#x2F;crash# sudo apt install systemtap-runtime</span><br></pre></td></tr></table></figure>
<h2 id="SystemTap-可以用来干什么"><a href="#SystemTap-可以用来干什么" class="headerlink" title="SystemTap 可以用来干什么"></a>SystemTap 可以用来干什么</h2><p>SystemTap允许用户仅需编写和重用简单的脚本即可获取Linux繁多的运行数据。通过SystemTap脚本，<br>你可以又好又快地提取数据、过滤数据、汇总数据。诊断复杂的性能问题（或功能问题）再也不是难事。<br>整个SystemTap脚本所做的，无非就是声明感兴趣的事件，然后添加对应的处理程序。当SystemTap脚本运行时，SystemTap会监控声明的事件；<br>一旦事件发生，Linux内核会临时切换到对应的处理程序，完成后再重拾原先的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可供监控的事件种类繁多：进入&#x2F;退出某个函数，定时器到期，会话终止，等等。处理程序由一组SystemTap语句构成，指明事件发生后要做的工作。</span><br><span class="line">其中包括从事件上下文中提取数据，存储到内部变量中，输出结果。</span><br></pre></td></tr></table></figure>

<h2 id="SystemTap-使用"><a href="#SystemTap-使用" class="headerlink" title="SystemTap 使用"></a>SystemTap 使用</h2><h3 id="最简单的一行代码"><a href="#最简单的一行代码" class="headerlink" title="最简单的一行代码"></a>最简单的一行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@127ubuntu: ~&#x2F;workspace# echo &quot;probe timer.s(1) &#123;exit()&#125;&quot; | sudo stap -v -</span><br><span class="line"></span><br><span class="line">Pass 1: parsed user script and 476 library scripts using 108312virt&#x2F;90968res&#x2F;7440shr&#x2F;83392data kb, in 260usr&#x2F;30sys&#x2F;315real ms.</span><br><span class="line">Pass 2: analyzed script: 1 probe, 1 function, 0 embeds, 0 globals using 109896virt&#x2F;92776res&#x2F;7688shr&#x2F;84976data kb, in 10usr&#x2F;0sys&#x2F;9real ms.</span><br><span class="line">Pass 3: translated to C into &quot;&#x2F;tmp&#x2F;stappbkhvF&#x2F;stap_629b1ee8abda600005ad17f270124c66_947_src.c&quot; using 110032virt&#x2F;92776res&#x2F;7688shr&#x2F;85112data kb, in 0usr&#x2F;0sys&#x2F;1real ms.</span><br><span class="line">Pass 4: compiled C into &quot;stap_629b1ee8abda600005ad17f270124c66_947.ko&quot; in 15530usr&#x2F;2160sys&#x2F;17963real ms.</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">Pass 5: run completed in 20usr&#x2F;30sys&#x2F;1459real ms.</span><br><span class="line">Inspiron-5548@ubuntu: ~&#x2F;workspace#</span><br></pre></td></tr></table></figure>
<p>可以看出 SystemTap 脚本运行需要结果5个步骤，在加载 SystemTap脚本过程(生成ko)的时候，SystemTap 耗时较多，尤其是CPU资源。</p>
<p>SystemTap脚本运行时，会启动一个对应的SystemTap会话。整个会话大致流程如下：</p>
<p>首先，SystemTap会检查脚本中用到的tapset，确保它们都存在于tapset库中（通常是/usr/share/systemtap/tapset/）。然后SystemTap会把找到的tapset替换成在tapset库中对应的定义。<br>tapset是tap（听诊器）的集合，指一些预定义的SystemTap事件或函数。<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/tapsets/">完整的tapset列表</a></p>
<p>SystemTap接着会把脚本转化成C代码，运行系统的C编译器编译出一个内核模块。完成这一步的工具包含在systemtap包中<br>SystemTap随即加载该模块，并启用脚本中所有的探针（包括事件和对应的处理程序）。这一步由system-runtime包的staprun完成。<br>每当被监控的事件发生，对应的处理程序就会被执行。<br>一旦SystemTap会话终止，探针会被禁用，内核模块也会被卸载。<br>这一串流程皆始于一个简单的命令行程序：stap。这个程序包揽了SystemTap主要的功能。</p>
<h3 id="脚本如何编写"><a href="#脚本如何编写" class="headerlink" title="脚本如何编写"></a>脚本如何编写</h3><p>在大多数情况下，SystemTap脚本是每个SystemTap会话的基石。SystemTap脚本决定了需要收集的信息类型，也决定了对收集到的信息的处理方式。<br>SystemTap脚本由两部分组成：事件和处理程序。<br>一旦SystemTap会话准备就绪，SystemTap会监控操作系统中特定的事件，并在事件发生的时候触发对应的处理程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个事件和它对应的处理程序合称探针。一个SystemTap脚本可以有多个探针。 一个探针的处理程序部分通常称之为探针主体（probe body）</span><br></pre></td></tr></table></figure>

<p>与应用开发的方式类比，使用事件和处理程序就像在程序的特定位置插入打日志的语句。每当程序运行时，这些日志会帮助你查看程序执行的流程。<br>但是SystemTasp脚本允许你在无需重新编译代码，即可插入检测指令，而且处理程序也不限于单纯地打印数据。<br>事件会触发对应的处理程序；对应的处理程序记录下感兴趣的数据，并以你指定的格式输出。</p>
<p>SystemTap脚本的后缀是.stp，并以这样的语句表示一个探针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">probe   event &#123;statements&#125;</span><br></pre></td></tr></table></figure>

<p>SystemTap支持给一个探针指定多个事件；每个事件以逗号隔开。<br>如果给某一个探针指定了多个事件，只要其中一个事件发生，SystemTap就会执行对应的处理程序。<br>每个探针有自己对应的语句块。语句块由花括号 {} 括住，包含事件发生时需要执行的所有语句。<br>SystemTap会顺序执行这些语句；语句间通常不需要特殊的分隔符或终止符。</p>
<p>SystemTap还允许你编写函数来提取探针间公共的逻辑。<br>所以，与其在多个探针间复制粘贴重复的语句，你不如把它们放入函数中，就像函数调用一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function function_name(arguments) &#123;statements&#125;</span><br><span class="line"></span><br><span class="line">probe event &#123;function_name(arguments)&#125;</span><br></pre></td></tr></table></figure>
<p>当探针被触发时，function_name中的语句会被执行。arguments是传递给函数的可选的入参。</p>
<h3 id="SystemTap-事件"><a href="#SystemTap-事件" class="headerlink" title="SystemTap 事件"></a>SystemTap 事件</h3><p>我们还需要了解SystemTap 事件，这里主要分为 <code>同步事件</code> 和 <code>异步事件</code>。</p>
<h4 id="同步事件"><a href="#同步事件" class="headerlink" title="同步事件"></a>同步事件</h4><p>同步事件会在任意进程执行到内核特定位置时触发。你可以用它来作为其它事件的参照点，毕竟同步事件有着清晰的上下文信息。<br>包括：</p>
<p><code>syscall.system_call</code></p>
<p>进入名为system_call的系统调用。如果想要监控的是退出某个系统调用的事件，在后面添加.return。举个例子，要想监控进入和退出系统调用close的事件，应该使用syscall.close和syscall.close.return。</p>
<p><code>vfs.file_operation</code></p>
<p>进入虚拟文件系统（VFS）名为file_operation的文件操作。跟系统调用事件一样，在后面添加.return可以监控对应的退出事件。 译注：file_operation取值的范畴，取决于当前内核中struct file_operations的定义的操作.</p>
<p><code>kernel.function(&quot;function&quot;)</code></p>
<p>进入名为function的内核函数。举个例子，kernel.function(“sys_open”)即内核函数sys_open被调用时所触发的事件。同样，kernel.function(“sys_open”).return会在sys_open函数调用返回时被触发。</p>
<p>在定义探测事件时，可以使用像*这样的通配符。你也可以用内核源码文件名限定要跟踪的函数。看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">probe kernel.function(&quot;*@net&#x2F;socket.c&quot;) &#123; &#125;</span><br><span class="line">probe kernel.function(&quot;*@net&#x2F;socket.c&quot;).return &#123; &#125;</span><br></pre></td></tr></table></figure>


<p><code>kernel.trace(&quot;tracepoint&quot;)</code><br>到达名为tracepoint的静态内核探测点（tracepoint）。较新的内核（&gt;= 2.6.30）包含了特定事件的检测代码。这些事件一般会被标记成静态内核探测点。一个例子是，kernel.trace(“kfree_skb”)表示内核释放了一个网络缓冲区的事件。（译注：想知道当前内核设置了哪些静态内核探测点吗？你需要运行sudo perf list。）</p>
<p><code>module(&quot;module&quot;).function(&quot;function&quot;)</code></p>
<p>进入指定模块module的函数function。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">probe module(&quot;ext3&quot;).function(&quot;*&quot;) &#123; &#125;</span><br><span class="line">probe module(&quot;ext3&quot;).function(&quot;*&quot;).return &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h4><p>异步事件跟特定的指令或代码的位置无关。 这部分事件主要包含计数器、定时器和其它类似的东西。</p>
<p><code>begin</code></p>
<p>SystemTap会话的启动事件，会在脚本开始时触发。</p>
<p><code>end</code></p>
<p>SystemTap会话的结束事件，会在脚本结束时触发。</p>
<p><code>timer events</code></p>
<p>用于周期性执行某段处理程序。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">probe timer.s(4) &#123; printf(&quot;hello world\n&quot;) &#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，每隔4秒就会输出hello world。还可以使用其它规格的定时器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timer.ms(milliseconds)</span><br><span class="line">timer.us(microseconds)</span><br><span class="line">timer.ns(nanoseconds)</span><br><span class="line">timer.hz(hertz)</span><br><span class="line">timer.jiffies(jiffies)</span><br></pre></td></tr></table></figure>

<p>定时事件总是跟其它事件搭配使用。其它事件负责收集信息，而定时事件定期输出当前状况，让你看到数据随时间的变化情况。</p>
<h3 id="SystemTap-处理程序"><a href="#SystemTap-处理程序" class="headerlink" title="SystemTap 处理程序"></a>SystemTap 处理程序</h3><p>有了事件之后，我们还需要在事件发生之后进行处理。</p>
<p>example1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">probe begin</span><br><span class="line">&#123;</span><br><span class="line">  printf (&quot;hello world\n&quot;)</span><br><span class="line">  exit ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SystemTap脚本会一直运行，直到执行了exit()函数。如果你想中途退出一个脚本，可以用Ctrl+c中断。<br>这是一个异步事件 <code>begin</code> 之后开始打印 一个字符串.</p>
<p><code>printf</code> 是一个标准输出函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf (&quot;format string\n&quot;, arguments)</span><br></pre></td></tr></table></figure>


<p>example2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">probe syscall.open</span><br><span class="line">&#123;</span><br><span class="line">  printf (&quot;%s(%d) open\n&quot;, execname(), pid())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &#39; probe syscall.open &#123;  printf (&quot;%s(%d) open\n&quot;, execname(), pid()) &#125;&#39; | sudo stap -v -</span><br></pre></td></tr></table></figure>
<p>example2中 SystemTap会在每次open被调用时，输出调用程序的名字和PID。</p>
<p>该探针输出的结果看上去会是这样(not in zsh, in bash)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:~&#x2F;workspace$ echo &#39; probe syscall.open &#123;  printf (&quot;%s(%d) open\n&quot;, execname(), pid()) &#125;&#39; | sudo stap -v -</span><br><span class="line">Pass 1: parsed user script and 476 library scripts using 108308virt&#x2F;90696res&#x2F;7172shr&#x2F;83388data kb, in 290usr&#x2F;40sys&#x2F;364real ms.</span><br><span class="line">Pass 2: analyzed script: 4 probes, 5 functions, 97 embeds, 4 globals using 110292virt&#x2F;93060res&#x2F;7724shr&#x2F;85372data kb, in 230usr&#x2F;330sys&#x2F;575real</span><br><span class="line"> ms.</span><br><span class="line">Pass 3: using cached &#x2F;root&#x2F;.systemtap&#x2F;cache&#x2F;4c&#x2F;stap_4cd2c557b5457e5f955c640275432033_64778.c</span><br><span class="line">Pass 4: using cached &#x2F;root&#x2F;.systemtap&#x2F;cache&#x2F;4c&#x2F;stap_4cd2c557b5457e5f955c640275432033_64778.ko</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">rg(25671) open</span><br><span class="line">rg(25671) open</span><br><span class="line">rg(25671) open</span><br><span class="line">rg(25671) open</span><br><span class="line">rg(25671) open</span><br></pre></td></tr></table></figure>

<p>下面是常用的 SystemTap 内建函数：</p>
<p><code>tid()</code></p>
<p>当前的tid（thread id）。</p>
<p><code>uid()</code></p>
<p>当前的uid。</p>
<p><code>cpu()</code></p>
<p>当前的CPU号</p>
<p><code>gettimeofday_s()</code></p>
<p>自epoch以来的秒数</p>
<p><code>ctime()</code></p>
<p>将上一个函数返回的秒数转化成时间字符串</p>
<p><code>pp()</code></p>
<p>返回描述当前处理的探测点的字符串</p>
<p><code>thread_indent()</code></p>
<p><code>name</code></p>
<p>返回系统调用的名字。这个变量只能在syscall.system_call触发的处理程序中使用。</p>
<p><code>target()</code></p>
<p>当你通过stap script -x PID或stap script -c command来执行某个脚本script时，target()会返回你指定的PID或命令名。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">probe syscall.* &#123;</span><br><span class="line">  if (pid() &#x3D;&#x3D; target())</span><br><span class="line">    printf(&quot;%s\n&quot;, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &#39; probe syscall.* &#123; if (pid() &#x3D;&#x3D; target()) printf(&quot;%s\n&quot;, name) &#125;&#39; | sudo stap -v -</span><br></pre></td></tr></table></figure>
<p>这个 SystemTap 脚本使用了通配符 probe了所以系统调用，在对脚本解析，编译成为 kernel module ko的时候尤其耗时，<br>在我 I5 5200U的机器上居然准备工作做了进1min…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">top - 12:38:07 up 12:53,  2 users,  load average: 2.56, 1.77, 1.14</span><br><span class="line">任务: 277 total,   5 running, 271 sleeping,   0 stopped,   1 zombie</span><br><span class="line">%Cpu(s): 10.0 us, 17.6 sy,  0.0 ni, 66.9 id,  0.0 wa,  0.0 hi,  5.5 si,  0.0 st</span><br><span class="line">MiB Mem :   3658.2 total,    196.4 free,   2043.1 used,   1418.8 buff&#x2F;cache</span><br><span class="line">MiB Swap:   2048.0 total,   1572.1 free,    475.9 used.    986.8 avail Mem</span><br><span class="line"></span><br><span class="line"> 进程号 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">  54775 root      20   0  171592 154320  18248 R  99.7   4.1   1:05.72 stap</span><br><span class="line">    932 ubuntu    20   0 1750472  40364  14900 S   3.7   1.1  11:16.15 Xorg</span><br><span class="line">   1279 ubuntu    20   0 4777288 218332  57988 S   3.0   5.8  12:57.76 gnome-shell</span><br><span class="line">   2458 ubuntu    20   0 4633228 103048  65556 R   3.0   2.8   0:10.23 chrome</span><br><span class="line">   1747 ubuntu    20   0  987308  43280  31604 S   1.7   1.2   0:46.33 gnome-terminal-</span><br><span class="line">   2371 ubuntu    20   0 1342876 232676  99800 S   0.7   6.2   8:23.72 chrome</span><br><span class="line">     18 root      20   0       0      0      0 S   0.3   0.0   0:01.14 ksoftirqd&#x2F;1</span><br><span class="line">     30 root      20   0       0      0      0 S   0.3   0.0   0:00.87 ksoftirqd&#x2F;3</span><br><span class="line">Inspiron-5548@ubuntu: ~&#x2F;workspace&#x2F;linux-stable&#x2F;drivers#</span><br></pre></td></tr></table></figure>
<p>输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:~&#x2F;workspace$ echo &#39; probe syscall.* &#123; if (pid() &#x3D;&#x3D; target()) printf(&quot;%s\n&quot;, name) &#125;&#39; | sudo stap -v -x 2371 -</span><br><span class="line">Pass 1: parsed user script and 476 library scripts using 108312virt&#x2F;90872res&#x2F;7344shr&#x2F;83392data kb, in 510usr&#x2F;40sys&#x2F;559real ms.</span><br><span class="line">qWARNING: cross-file global variable reference to identifier &#39;syscall_string_trunc&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;syscalls_cfg_trunc.s</span><br><span class="line">tp:3:8 from: identifier &#39;syscall_string_trunc&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;sysc_add_key.stp:19:59</span><br><span class="line"> source:                         user_buffer_quoted(payload_uaddr, plen, syscall_string_trunc),</span><br><span class="line">                                                                         ^</span><br><span class="line">        in expansion of macro: operator &#39;@_SYSCALL_ADD_KEY_ARGSTR&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;sysc_add_key.stp:72:2</span><br><span class="line"> source:        @_SYSCALL_ADD_KEY_ARGSTR</span><br><span class="line">                ^</span><br><span class="line">WARNING: cross-file global variable reference to identifier &#39;syscall_string_trunc&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;syscalls_cfg_trunc.st</span><br><span class="line">p:3:8 from: identifier &#39;syscall_string_trunc&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;sysc_mount.stp:31:46</span><br><span class="line"> source:        data &#x3D; user_string_n_quoted(pointer_arg(5), syscall_string_trunc)</span><br><span class="line">                                                            ^</span><br><span class="line">WARNING: cross-file global variable reference to identifier &#39;syscall_string_trunc&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;syscalls_cfg_trunc.st</span><br><span class="line">p:3:8 from: identifier &#39;syscall_string_trunc&#39; at :23:49</span><br><span class="line"> source:        buf_str &#x3D; user_buffer_quoted(buf_uaddr, count, syscall_string_trunc)</span><br><span class="line">                                                               ^</span><br><span class="line">        in expansion of macro: operator &#39;@_SYSCALL_WRITE_REGARGS&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;sysc_write.stp:100:2</span><br><span class="line"> source:        @_SYSCALL_WRITE_REGARGS</span><br><span class="line">                ^</span><br><span class="line">Pass 2: analyzed script: 853 probes, 29 functions, 100 embeds, 5 globals using 129252virt&#x2F;113636res&#x2F;9172shr&#x2F;104332data kb, in 35560usr&#x2F;79740s</span><br><span class="line">ys&#x2F;116322real ms.</span><br><span class="line">Pass 3: using cached &#x2F;root&#x2F;.systemtap&#x2F;cache&#x2F;e2&#x2F;stap_e2b35608bd8c0499c68f451dc8b09a85_432536.c</span><br><span class="line">Pass 4: using cached &#x2F;root&#x2F;.systemtap&#x2F;cache&#x2F;e2&#x2F;stap_e2b35608bd8c0499c68f451dc8b09a85_432536.ko</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">recvmsg</span><br><span class="line">write</span><br><span class="line">write</span><br><span class="line">epoll_wait</span><br><span class="line">epoll_wait</span><br><span class="line">epoll_wait</span><br><span class="line">recvmsg</span><br><span class="line">read</span><br><span class="line">sendto</span><br><span class="line">futex</span><br><span class="line">recvmsg</span><br><span class="line">recvmsg</span><br><span class="line">recvmsg</span><br><span class="line">poll</span><br><span class="line">recvmsg</span><br><span class="line">recvmsg</span><br></pre></td></tr></table></figure>



<h3 id="SystemTap-处理程序的基本结构"><a href="#SystemTap-处理程序的基本结构" class="headerlink" title="SystemTap 处理程序的基本结构"></a>SystemTap 处理程序的基本结构</h3><p>SystemTap 在处理程序中 它们的语法基本上类似于C或awk。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>处理程序里面当然可以使用变量，你所需的不过是给它取个好名字，把函数或表达式的值赋给它，然后就可以使用它了。<br>SystemTap可以自动判定变量的类型。举个例子，如果你用gettimeofday_s()给变量foo赋值，那么foo就是数值类型的，<br>可以在printf()中通过%d输出。</p>
<p>变量默认只能在其所定义的探针内可用。这意味着变量的生命周期仅仅是处理程序的某次运行。<br>不过你也可以在探针外定义变量，并使用global修饰它们，这样就能在探针间共享变量了。 ⁠</p>
<p>example1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">global count_jiffies, count_ms</span><br><span class="line">probe timer.jiffies(100) &#123; count_jiffies ++ &#125;</span><br><span class="line">probe timer.ms(100) &#123; count_ms ++ &#125;</span><br><span class="line">probe timer.ms(12345)</span><br><span class="line">&#123;</span><br><span class="line">  hz&#x3D;(1000*count_jiffies) &#x2F; count_ms</span><br><span class="line">  printf (&quot;jiffies:ms ratio %d:%d &#x3D;&gt; CONFIG_HZ&#x3D;%d\n&quot;,</span><br><span class="line">    count_jiffies, count_ms, hz)</span><br><span class="line">  exit ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>example1 中 timer-jiffies.stp 通过累加jiffies和milliseconds，来求出内核的CONFIG_HZ配置。<br>global语句使得count_jiffies和count_ms在每个探针中可用。</p>
<h4 id="目标变量-Target-Variables"><a href="#目标变量-Target-Variables" class="headerlink" title="目标变量(Target Variables)"></a>目标变量(Target Variables)</h4><p>跟内核代码相关的事件，如kernel.function(“function”)和kernel.statement(“statement”)，<br>允许使用目标变量获取这部分代码中可访问到的变量的值。<br>你可以使用-L选项来列出特定探测点下可用的目标变量。<br>如果已经安装了内核调试信息，你可以通过这个命令获取vfs_read中可用的目标变量</p>
<p>由于 我当前笔记本环境问题，暂时没法使用这个，会报错，后续补充</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:&#x2F;etc&#x2F;apt$ sudo stap -L &#39;kernel.function(&quot;vfs_read&quot;)&#39;</span><br><span class="line">Tip: &#x2F;usr&#x2F;share&#x2F;doc&#x2F;systemtap&#x2F;README.Debian should help you get started.</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:&#x2F;etc&#x2F;apt$ sudo stap -e &#39;probe kernel.function(&quot;vfs_read&quot;) &#123;</span><br><span class="line">&gt;            printf (&quot;current files_stat max_files: %d\n&quot;,</span><br><span class="line">&gt;                    @var(&quot;[email protected]&#x2F;file_table.c&quot;)-&gt;max_files);</span><br><span class="line">&gt;            exit(); &#125;&#39;</span><br><span class="line">semantic error: while resolving probe point: identifier &#39;kernel&#39; at &lt;input&gt;:1:7</span><br><span class="line">        source: probe kernel.function(&quot;vfs_read&quot;) &#123;</span><br><span class="line">                      ^</span><br><span class="line"></span><br><span class="line">semantic error: missing x86_64 kernel&#x2F;module debuginfo [man warning::debuginfo] under &#39;&#x2F;lib&#x2F;modules&#x2F;5.4.0-58-generic&#x2F;build&#39;</span><br><span class="line"></span><br><span class="line">Pass 2: analysis failed.  [man error::pass2]</span><br><span class="line">Tip: &#x2F;usr&#x2F;share&#x2F;doc&#x2F;systemtap&#x2F;README.Debian should help you get started.</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:&#x2F;etc&#x2F;apt$</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@ubuntu: ~&#x2F;workspace&#x2F;linux-stable&#x2F;drivers# stap -l &#39;syscall.*&#39;</span><br><span class="line">syscall.accept</span><br><span class="line">syscall.accept4</span><br><span class="line">syscall.accesso</span><br><span class="line">syscall.acct</span><br><span class="line">syscall.add_key</span><br><span class="line">syscall.adjtimex</span><br><span class="line">syscall.alarm</span><br><span class="line">syscall.arch_prctl</span><br></pre></td></tr></table></figure>


<h4 id="整齐打印目标变量（Pretty-Printing-Target-Variables）"><a href="#整齐打印目标变量（Pretty-Printing-Target-Variables）" class="headerlink" title="整齐打印目标变量（Pretty Printing Target Variables）"></a>整齐打印目标变量（Pretty Printing Target Variables）</h4><p>某些场景中，我们可能需要输出当前可访问的各种变量，以便于记录底层的变化。SystemTap提供了一些操作，可以生成描述特定目标变量的字符串：</p>
<p><code>$$vars</code></p>
<p>输出作用域内每个变量的值。等价于sprintf(“parm1=%x … parmN=%x var1=%x … varN=%x”, parm1, …, parmN, var1, …, varN)。如果变量的值在运行时找不到，输出=?。</p>
<p><code>$$locals</code></p>
<p>同<code>$$vars</code>，只输出本地变量。</p>
<p><code>$$parms</code></p>
<p>同<code>$$vars</code>，只输出函数入参。</p>
<p><code>$$return</code></p>
<p>仅在带return的探针中可用。如果被监控的函数有返回值，它等价于sprintf(“return=%x”, $return)，否则为空字符串。</p>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>有些时候，你写的SystemTap脚本较为复杂，可能需要用上条件语句。SystemTap支持C风格的条件语句，另外还支持foreach (VAR in ARRAY) {}形式的遍历。</p>
<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>通过$或@加个数字的形式可以访问对应位置的命令行参数。用$会把用户输入当作整数，用@会把用户输入当作字符串。</p>
<p>probe kernel.function(@1) { }<br>probe kernel.function(@1).return { }<br>上面的脚本期望用户把要监控的函数作为命令行参数传递进来。你可以让脚本接受多个命令行参数，分别命名为@1，@2等等，按用户输入的次序逐个对应。</p>
<h2 id="Tapsets"><a href="#Tapsets" class="headerlink" title="Tapsets"></a>Tapsets</h2><p>tapsets是一些包含常用的探针和函数的内置脚本，你可以在SystemTap脚本中复用它们。</p>
<p>当用户运行一个SystemTap脚本时，SystemTap会检测脚本中的事件和处理程序，并在翻译脚本成C代码之前，加载用到的tapset。<br>就像SystemTap脚本一样，tapset的拓展名也是.stp。<br>默认情况下tapset位于/usr/share/systemtap/tapset/。</p>
<p>跟SystemTap脚本不同的是，tapset不能被直接运行；它只能作为库使用。<br>tapset库让用户能够在更高的抽象层次上定义事件和函数。<br>tapset提供了一些常用的内核函数的别名，这样用户就不需要记住完整的内核函数名了（尤其是有些函数名可能会因内核版本的不同而不同）。<br>另外tapset也提供了常用的辅助函数，比如之前我们见过的thread_indent()。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SystemTap 使用过程中发现 他解析编译极其慢，很耗费 CPU资源，最好做到一次解析编译模块，可以到处<br>部署，实际SystemTap 也已经支持了这样的做法。</p>
<p>参考<a target="_blank" rel="noopener" href="https://spacewander.gitbooks.io/systemtapbeginnersguide_zh/content/2_3_RunningSystemTapScripts.html">SystemTap 内核文档</a></p>
<p>参考 <a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html-single/systemtap_beginners_guide/index">RedHat systemTap 文档</a></p>
<p>参考 <a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide/index.html">文档</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-07T12:00:40.000Z" title="1/7/2021, 8:00:40 PM">2021-01-07</time>发表</span><span class="level-item"><time dateTime="2021-01-14T16:53:25.527Z" title="1/15/2021, 12:53:25 AM">2021-01-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">4 分钟读完 (大约526个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/07/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/tools/vmtouch%20%E8%A7%82%E6%B5%8B%E6%96%87%E4%BB%B6page%20cache/">vmtouch 观测文件page cache</a></h1><div class="content"><h2 id="vmtouch-介绍"><a href="#vmtouch-介绍" class="headerlink" title="vmtouch 介绍"></a>vmtouch 介绍</h2><p><code>便携式文件系统缓存诊断和控制</code> 是 <code>vmtouch</code> 作者对于vmtouch的的定义。<br>首先他可以很方便的知道某一个文件当前有多少在 kernel memory 里面作为<br><code>pagecache</code> 存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ vmtouch haha</span><br><span class="line">           Files: 1</span><br><span class="line">     Directories: 0</span><br><span class="line">  Resident Pages: 11584&#x2F;1024000  45M&#x2F;3G  1.13%</span><br><span class="line">         Elapsed: 0.031335 seconds</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ cat haha</span><br><span class="line">^C</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ vmtouch haha</span><br><span class="line">           Files: 1</span><br><span class="line">     Directories: 0</span><br><span class="line">  Resident Pages: 36800&#x2F;1024000  143M&#x2F;3G  3.59%</span><br><span class="line">         Elapsed: 0.033472 seconds</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$</span><br></pre></td></tr></table></figure>

<p>明显可以看到在经过 <code>cat</code> 访问之后 文件更多部分被读入 memory，作为 pagecache。</p>
<p>作者对于他的功能介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 发现你的操作系统正在缓存哪些文件</span><br><span class="line">2. 告诉操作系统缓存或清除某些文件或文件区域</span><br><span class="line">3. 将文件锁定在内存中，这样操作系统就不会删除它们</span><br><span class="line">4. 在服务器故障转移时保留虚拟内存配置文件</span><br><span class="line">5. 保持“热备”文件服务器</span><br><span class="line">6. 绘制文件系统缓存随时间的使用情况</span><br><span class="line">7. 维护缓存使用的“软配额”</span><br></pre></td></tr></table></figure>



<h2 id="vmtouch-使用"><a href="#vmtouch-使用" class="headerlink" title="vmtouch 使用"></a>vmtouch 使用</h2><h3 id="控制增加-pagecache"><a href="#控制增加-pagecache" class="headerlink" title="控制增加 pagecache"></a>控制增加 pagecache</h3><p>可以将整个文件读入内存，其实我们通过访问这个文件（从头到尾）也可以做到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ vmtouch -vt haha</span><br><span class="line">haha</span><br><span class="line">[OOo                                                         ] 44737&#x2F;1024000</span><br><span class="line">[OOOOOo                                                      ] 90849&#x2F;1024000</span><br><span class="line">[OOOOOOOOo                                                   ] 150209&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOo                                               ] 215937&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOo                                            ] 271489&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOo                                        ] 326305&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOo                                      ] 370721&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOo                                   ] 414305&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOo                                ] 469697&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo                             ] 524289&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo                          ] 577153&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo                     ] 652481&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo                  ] 705953&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo               ] 757281&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo            ] 810593&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo        ] 876769&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo      ] 920545&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo  ] 973473&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO] 1024000&#x2F;1024000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           Files: 1</span><br><span class="line">     Directories: 0</span><br><span class="line">   Touched Pages: 1024000 (3G)</span><br><span class="line">         Elapsed: 9.4376 seconds</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$</span><br></pre></td></tr></table></figure>


<h3 id="控制减少-pagecache"><a href="#控制减少-pagecache" class="headerlink" title="控制减少 pagecache"></a>控制减少 pagecache</h3><p>evict a file from memory<br>将一个文件的pagecache 从内存中移除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ vmtouch -ve haha</span><br><span class="line">Evicting haha</span><br><span class="line"></span><br><span class="line">           Files: 1</span><br><span class="line">     Directories: 0</span><br><span class="line">   Evicted Pages: 1024000 (3G)</span><br><span class="line">         Elapsed: 0.085208 seconds</span><br></pre></td></tr></table></figure>

<p>与<code>drop cache</code>不同，<code>vmtouch</code>做到了精准控制单个文件page_cache的效果，而 drop cache不行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu-Inspiron-5548:&#x2F;home&#x2F;ubuntu# echo 1 &gt;  &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span><br><span class="line">root@ubuntu-Inspiron-5548:&#x2F;home&#x2F;ubuntu# echo 3 &gt;  &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span><br></pre></td></tr></table></figure>

<h3 id="保持文件在pagecache中"><a href="#保持文件在pagecache中" class="headerlink" title="保持文件在pagecache中"></a>保持文件在pagecache中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ vmtouch -dl haha</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ vmtouch: FATAL: mlock: haha (Cannot allocate memory)</span><br><span class="line"></span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$</span><br></pre></td></tr></table></figure>
<p>(内存4G，文件4G 是没办法将文件常驻在 内存中的)<br>从此报错信息可以看出 <code>vmtouch</code> 也是通过 <code>mlock</code> 系统调用来实现 文件内容 或者 文件目录内容锁定在 内存中的</p>
<p><a target="_blank" rel="noopener" href="https://hoytech.com/vmtouch/">vmtouch 作者的文章</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-07T02:00:40.000Z" title="1/7/2021, 10:00:40 AM">2021-01-07</time>发表</span><span class="level-item"><time dateTime="2021-01-14T16:53:25.527Z" title="1/15/2021, 12:53:25 AM">2021-01-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">1 分钟读完 (大约143个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/07/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/systemTap/examples/SystemTap%20examples/">SystemTap examples</a></h1><div class="content"><p>SystemTap脚本集锦<br>本章列举了若干可用于监控和调查内核子系统的SystemTap脚本。所有这些示例都能在 <code>centos</code>的<br> <code>/usr/share/systemtap/testsuite/systemtap.examples/</code>下找到。</p>
<h2 id="SystemTap脚本集锦"><a href="#SystemTap脚本集锦" class="headerlink" title="SystemTap脚本集锦"></a>SystemTap脚本集锦</h2><p><a target="_blank" rel="noopener" href="https://spacewander.gitbooks.io/systemtapbeginnersguide_zh/content/5_UsefulSystemTapScripts.html">SystemTap脚本集锦</a></p>
<h2 id="解读错误信息"><a href="#解读错误信息" class="headerlink" title="解读错误信息"></a>解读错误信息</h2><p><a target="_blank" rel="noopener" href="https://spacewander.gitbooks.io/systemtapbeginnersguide_zh/content/6_UnderstandingSystemTapErrors.html">解读错误信息</a></p>
<p> 参考<a target="_blank" rel="noopener" href="https://spacewander.gitbooks.io/systemtapbeginnersguide_zh/content/2_3_RunningSystemTapScripts.html">SystemTap 内核文档</a></p>
<p>参考 <a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html-single/systemtap_beginners_guide/index">RedHat systemTap 文档</a></p>
<p>参考 <a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide/index.html">文档</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/linux%E5%86%85%E6%A0%B8/page/3/">上一页</a></div><div class="pagination-next"><a href="/categories/linux%E5%86%85%E6%A0%B8/page/5/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/linux%E5%86%85%E6%A0%B8/">1</a></li><li><a class="pagination-link" href="/categories/linux%E5%86%85%E6%A0%B8/page/2/">2</a></li><li><a class="pagination-link" href="/categories/linux%E5%86%85%E6%A0%B8/page/3/">3</a></li><li><a class="pagination-link is-current" href="/categories/linux%E5%86%85%E6%A0%B8/page/4/">4</a></li><li><a class="pagination-link" href="/categories/linux%E5%86%85%E6%A0%B8/page/5/">5</a></li><li><a class="pagination-link" href="/categories/linux%E5%86%85%E6%A0%B8/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Hui Su"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Hui Su</p><p class="is-size-6 is-block">liulangren bolg</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">92</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">120</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liulangrenaaa" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liulangrenaaa"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.google.com.hk/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Google</span></span><span class="level-right"><span class="level-item tag">www.google.com.hk</span></span></a></li><li><a class="level is-mobile" href="https://lkml.org/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">LKML</span></span><span class="level-right"><span class="level-item tag">lkml.org</span></span></a></li><li><a class="level is-mobile" href="https://mail.google.com/mail" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gmail</span></span><span class="level-right"><span class="level-item tag">mail.google.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhihu.com/explore" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/contest/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 剑指offer</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 周赛</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://tongji.baidu.com/web/32051076/overview/index?siteId=16230094" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">百度分析</span></span><span class="level-right"><span class="level-item tag">tongji.baidu.com</span></span></a></li><li><a class="level is-mobile" href="https://analytics.google.com/analytics/web/#/a187909645p259761261/admin/streams/table/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">google分析</span></span><span class="level-right"><span class="level-item tag">analytics.google.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/KASAN/"><span class="tag">KASAN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OOM/"><span class="tag">OOM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QCOM/"><span class="tag">QCOM</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpf/"><span class="tag">bpf</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpftrace/"><span class="tag">bpftrace</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup/"><span class="tag">cgroup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v1/"><span class="tag">cgroup v1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v2/"><span class="tag">cgroup v2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/crash/"><span class="tag">crash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dd/"><span class="tag">dd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/deadlock/"><span class="tag">deadlock</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debugfs/"><span class="tag">debugfs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/double-free/"><span class="tag">double free</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/drop-caches/"><span class="tag">drop_caches</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dumpe2fs/"><span class="tag">dumpe2fs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/event-trace/"><span class="tag">event trace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ext2/"><span class="tag">ext2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-attr/"><span class="tag">file attr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-hole/"><span class="tag">file hole</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/filesystem/"><span class="tag">filesystem</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fsck/"><span class="tag">fsck</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ftrace/"><span class="tag">ftrace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gdb/"><span class="tag">gdb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hardlockup/"><span class="tag">hardlockup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hrtimer/"><span class="tag">hrtimer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hugepage/"><span class="tag">hugepage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hungtask/"><span class="tag">hungtask</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt/"><span class="tag">intrrrupt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt-storm/"><span class="tag">intrrrupt storm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/irq/"><span class="tag">irq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kdump/"><span class="tag">kdump</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kernel-patch/"><span class="tag">kernel patch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kfence/"><span class="tag">kfence</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kmemleak/"><span class="tag">kmemleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kprobes/"><span class="tag">kprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kretprobes/"><span class="tag">kretprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ksoftirqd/"><span class="tag">ksoftirqd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kthread/"><span class="tag">kthread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvm/"><span class="tag">kvm</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvmtool/"><span class="tag">kvmtool</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/launch-json/"><span class="tag">launch.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-kernel/"><span class="tag">linux kernel</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lockdep/"><span class="tag">lockdep</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/makedumpfile/"><span class="tag">makedumpfile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memleak/"><span class="tag">memleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory/"><span class="tag">memory</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory-direct-reclaim/"><span class="tag">memory direct reclaim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mount/"><span class="tag">mount</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/namespace/"><span class="tag">namespace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oom/"><span class="tag">oom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oops/"><span class="tag">oops</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-cache/"><span class="tag">page_cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-owner/"><span class="tag">page_owner</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pagecache/"><span class="tag">pagecache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/panic/"><span class="tag">panic</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/per-cpu/"><span class="tag">per-cpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/perf/"><span class="tag">perf</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pid-namespace/"><span class="tag">pid namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preempt-count/"><span class="tag">preempt_count</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pressure/"><span class="tag">pressure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psi/"><span class="tag">psi</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rcu/"><span class="tag">rcu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/read-code/"><span class="tag">read code</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sched-latency/"><span class="tag">sched latency</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/schedule/"><span class="tag">schedule</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slab/"><span class="tag">slab</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub/"><span class="tag">slub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub-debug/"><span class="tag">slub_debug</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/softlockup/"><span class="tag">softlockup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stack-overflow/"><span class="tag">stack_overflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sync/"><span class="tag">sync</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systemTap/"><span class="tag">systemTap</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-json/"><span class="tag">task.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-struct/"><span class="tag">task_struct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tasklet/"><span class="tag">tasklet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thread-info/"><span class="tag">thread_info</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ubuntu/"><span class="tag">ubuntu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/use-after-free/"><span class="tag">use after free</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uts-namespace/"><span class="tag">uts namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/valgrind/"><span class="tag">valgrind</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vdso/"><span class="tag">vdso</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmstat/"><span class="tag">vmstat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmtouch/"><span class="tag">vmtouch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vscode/"><span class="tag">vscode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/x86/"><span class="tag">x86</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xattr/"><span class="tag">xattr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zone/"><span class="tag">zone</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%B6%8A%E7%95%8C/"><span class="tag">内存泄漏越界</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"><span class="tag">内存泄露</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内核内存泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C/"><span class="tag">内核内存越界</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"><span class="tag">内核同步</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0/"><span class="tag">内核抢占</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%A0%88%E6%BA%A2%E5%87%BA/"><span class="tag">内核栈溢出</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E7%AE%A1%E7%AE%A1%E7%90%86/"><span class="tag">内管管理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"><span class="tag">函数调用</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/"><span class="tag">性能稳定性</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B3%84%E6%BC%8F/"><span class="tag">文件描述符泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><span class="tag">文件系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E9%A1%B9/"><span class="tag">杂项</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%88/"><span class="tag">栈</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/"><span class="tag">死锁检测</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="tag">生活感悟</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%A8%E6%88%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">用户内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A9%BA%E6%8C%87%E9%92%88/"><span class="tag">空指针</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F/"><span class="tag">虚拟地址空间泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F/"><span class="tag">资源泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%B8%AD%E6%96%AD/"><span class="tag">软中断</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"><span class="tag">进程调度</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/"><span class="tag">通用寄存器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81%E7%B2%92%E5%BA%A6/"><span class="tag">锁粒度</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E7%B3%BB%E7%BB%9F/"><span class="tag">问题系统</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/QCOM/"><span class="level-start"><span class="level-item">QCOM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/cgroup-v1/"><span class="level-start"><span class="level-item">cgroup v1</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/cgroup-v1/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/kernel-debug/"><span class="level-start"><span class="level-item">kernel debug</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-kernel/"><span class="level-start"><span class="level-item">linux kernel</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/"><span class="level-start"><span class="level-item">linux schedule</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/deadline-schedule/"><span class="level-start"><span class="level-item">deadline schedule</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/"><span class="level-start"><span class="level-item">frequency governer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/schedule-util/"><span class="level-start"><span class="level-item">schedule util</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/idle/"><span class="level-start"><span class="level-item">idle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/linux%E5%86%85%E6%A0%B8/"><span class="level-start"><span class="level-item">linux内核</span></span><span class="level-end"><span class="level-item tag">53</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/"><span class="level-start"><span class="level-item">namespace</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/namespace/pid-namespace/"><span class="level-start"><span class="level-item">pid namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/uts-namespace/"><span class="level-start"><span class="level-item">uts namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/qemu/"><span class="level-start"><span class="level-item">qemu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/server/"><span class="level-start"><span class="level-item">server</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/shell%E8%84%9A%E6%9C%AC/"><span class="level-start"><span class="level-item">shell脚本</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="level-start"><span class="level-item">生活感悟</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-16T11:00:40.000Z">2021-07-16</time></p><p class="title"><a href="/2021/07/16/filesystem/file%20hole/">file hole</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-15T11:00:40.000Z">2021-07-15</time></p><p class="title"><a href="/2021/07/15/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/perf%E7%9B%B8%E5%85%B3/perf%20kernel%20subsys/">perf kernel subsys</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-15T11:00:40.000Z">2021-07-15</time></p><p class="title"><a href="/2021/07/15/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/perf%E7%9B%B8%E5%85%B3/perf%20example/">perf example</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-15T11:00:40.000Z">2021-07-15</time></p><p class="title"><a href="/2021/07/15/filesystem/fsck/">fsck</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-14T11:20:59.152Z">2021-07-14</time></p><p class="title"><a href="/2021/07/14/filesystem/buffer_head/"> </a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Su Hui</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>