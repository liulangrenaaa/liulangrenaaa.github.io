<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: linux内核 - liulangren Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="liulangren blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="liulangren blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="liulangren Blog"><meta property="og:url" content="https://liulangrenaaa.github.io/"><meta property="og:site_name" content="liulangren Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liulangrenaaa.github.io/img/og_image.png"><meta property="article:author" content="Su Hui"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liulangrenaaa.github.io"},"headline":"liulangren Blog","image":["https://liulangrenaaa.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Su Hui"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cabdc5b9b70bb83fa919a6ebeb439f93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=PTKX6HMR55" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'PTKX6HMR55');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">linux内核</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-17T11:00:00.000Z" title="1/17/2021, 7:00:00 PM">2021-01-17</time>发表</span><span class="level-item"><time dateTime="2021-01-21T09:06:22.284Z" title="1/21/2021, 5:06:22 PM">2021-01-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">12 分钟读完 (大约1859个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/17/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/valgrind%20%E5%AE%9A%E4%BD%8D%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">valgrind 定位用户空间内存泄漏</a></h1><div class="content"><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h2><p>在实际开发中，某个应用程序如果存在内存泄露，且是长时间运行的程序，就会导致比较严重的后果。<br>在一些业务场景的长跑测试中，这些问题往往会充分暴露出来。</p>
<p>一般情况下这种内存泄漏都是以 OOM Kill 而结尾的。 kmsg log 往往只有 这个进程确实消耗了大量进<br>程的证据，但是无法确切知道是哪里的内存泄漏，这里就需要一个工具来帮助检测，如果是发生内存泄漏之后<br>仅仅通过人肉去分析代码，往往很困难。</p>
<p>valgrind 就是这样一款 强大的工具：</p>
<ol>
<li>检查用户空间内存泄漏</li>
<li>检查</li>
</ol>
<h2 id="valdrind-原理"><a href="#valdrind-原理" class="headerlink" title="valdrind 原理"></a>valdrind 原理</h2><h2 id="valdrind-安装，使用"><a href="#valdrind-安装，使用" class="headerlink" title="valdrind 安装，使用"></a>valdrind 安装，使用</h2><p>直接安装， ubuntu 官方软件源已经包含了，其他平台可以通过源码编译安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@100ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak# sudo apt install valgrind</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following packages were automatically installed and are no longer required:</span><br><span class="line">  openbsd-inetd openjdk-11-jdk-headless tcpd update-inetd</span><br><span class="line">Use &#39;sudo apt autoremove&#39; to remove them.</span><br><span class="line">Suggested packages:</span><br><span class="line">  valgrind-dbg valgrind-mpi kcachegrind alleyoop valkyrie</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  valgrind</span><br><span class="line">0 upgraded, 1 newly installed, 0 to remove and 231 not upgraded.</span><br><span class="line">Need to get 20.3 MB of archives.</span><br><span class="line">After this operation, 90.0 MB of additional disk space will be used.</span><br><span class="line">Get:1 https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu focal-updates&#x2F;main amd64 valgrind amd64 1:3.15.0-1ubuntu9.1 [20.3 MB]</span><br><span class="line">48% [1 valgrind 12.2 MB&#x2F;20.3 MB 60%]</span><br><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak# ls</span><br></pre></td></tr></table></figure>

<p>使用如下代码检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int i &#x3D; 3;</span><br><span class="line">        char *p &#x3D; NULL;</span><br><span class="line">        p &#x3D; malloc(1024 * 1024);</span><br><span class="line">        if (!p)</span><br><span class="line">                printf(&quot;malloc failed,just wait!!\n&quot;);</span><br><span class="line"></span><br><span class="line">        printf(&quot;malloc sucess,just wait!!\n&quot;);</span><br><span class="line"></span><br><span class="line">        while(i--) &#123;</span><br><span class="line">                usleep(1000 * 1000);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于 valgrind 不好的地方在于：</p>
<ol>
<li><p>对于想使用 valgrind来检查内存泄漏的业务来说，必须从开始 用valgrind 启动，意味着对于业务<br>需要重启。还有比如很难复现的内存泄漏，等你重启业务用 valgrind来启动，说不定又不复现了。。</p>
</li>
<li><p>对于 valgrind 启动的业务来说，会比直接启动有一些性能损失。</p>
</li>
</ol>
<h3 id="userspace-memleak-demo"><a href="#userspace-memleak-demo" class="headerlink" title="userspace memleak demo"></a>userspace memleak demo</h3><p>使用上面代码 直接用 <code>valgrind</code> 启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak# valgrind .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Command: .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;</span><br><span class="line">malloc sucess,just wait!!</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;     in use at exit: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;   total heap usage: 2 allocs, 1 frees, 1,049,600 bytes allocated</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; LEAK SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;    definitely lost: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;    still reachable: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;         suppressed: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; Rerun with --leak-check&#x3D;full to see details of leaked memory</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D; ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>HEAP SUMMARY:</code> 中写了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;     in use at exit: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813281&#x3D;&#x3D;   total heap usage: 2 allocs, 1 frees, 1,049,600 bytes allocated</span><br></pre></td></tr></table></figure>
<p>在进程退出时，仍然有 <code>1048576 bytes</code> 内存在使用中，这部分就是泄漏的内存。但是我们仍然不能确<br>定到底是哪里泄漏的内存，按照他的建议 加上 <code>-leak-check=full</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak# valgrind  --leak-check&#x3D;full  .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; Command: .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;</span><br><span class="line">malloc sucess,just wait!!</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;     in use at exit: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;   total heap usage: 2 allocs, 1 frees, 1,049,600 bytes allocated</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D; 1,048,576 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    by 0x1091AD: main (in &#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak&#x2F;a.out)</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; LEAK SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    definitely lost: 1,048,576 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    still reachable: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;         suppressed: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D; ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span><br><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak#</span><br></pre></td></tr></table></figure>

<p>可以看到这次， <code>valgrind</code> 已经将泄漏的具体位置打印了出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2813434&#x3D; 1,048,576 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2813434&#x3D;&#x3D;    by 0x1091AD: main (in &#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;user_space_memleak&#x2F;a.out)</span><br></pre></td></tr></table></figure>

<p>可以用 <code>gcc -g</code> 重新编译一下带上符号表信息，再次用 valgrind 定位，可以得到更详细信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2822695&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2822695&#x3D;&#x3D;    by 0x1091AD: main (user_space_memleak.c:9)</span><br></pre></td></tr></table></figure>
<p>这次直接将 在 哪个文件 哪一行都直接打印出来了。</p>
<h3 id="out-of-bounds-access-demo"><a href="#out-of-bounds-access-demo" class="headerlink" title="out of bounds access demo"></a>out of bounds access demo</h3><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int i &#x3D; 3;</span><br><span class="line">        char *p &#x3D; NULL;</span><br><span class="line">        p &#x3D; malloc(1024);</span><br><span class="line">        if (!p)</span><br><span class="line">                printf(&quot;malloc failed,just wait!!\n&quot;);</span><br><span class="line"></span><br><span class="line">        printf(&quot;malloc sucess,just wait!!*(p + 10) &#x3D; %d\n&quot;, *(p + 10));</span><br><span class="line">        *(p + 1023) &#x3D; *(p + 1024);</span><br><span class="line">        *(p + 1024) &#x3D; 1;</span><br><span class="line">        while(i--) &#123;</span><br><span class="line">                usleep(1000 * 1000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free(p);</span><br><span class="line">        free(p + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gcc -g</code> 编译之偶 用 <code>valgrind ./a.out</code> 跑一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;valgrind# valgrind .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Command: .&#x2F;a.out</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D; Use of uninitialised value of size 8</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    at 0x48B681B: _itoa_word (_itoa.c:179)</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    by 0x48D26F4: __vfprintf_internal (vfprintf-internal.c:1687)</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    by 0x48BCEBE: printf (printf.c:33)</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    by 0x109225: main (out_of_bounds_access.c:13)</span><br><span class="line">malloc sucess,just wait!!</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Invalid read of size 1</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x109200: main (out_of_bounds_access.c:14)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;  Address 0x4a4d440 is 0 bytes after a block of size 1,024 alloc&#39;d</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    by 0x1091CD: main (out_of_bounds_access.c:9)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Invalid write of size 1</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x109213: main (out_of_bounds_access.c:15)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;  Address 0x4a4d440 is 0 bytes after a block of size 1,024 alloc&#39;d</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    by 0x1091CD: main (out_of_bounds_access.c:9)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D; Invalid free() &#x2F; delete &#x2F; delete[] &#x2F; realloc()</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    at 0x483CA3F: free (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    by 0x10927F: main (out_of_bounds_access.c:21)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;  Address 0x4a4d041 is 1 bytes inside a block of size 1,024 free&#39;d</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    at 0x483CA3F: free (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    by 0x10926F: main (out_of_bounds_access.c:20)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;  Block was alloc&#39;d at</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    by 0x1091ED: main (out_of_bounds_access.c:9)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;   total heap usage: 2 allocs, 3 frees, 2,048 bytes allocated</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; All heap blocks were freed -- no leaks are possible</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<p>也是直接指出了 一次引用未初始化的内存, 两次越界访问, 一次非法 free：</p>
<ol>
<li><p>一次引用为初始化的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D; Use of uninitialised value of size 8</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    at 0x48B681B: _itoa_word (_itoa.c:179)</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    by 0x48D26F4: __vfprintf_internal (vfprintf-internal.c:1687)</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    by 0x48BCEBE: printf (printf.c:33)</span><br><span class="line">&#x3D;&#x3D;2833797&#x3D;&#x3D;    by 0x109225: main (out_of_bounds_access.c:13)</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次越界读访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Invalid read of size 1</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x109200: main (out_of_bounds_access.c:14)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;  Address 0x4a4d440 is 0 bytes after a block of size 1,024 alloc&#39;d</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    by 0x1091CD: main (out_of_bounds_access.c:9)</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次越界写访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D; Invalid write of size 1</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x109213: main (out_of_bounds_access.c:15)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;  Address 0x4a4d440 is 0 bytes after a block of size 1,024 alloc&#39;d</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2826928&#x3D;&#x3D;    by 0x1091CD: main (out_of_bounds_access.c:9)</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次 invaild free</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D; Invalid free() &#x2F; delete &#x2F; delete[] &#x2F; realloc()</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    at 0x483CA3F: free (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    by 0x10927F: main (out_of_bounds_access.c:21)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;  Address 0x4a4d041 is 1 bytes inside a block of size 1,024 free&#39;d</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    at 0x483CA3F: free (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    by 0x10926F: main (out_of_bounds_access.c:20)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;  Block was alloc&#39;d at</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    at 0x483B7F3: malloc (in &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;2845980&#x3D;&#x3D;    by 0x1091ED: main (out_of_bounds_access.c:9)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际项目中应用的内存泄漏往往比这要复杂很多，可能代码考虑了正常情况下的 free，异常情况下没有<br>free等， <code>valgrind</code> 是很强大，有很多参数，但也只能帮助我们在出现问题之后定位，还是需要养成良<br>好的编码习惯，减少杜绝这类问题</p>
<p>参考<a target="_blank" rel="noopener" href="http://senlinzhan.github.io/2017/12/31/valgrind/">文章1</a><br>参考<a target="_blank" rel="noopener" href="https://www.cprogramming.com/debugging/valgrind.html">文章2</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-16T11:00:00.000Z" title="1/16/2021, 7:00:00 PM">2021-01-16</time>发表</span><span class="level-item"><time dateTime="2021-01-31T09:47:29.081Z" title="1/31/2021, 5:47:29 PM">2021-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">7 分钟读完 (大约1122个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/16/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/kmemleak%20%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">kmemleak 定位内存泄露</a></h1><div class="content"><h2 id="kmemleak-原理"><a href="#kmemleak-原理" class="headerlink" title="kmemleak 原理"></a>kmemleak 原理</h2><p>Basic Algorithm<br>The memory allocations via kmalloc(), vmalloc(), kmem_cache_alloc() and friends are traced and the pointers, together with additional information like size and stack trace, are stored in a rbtree. The corresponding freeing function calls are tracked and the pointers removed from the kmemleak data structures.</p>
<p>An allocated block of memory is considered orphan if no pointer to its start address or to any location inside the block can be found by scanning the memory (including saved registers). This means that there might be no way for the kernel to pass the address of the allocated block to a freeing function and therefore the block is considered a memory leak.</p>
<p>The scanning algorithm steps:</p>
<p>mark all objects as white (remaining white objects will later be considered orphan)<br>scan the memory starting with the data section and stacks, checking the values against the addresses stored in the rbtree. If a pointer to a white object is found, the object is added to the gray list<br>scan the gray objects for matching addresses (some white objects can become gray and added at the end of the gray list) until the gray set is finished<br>the remaining white objects are considered orphan and reported via /sys/kernel/debug/kmemleak<br>Some allocated memory blocks have pointers stored in the kernel’s internal data structures and they cannot be detected as orphans. To avoid this, kmemleak can also store the number of values pointing to an address inside the block address range that need to be found so that the block is not considered a leak. One example is __vmalloc().</p>
<h2 id="kmemleak-使用"><a href="#kmemleak-使用" class="headerlink" title="kmemleak 使用"></a>kmemleak 使用</h2><p>kmemleak 功能一开始默认是不开启的，需要配置如下选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [ $debug_kmemleak &#x3D;&#x3D; 1 ]</span><br><span class="line">then</span><br><span class="line">## kmemleak detect and panic start</span><br><span class="line">	echo &quot;CONFIG_DEBUG_KMEMLEAK&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">	echo &quot;CONFIG_DEBUG_KMEMLEAK_MEM_POOL_SIZE&#x3D;16000&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">	echo &quot;CONFIG_DEBUG_KMEMLEAK_AUTO_SCAN&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">	echo &quot;CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE&#x3D;1&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">## kmemleak detect and panic end</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>参考<a target="_blank" rel="noopener" href="https://github.com/liulangrenaaa/test_modules/blob/main/resource_leak/kmemleak/kmemleak.c">test code</a></p>
<p>一开始遇到了无法安装的问题，后来发现是因为模块名 一样导致的问题。。<br>参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16360689/invalid-parameters-error-when-trying-to-insert-module-that-accesses-exported-s">bug</a></p>
<p>触发开始扫描，这是个同步过程，内存比较大的话可能比较耗时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# echo scan &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;kmemleak</span><br><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug#</span><br></pre></td></tr></table></figure>

<p>查看扫描结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# cat kmemleak</span><br><span class="line">unreferenced object 0xffff8da0cac1c500 (size 32):</span><br><span class="line">  comm &quot;insmod&quot;, pid 3529, jiffies 4294873584 (age 562.798s)</span><br><span class="line">  hex dump (first 32 bytes):</span><br><span class="line">    6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class="line">    6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b a5  kkkkkkkkkkkkkkk.</span><br><span class="line">  backtrace:</span><br><span class="line">    [&lt;00000000ae5c9724&gt;] 0xffffffffc030702d</span><br><span class="line">    [&lt;00000000afc3b54e&gt;] do_one_initcall+0x56&#x2F;0x2b0</span><br><span class="line">    [&lt;000000000724192e&gt;] do_init_module+0x56&#x2F;0x200</span><br><span class="line">    [&lt;00000000996ecfff&gt;] load_module+0x2348&#x2F;0x26e0</span><br><span class="line">    [&lt;000000004fa63e1a&gt;] __do_sys_finit_module+0xa0&#x2F;0xe0</span><br><span class="line">    [&lt;00000000cddcb6e5&gt;] do_syscall_64+0x33&#x2F;0x40</span><br><span class="line">    [&lt;00000000a0266b85&gt;] entry_SYSCALL_64_after_hwframe+0x44&#x2F;0xa9</span><br><span class="line">unreferenced object 0xffff8da0d2371000 (size 1024):</span><br><span class="line">  comm &quot;insmod&quot;, pid 3529, jiffies 4294873584 (age 562.798s)</span><br><span class="line">  hex dump (first 32 bytes):</span><br><span class="line">    6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class="line">    6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class="line">  backtrace:</span><br><span class="line">    [&lt;0000000079fd2c9c&gt;] 0xffffffffc030709c</span><br><span class="line">    [&lt;00000000afc3b54e&gt;] do_one_initcall+0x56&#x2F;0x2b0</span><br><span class="line">    [&lt;000000000724192e&gt;] do_init_module+0x56&#x2F;0x200</span><br><span class="line">    [&lt;00000000996ecfff&gt;] load_module+0x2348&#x2F;0x26e0</span><br><span class="line">    [&lt;000000004fa63e1a&gt;] __do_sys_finit_module+0xa0&#x2F;0xe0</span><br><span class="line">    [&lt;00000000cddcb6e5&gt;] do_syscall_64+0x33&#x2F;0x40</span><br><span class="line">    [&lt;00000000a0266b85&gt;] entry_SYSCALL_64_after_hwframe+0x44&#x2F;0xa9</span><br><span class="line">unreferenced object 0xffff8da0ca534000 (size 4096):</span><br><span class="line">  comm &quot;insmod&quot;, pid 3529, jiffies 4294873584 (age 562.862s)</span><br><span class="line">  hex dump (first 32 bytes):</span><br><span class="line">    6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class="line">    6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk</span><br><span class="line">  backtrace:</span><br><span class="line">    [&lt;000000000526120c&gt;] 0xffffffffc0307130</span><br><span class="line">    [&lt;00000000afc3b54e&gt;] do_one_initcall+0x56&#x2F;0x2b0</span><br><span class="line">    [&lt;000000000724192e&gt;] do_init_module+0x56&#x2F;0x200</span><br><span class="line">    [&lt;00000000996ecfff&gt;] load_module+0x2348&#x2F;0x26e0</span><br><span class="line">    [&lt;000000004fa63e1a&gt;] __do_sys_finit_module+0xa0&#x2F;0xe0</span><br><span class="line">    [&lt;00000000cddcb6e5&gt;] do_syscall_64+0x33&#x2F;0x40</span><br><span class="line">    [&lt;00000000a0266b85&gt;] entry_SYSCALL_64_after_hwframe+0x44&#x2F;0xa9</span><br><span class="line">unreferenced object 0xffffaa50801fb000 (size 4096):</span><br><span class="line">  comm &quot;insmod&quot;, pid 3529, jiffies 4294873584 (age 562.862s)</span><br><span class="line">  hex dump (first 32 bytes):</span><br><span class="line">    27 94 40 81 50 aa ff ff 27 04 00 00 00 00 00 00  &#39;.@.P...&#39;.......</span><br><span class="line">    7c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  |...............</span><br><span class="line">  backtrace:</span><br><span class="line">    [&lt;00000000854ee6a4&gt;] __vmalloc_node_range+0x236&#x2F;0x270</span><br><span class="line">    [&lt;00000000a355227b&gt;] __vmalloc_node+0x3f&#x2F;0x60</span><br><span class="line">    [&lt;0000000039b16a7e&gt;] 0xffffffffc0307149</span><br><span class="line">    [&lt;00000000afc3b54e&gt;] do_one_initcall+0x56&#x2F;0x2b0</span><br><span class="line">    [&lt;000000000724192e&gt;] do_init_module+0x56&#x2F;0x200</span><br><span class="line">    [&lt;00000000996ecfff&gt;] load_module+0x2348&#x2F;0x26e0</span><br><span class="line">    [&lt;000000004fa63e1a&gt;] __do_sys_finit_module+0xa0&#x2F;0xe0</span><br><span class="line">    [&lt;00000000cddcb6e5&gt;] do_syscall_64+0x33&#x2F;0x40</span><br><span class="line">    [&lt;00000000a0266b85&gt;] entry_SYSCALL_64_after_hwframe+0x44&#x2F;0xa9</span><br><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug#</span><br></pre></td></tr></table></figure>
<p>可以比较清楚的看到 可能leak的 object点，且有详细调用栈，排查起来十分方便</p>
<p>清除之前扫描结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# echo clear  &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;kmemleak</span><br><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# cat kmemleak</span><br><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug#</span><br></pre></td></tr></table></figure>

<h2 id="kmemleak-代码"><a href="#kmemleak-代码" class="headerlink" title="kmemleak 代码"></a>kmemleak 代码</h2><p>后续填坑</p>
<h2 id="kmemleak-overhead"><a href="#kmemleak-overhead" class="headerlink" title="kmemleak overhead"></a>kmemleak overhead</h2><p>当然假设我们场景允许 使能kmemleak之后，重新编译 kernel，也要关心 kmemleak 所带来的<br>overhead是否允许，如果你的场景本来就是一个高负载的已经80%多的CPU使用率了，然后开启<br>kmemleak,是很可能出问题的。</p>
<p>在 公司 一款三核心的 Cortex-A7 的产品中测试结果：<br>        disabled        enabled     Per Core增加%       换算成单核CPU%<br>User:     3.54%          7.63%          4.09%            12.27%<br>Sys:      10.68%         23.76%         13.08%           38.7%<br>Idle:     84.6%          67.68%         17.02%           -50.76%</p>
<p>在我自己 qemu 虚拟机中测试结果是：</p>
<pre><code>    disabled        enabled     Per Core增加%       换算成单核CPU%</code></pre>
<p>User:     3.54%          7.63%                           12.27%<br>Sys:      10.68%         23.76%                          38.7%<br>Idle:     84.6%          67.68%                          -50.76%</p>
<p>参考<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/dev-tools/kmemleak.html">内核文档</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-16T11:00:00.000Z" title="1/16/2021, 7:00:00 PM">2021-01-16</time>发表</span><span class="level-item"><time dateTime="2021-01-31T11:03:31.205Z" title="1/31/2021, 7:03:31 PM">2021-01-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">4 分钟读完 (大约585个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/16/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/page_owner%20%E5%AE%9A%E4%BD%8D%20buddy%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">page_owner 定位 buddy 内存泄漏</a></h1><div class="content"><h2 id="page-owner-原理"><a href="#page-owner-原理" class="headerlink" title="page_owner 原理"></a>page_owner 原理</h2><p>主要是通过给 每个分配出去的page 记录调用栈</p>
<h2 id="page-owner-使用"><a href="#page-owner-使用" class="headerlink" title="page_owner 使用"></a>page_owner 使用</h2><p>从mm/makefile 看，需要如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if [ $debug_page_owner &#x3D;&#x3D; 1 ]</span><br><span class="line">then</span><br><span class="line">## page_owner detect and panic start</span><br><span class="line">	echo &quot;CONFIG_STACKDEPOT&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">	echo &quot;CONFIG_PAGE_EXTENSION&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">	echo &quot;CONFIG_PAGE_OWNER&#x3D;y&quot; &gt;&gt; &#x2F;tmp&#x2F;.config</span><br><span class="line">## page_owner detect and panic end</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>重新编译之后，启动qemu, 需要加上 <code>page_owner=on</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-x86_64 \</span><br><span class="line">	-kernel &#x2F;tmp&#x2F;bzImage \</span><br><span class="line">	-hda &#x2F;home&#x2F;ubuntu&#x2F;myspace&#x2F;qemu_build&#x2F;stable_ubuntu.img \</span><br><span class="line">	-append &quot;root&#x3D;&#x2F;dev&#x2F;sda5 console&#x3D;ttyS0 crashkernel&#x3D;256M page_owner&#x3D;on&quot; \</span><br><span class="line">	-smp 4 \</span><br><span class="line">	-m 2048 \</span><br><span class="line">	--enable-kvm \</span><br><span class="line">	-net nic \</span><br><span class="line">	-net user,hostfwd&#x3D;tcp::2222-:22 \</span><br><span class="line">	--nographic \</span><br><span class="line">	-fsdev local,id&#x3D;fs1,path&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share,security_model&#x3D;none \</span><br><span class="line">	-device virtio-9p-pci,fsdev&#x3D;fs1,mount_tag&#x3D;host_share</span><br></pre></td></tr></table></figure>

<p>查看 <code>/sys/kernel/debug/page_owner</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# cat page_owner | wc -l</span><br><span class="line">4363829</span><br><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug#</span><br></pre></td></tr></table></figure>
<p>记录的信息非常多，然后需要一些工具来帮助检查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# cat page_owner &gt; &#x2F;home&#x2F;rlk&#x2F;page_owner.txt</span><br><span class="line">root@rlk-Standard-PC-i440FX-PIIX-1996:&#x2F;sys&#x2F;kernel&#x2F;debug# cp &#x2F;tmp&#x2F;share&#x2F;test_modules&#x2F;resource_leak&#x2F;page_alloc_leak&#x2F;page_owner_sort &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">stable_kernel@kernel: ~# page_owner_sort .&#x2F;page_owner.txt sorted_page_owner.txt</span><br><span class="line">loaded 398724</span><br><span class="line">sorting ....</span><br><span class="line">culling</span><br><span class="line">stable_kernel@kernel: ~# cat sorted_page_owner.txt| wc -l</span><br><span class="line">5470295</span><br><span class="line">stable_kernel@kernel: ~# cat page_owner.txt| wc -l</span><br><span class="line">5472954</span><br><span class="line">stable_kernel@kernel: ~#</span><br></pre></td></tr></table></figure>

<p>看一下详细信息，<code>order</code> <code>mask</code>详细信息都有，对于debug 页面内存泄露用处很大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">stable_kernel@kernel: ~# cat page_owner.txt | head -n 80</span><br><span class="line">Page allocated via order 2, mask 0xd20c1(GFP_DMA|__GFP_IO|__GFP_FS|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_NOMEMALLOC), pid 62, ts 121463164s</span><br><span class="line">PFN 1024 type Unmovable Block 2 type Unmovable Flags 0x10200(slab|head)</span><br><span class="line"> prep_new_page+0xcf&#x2F;0xf0</span><br><span class="line"> get_page_from_freelist+0xd8a&#x2F;0x1230</span><br><span class="line"> __alloc_pages_nodemask+0x170&#x2F;0x330</span><br><span class="line"> allocate_slab+0x24f&#x2F;0x2f0</span><br><span class="line"> ___slab_alloc+0x480&#x2F;0x6b0</span><br><span class="line"> __slab_alloc+0x50&#x2F;0x60</span><br><span class="line"> kmem_cache_alloc_trace+0x1fb&#x2F;0x230</span><br><span class="line"> sr_probe+0x213&#x2F;0x5e0</span><br><span class="line"> really_probe+0xd6&#x2F;0x2e0</span><br><span class="line"> driver_probe_device+0x4a&#x2F;0xa0</span><br><span class="line"> bus_for_each_drv+0x7c&#x2F;0xc0</span><br><span class="line"> __device_attach+0xe8&#x2F;0x150</span><br><span class="line"> bus_probe_device+0x9a&#x2F;0xb0</span><br><span class="line"> device_add+0x39b&#x2F;0x850</span><br><span class="line"> scsi_sysfs_add_sdev+0x89&#x2F;0x280</span><br><span class="line"> scsi_probe_and_add_lun+0x81e&#x2F;0xb90</span><br><span class="line"></span><br><span class="line">Page allocated via order 0, mask 0x0(), pid 1, ts 285099088 ns</span><br><span class="line">PFN 4096 type Unmovable Block 8 type Unmovable Flags 0x100000000000000()</span><br><span class="line"> register_early_stack+0x23&#x2F;0x60</span><br><span class="line"> init_page_owner+0x27&#x2F;0x290</span><br><span class="line"> kernel_init_freeable+0x158&#x2F;0x273</span><br><span class="line"> kernel_init+0x5&#x2F;0x101</span><br><span class="line"></span><br><span class="line">Page allocated via order 0, mask 0x0(), pid 1, ts 285099128 ns</span><br><span class="line">PFN 4097 type Unmovable Block 8 type Unmovable Flags 0x100000000000000()</span><br><span class="line"> register_early_stack+0x23&#x2F;0x60</span><br><span class="line"> init_page_owner+0x27&#x2F;0x290</span><br><span class="line"> kernel_init_freeable+0x158&#x2F;0x273</span><br><span class="line"> kernel_init+0x5&#x2F;0x101</span><br></pre></td></tr></table></figure>


<h2 id="page-owner-代码"><a href="#page-owner-代码" class="headerlink" title="page_owner 代码"></a>page_owner 代码</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个工具 运行 overhead较大，在线上可能不能开启，只能在debug时开启。</p>
<p>参考<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/vm/page_owner.html">内核文档</a><br>参考<a target="_blank" rel="noopener" href="https://lwn.net/Articles/121656/">LWN 文章</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T11:00:00.000Z" title="1/15/2021, 7:00:00 PM">2021-01-15</time>发表</span><span class="level-item"><time dateTime="2021-01-21T16:39:25.597Z" title="1/22/2021, 12:39:25 AM">2021-01-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">14 分钟读完 (大约2084个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/15/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F/">进程虚拟地址空间泄漏问题</a></h1><div class="content"><h2 id="虚拟内存泄漏"><a href="#虚拟内存泄漏" class="headerlink" title="虚拟内存泄漏"></a>虚拟内存泄漏</h2><p>一般情况我们说 内存泄漏，都是指的是物理内存泄漏，毕竟物理内存是实实在在的，一个进程泄漏了，那么整个系统中的可用内存就会变少。</p>
<p>但是linux的虚拟内存空间是各个进程之间相互隔离的，在arm64系统中 有 T,在 arm32系统中也有3G<br>多。但是否意味着这种 虚拟内存我们就不需要关心呢？</p>
<h2 id="尝试复现"><a href="#尝试复现" class="headerlink" title="尝试复现"></a>尝试复现</h2><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        char *p &#x3D; NULL;</span><br><span class="line">        for (i &#x3D; 0; i &lt; 1024 * 1024 * 64; i++) &#123;</span><br><span class="line">                p &#x3D; malloc(1024 * 1024);</span><br><span class="line">                if (!p) &#123;printf(&quot;malloc failed,p &#x3D; %p, i &#x3D; %d\n&quot;, p, i); break;&#125;</span><br><span class="line">                else    &#123;printf(&quot;malloc sucess.p &#x3D; %p, i &#x3D; %d\n&quot;, p, i);&#125;</span><br><span class="line">                usleep(1000 * 10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;malloc failed,just wait!!\n&quot;);</span><br><span class="line">        while(1) &#123;</span><br><span class="line">                usleep(1000 * 10);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次尝试需分配 1G的虚拟内存，但是不会去使用，也就是不会去申请物理内存</p>
<h2 id="x86-64-平台"><a href="#x86-64-平台" class="headerlink" title="x86_64 平台"></a>x86_64 平台</h2><p>我一开始尝试在腾讯云 服务器上复现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@130ubuntu: ~&#x2F;workspace&#x2F;test_modules&#x2F;resource_leak&#x2F;process_virtual_address_memleak# .&#x2F;a.out</span><br><span class="line">malloc sucess. p &#x3D; 0x7f8e3f5c6010, i &#x3D; 0</span><br><span class="line">malloc sucess. p &#x3D; 0x7f8e3f4c5010, i &#x3D; 1</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0x56771e4ba6e0, i &#x3D; 461827</span><br><span class="line">malloc sucess. p &#x3D; 0x56771e5ba6f0, i &#x3D; 461828</span><br><span class="line">[1]    2721866 killed     .&#x2F;a.out</span><br></pre></td></tr></table></figure>

<p>直到最后分配到 <code>461828 MB</code> 内存的时候，<code>a.out</code> 被OOM kill了。</p>
<p>到底是为啥呢？？？毕竟我也没有去往 <code>malloc</code> 的虚拟地址中写数据，也不应该会分配物理页面。<br>从 <code>top</code> 命令看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">top - 15:47:46 up 3 days, 15:06,  2 users,  load average: 0.24, 0.16, 0.10</span><br><span class="line">Tasks: 157 total,   1 running, 156 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  3.3 us,  3.6 sy,  0.0 ni, 92.7 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :   1987.9 total,     70.5 free,   1660.6 used,    256.8 buff&#x2F;cache</span><br><span class="line">MiB Swap:   2048.0 total,   1499.9 free,    548.1 used.    162.0 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">2783846 ubuntu    20   0  173.4g 683692   1380 S   0.3  33.6   0:06.86 a.out</span><br><span class="line">   1378 jenkins   20   0 2510448 176168   2924 S   0.7   8.7   7:05.12 java</span><br><span class="line">2779920 ubuntu    20   0  925684 107776  15196 S   1.0   5.3   0:21.10 node</span><br><span class="line">2703822 ubuntu    20   0 1611828  41268  11624 S   0.3   2.0   0:24.40 node</span><br><span class="line">2773158 ubuntu    20   0  702408  39436  12496 S   0.7   1.9   0:15.87</span><br></pre></td></tr></table></figure>

<p>已经分配了 <code>173G</code> 虚拟内存，但是同时可以发现 驻留在物理内存中的页面也达到了 <code>683692kb</code>.<br>这到底是什么？</p>
<p>通过对比 运行 <code>mytest</code> 前后的 <code>/proc/meminfo</code> 文件，发现差异主要在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">系统正常</span><br><span class="line">Active(anon):     243372 kB</span><br><span class="line">Inactive(anon):   267836 kB</span><br><span class="line"></span><br><span class="line">mytest运行之后</span><br><span class="line">Active(anon):     550888 kB</span><br><span class="line">Inactive(anon):   576840 kB</span><br></pre></td></tr></table></figure>
<p>说明确实是 mytest 消耗了大量的内存 用作匿名页面<br>接下来就需要查看具体是哪种页面消耗了物理内存了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;2798128# cat smaps | grep heap -A 40</span><br><span class="line">7fbca3ff9000-7fc69e600000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">Size:           41850908 kB</span><br><span class="line">KernelPageSize:        4 kB</span><br><span class="line">MMUPageSize:           4 kB</span><br><span class="line">Rss:              162844 kB</span><br><span class="line">Pss:              162844 kB</span><br><span class="line">Shared_Clean:          0 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:         0 kB</span><br><span class="line">Private_Dirty:    162844 kB</span><br><span class="line">Referenced:       162844 kB</span><br><span class="line">Anonymous:        162844 kB</span><br><span class="line">LazyFree:              0 kB</span><br><span class="line"></span><br><span class="line">此时top 输出</span><br><span class="line">top - 16:05:47 up 3 days, 15:24,  4 users,  load average: 0.14, 0.09, 0.10</span><br><span class="line">Tasks: 157 total,   1 running, 156 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  3.0 us,  2.7 sy,  0.0 ni, 94.0 id,  0.0 wa,  0.0 hi,  0.3 si,  0.0 st</span><br><span class="line">MiB Mem :   1987.9 total,    786.6 free,    917.0 used,    284.2 buff&#x2F;cache</span><br><span class="line">MiB Swap:   2048.0 total,   1512.2 free,    535.8 used.    912.0 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">2798128 ubuntu    20   0   45.1g 185412   1408 S   0.7   9.1   0:01.66 a.out</span><br><span class="line">......</span><br><span class="line">等待3min</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;2798128# cat smaps | grep heap -A 40</span><br><span class="line">7fb68e600000-7fc69e600000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">Size:           67371008 kB</span><br><span class="line">KernelPageSize:        4 kB</span><br><span class="line">MMUPageSize:           4 kB</span><br><span class="line">Rss:              262144 kB</span><br><span class="line">Pss:              262144 kB</span><br><span class="line">Shared_Clean:          0 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:         0 kB</span><br><span class="line">Private_Dirty:    262144 kB</span><br><span class="line">Referenced:       262144 kB</span><br><span class="line">Anonymous:        262144 kB</span><br><span class="line">LazyFree:              0 kB</span><br><span class="line">AnonHugePages:         0 kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此时top 输出</span><br><span class="line">top - 16:09:43 up 3 days, 15:27,  4 users,  load average: 0.24, 0.12, 0.10</span><br><span class="line">Tasks: 159 total,   1 running, 158 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.7 us,  3.4 sy,  0.0 ni, 90.3 id,  3.7 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :   1987.9 total,    585.4 free,   1072.9 used,    329.5 buff&#x2F;cache</span><br><span class="line">MiB Swap:   2048.0 total,   1523.9 free,    524.1 used.    754.9 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">2798128 ubuntu    20   0   67.9g 278604   1408 S   0.3  13.7   0:02.55 a.out</span><br></pre></td></tr></table></figure>

<p>可以看到虽然 没有往堆内存中写入数据，但是还是消耗了较多的物理内存？这是怎么回事？</p>
<ol>
<li><p>猜想一， 可能是一直连续分配虚拟内存，导致 <code>vma</code> 使用很多？<br>通过查看 /proc/slabinfo 和 /proc/pid/maps 看堆内存就一块，基本没有分块的，kernel中也有<br><code>vma_merge</code> 的操作，所以应该不是vma 占用的内存</p>
</li>
<li><p>??？<br>我还没有其他头绪，为什么会占用物理内存</p>
</li>
</ol>
<h2 id="arm32-平台"><a href="#arm32-平台" class="headerlink" title="arm32 平台"></a>arm32 平台</h2><p>然后想了想，x86_64平台可能是虚拟内存太大，复现时间成本有点高<br>就使用了公司的板子，重新编译了一遍，在一个 <code>arm32</code> 板子上运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">root@device_gls:&#x2F; # mytest</span><br><span class="line">malloc sucess. p &#x3D; 0xb6b00000, i &#x3D; 0</span><br><span class="line">malloc sucess. p &#x3D; 0xb6a00000, i &#x3D; 1</span><br><span class="line">malloc sucess. p &#x3D; 0xb6900000, i &#x3D; 2</span><br><span class="line">malloc sucess. p &#x3D; 0xb6800000, i &#x3D; 3</span><br><span class="line">malloc sucess. p &#x3D; 0xb6700000, i &#x3D; 4</span><br><span class="line">malloc sucess. p &#x3D; 0xb6600000, i &#x3D; 5</span><br><span class="line">malloc sucess. p &#x3D; 0xb6500000, i &#x3D; 6</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0x10380000, i &#x3D; 2663</span><br><span class="line">malloc sucess. p &#x3D; 0x10280000, i &#x3D; 2664</span><br><span class="line">malloc sucess. p &#x3D; 0x10180000, i &#x3D; 2665</span><br><span class="line">malloc sucess. p &#x3D; 0x10080000, i &#x3D; 2666</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0xff80000, i &#x3D; 2667</span><br><span class="line">malloc sucess. p &#x3D; 0xfe80000, i &#x3D; 2668</span><br><span class="line">malloc sucess. p &#x3D; 0xfd80000, i &#x3D; 2669</span><br><span class="line">malloc sucess. p &#x3D; 0xfc80000, i &#x3D; 2670</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0x4180000, i &#x3D; 2857</span><br><span class="line">malloc sucess. p &#x3D; 0x4080000, i &#x3D; 2858</span><br><span class="line">malloc sucess. p &#x3D; 0x3f80000, i &#x3D; 2859</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0x1080000, i &#x3D; 2906</span><br><span class="line">malloc sucess. p &#x3D; 0xf80000, i &#x3D; 2907</span><br><span class="line">malloc sucess. p &#x3D; 0xe80000, i &#x3D; 2908</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0x80000, i &#x3D; 2922</span><br><span class="line">malloc sucess. p &#x3D; 0xb6f80000, i &#x3D; 2923</span><br><span class="line">malloc sucess. p &#x3D; 0xb7080000, i &#x3D; 2924</span><br><span class="line">......</span><br><span class="line">malloc sucess. p &#x3D; 0xbe880000, i &#x3D; 3044</span><br><span class="line">malloc sucess. p &#x3D; 0xbe980000, i &#x3D; 3045</span><br><span class="line">malloc sucess. p &#x3D; 0xbea80000, i &#x3D; 3046</span><br><span class="line">malloc sucess. p &#x3D; 0xbed80000, i &#x3D; 3047</span><br><span class="line">malloc failed, p &#x3D; 0x0, i &#x3D; 3048</span><br><span class="line">malloc failed,just wait!!</span><br></pre></td></tr></table></figure>


<p>可以看到，<code>arm32</code> 平台在分配了 <code>3038MB</code> 虚拟内存之后，在分配第3039块1MB的内存时，由于虚拟地<br>址空间用完了，不能再继续分配虚拟内存？</p>
<p>可以看到此时 <code>mytest</code> 进程的地址空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">root@device_gls:&#x2F;proc&#x2F;1293 # cat maps</span><br><span class="line">00080000-7f580000 rw-p 00000000 00:00 0          [anon:libc_malloc]</span><br><span class="line">7f5cd000-7f5d0000 r-xp 00000000 103:0f 1523      &#x2F;system&#x2F;bin&#x2F;mytest</span><br><span class="line">7f5d0000-7f5d1000 r--p 00002000 103:0f 1523      &#x2F;system&#x2F;bin&#x2F;mytest</span><br><span class="line">7f5d1000-7f5d2000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">7f600000-b6d00000 rw-p 00000000 00:00 0          [anon:libc_malloc]</span><br><span class="line">b6d64000-b6d68000 r-xp 00000000 103:0f 1428      &#x2F;system&#x2F;lib&#x2F;libnetd_client.so</span><br><span class="line">b6d68000-b6d69000 r--p 00003000 103:0f 1428      &#x2F;system&#x2F;lib&#x2F;libnetd_client.so</span><br><span class="line">b6d69000-b6d6a000 rw-p 00004000 103:0f 1428      &#x2F;system&#x2F;lib&#x2F;libnetd_client.so</span><br><span class="line">b6d6a000-b6d8a000 r--s 00000000 00:0f 11859      &#x2F;dev&#x2F;__properties__</span><br><span class="line">b6d8a000-b6d8b000 rw-p 00000000 00:00 0          [anon:linker_alloc_vector]</span><br><span class="line">b6d8c000-b6d8d000 rw-p 00000000 00:00 0          [anon:linker_alloc_vector]</span><br><span class="line">b6d8d000-b6dac000 r-xp 00000000 103:0f 1421      &#x2F;system&#x2F;lib&#x2F;libm.so</span><br><span class="line">b6dac000-b6dad000 ---p 00000000 00:00 0</span><br><span class="line">b6dad000-b6dae000 r--p 0001f000 103:0f 1421      &#x2F;system&#x2F;lib&#x2F;libm.so</span><br><span class="line">b6dae000-b6daf000 rw-p 00020000 103:0f 1421      &#x2F;system&#x2F;lib&#x2F;libm.so</span><br><span class="line">b6daf000-b6e23000 r-xp 00000000 103:0f 1355      &#x2F;system&#x2F;lib&#x2F;libc.so</span><br><span class="line">b6e23000-b6e27000 r--p 00073000 103:0f 1355      &#x2F;system&#x2F;lib&#x2F;libc.so</span><br><span class="line">b6e27000-b6e2a000 rw-p 00077000 103:0f 1355      &#x2F;system&#x2F;lib&#x2F;libc.so</span><br><span class="line">b6e2a000-b6e34000 rw-p 00000000 00:00 0</span><br><span class="line">b6e34000-b6ebc000 r-xp 00000000 103:0f 1354      &#x2F;system&#x2F;lib&#x2F;libc++.so</span><br><span class="line">b6ebc000-b6ebd000 ---p 00000000 00:00 0</span><br><span class="line">b6ebd000-b6ec1000 r--p 00088000 103:0f 1354      &#x2F;system&#x2F;lib&#x2F;libc++.so</span><br><span class="line">b6ec1000-b6ec2000 rw-p 0008c000 103:0f 1354      &#x2F;system&#x2F;lib&#x2F;libc++.so</span><br><span class="line">b6ec2000-b6ec3000 rw-p 00000000 00:00 0</span><br><span class="line">b6ec3000-b6ec4000 r--p 00000000 00:00 0</span><br><span class="line">b6ec4000-b6ec5000 r--p 00000000 00:00 0          [anon:linker_alloc]</span><br><span class="line">b6ec5000-b6ec6000 rw-p 00000000 00:00 0          [anon:linker_alloc]</span><br><span class="line">b6ec6000-b6ec7000 rw-p 00000000 00:00 0          [anon:linker_alloc_vector]</span><br><span class="line">b6ec7000-b6ec8000 rw-p 00000000 00:00 0          [anon:linker_alloc_32]</span><br><span class="line">b6ec8000-b6ec9000 r--p 00000000 00:00 0          [anon:linker_alloc]</span><br><span class="line">b6ec9000-b6ee9000 r--s 00000000 00:0f 11859      &#x2F;dev&#x2F;__properties__</span><br><span class="line">b6ee9000-b6eea000 r--p 00000000 00:00 0</span><br><span class="line">b6eea000-b6eeb000 ---p 00000000 00:00 0</span><br><span class="line">b6eeb000-b6eed000 rw-p 00000000 00:00 0          [anon:thread signal stack]</span><br><span class="line">b6eed000-b6f0a000 r-xp 00000000 103:0f 170       &#x2F;system&#x2F;bin&#x2F;linker</span><br><span class="line">b6f0a000-b6f0b000 r--p 0001c000 103:0f 170       &#x2F;system&#x2F;bin&#x2F;linker</span><br><span class="line">b6f0b000-b6f0d000 rw-p 0001d000 103:0f 170       &#x2F;system&#x2F;bin&#x2F;linker</span><br><span class="line">b6f0d000-b6f0f000 rw-p 00000000 00:00 0</span><br><span class="line">b6f80000-beb80000 rw-p 00000000 00:00 0          [anon:libc_malloc]</span><br><span class="line">bed01000-bed22000 rw-p 00000000 00:00 0          [stack]</span><br><span class="line">bed80000-bee80000 rw-p 00000000 00:00 0          [anon:libc_malloc]</span><br><span class="line">bef66000-bef67000 r-xp 00000000 00:00 0          [sigpage]</span><br><span class="line">bef67000-bef68000 r--p 00000000 00:00 0          [vvar]</span><br><span class="line">bef68000-bef69000 r-xp 00000000 00:00 0          [vdso]</span><br><span class="line">ffff0000-ffff1000 r-xp 00000000 00:00 0          [vectors]</span><br><span class="line">root@device_gls:&#x2F;proc&#x2F;1293 #</span><br></pre></td></tr></table></figure>


<p>我们看 <code>libc_malloc</code> 区域的 的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00080000-7f580000 rw-p 00000000 00:00 0          [anon:libc_malloc]  &#x3D;&#x3D; 2037MB</span><br><span class="line">7f600000-b6d00000 rw-p 00000000 00:00 0          [anon:libc_malloc]  &#x3D;&#x3D; 887MB</span><br><span class="line">b6f80000-beb80000 rw-p 00000000 00:00 0          [anon:libc_malloc]  &#x3D;&#x3D; 124MB</span><br><span class="line">bed80000-bee80000 rw-p 00000000 00:00 0          [anon:libc_malloc]  &#x3D;&#x3D; 1MB</span><br></pre></td></tr></table></figure>
<p>总和是 <code>2037 + 887 + 124 + 1 = 3049MB</code></p>
<p>这是项目中一个实际的bug，场景是 直播盒子 做长跑测试的时候，每到7天左右，直播业务就会因<br>为malloc失败而导致失败，但是由于业务代码写的问题，没有检查 malloc返回值的原因，导致业<br>务应用会crash, 现象是空指针错误。。很难联想到是因为进程虚拟地址空间全部泄漏导致的问题。<br>业务的小伙伴差了一个多月都没有头绪。。</p>
<p>在 <code>arm32</code> 设备上，<br>User 14 + Nice 0 + Sys 49 + Idle 246 + IOW 1 + IRQ 0 + SIRQ 0 = 310</p>
<p>  PID PR CPU% S  #THR     VSS     RSS PCY UID      Name<br> 3592  0   0% S     1 3124044K   1688K  fg root     mytest</p>
<p>RSS 也占用了一些，但是远没 X86设备上夸张</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@ubuntu: ~&#x2F;workspace# cat &#x2F;tmp&#x2F;123 | grep Rss</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                  12 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                 256 kB</span><br><span class="line">Rss:                  16 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                  28 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                  64 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                 460 kB</span><br><span class="line">Rss:                  16 kB</span><br><span class="line">Rss:                  12 kB</span><br><span class="line">Rss:                  28 kB</span><br><span class="line">Rss:                 536 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                  16 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                  28 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                 116 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   8 kB</span><br><span class="line">Rss:                   8 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                   8 kB</span><br><span class="line">Rss:                   0 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   4 kB</span><br><span class="line">Rss:                   0 kB</span><br></pre></td></tr></table></figure>
<p>其中 malloc 的 rss 只占用 <code>256Kb</code>,大部分是 libc, libc++ libm的代码段占用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">7f680000-b6d80000 rw-p 00000000 00:00 0          [anon:libc_malloc]</span><br><span class="line">Name:           [anon:libc_malloc]</span><br><span class="line">Size:             908288 kB</span><br><span class="line">Rss:                 256 kB</span><br><span class="line">Pss:                 256 kB</span><br><span class="line">Shared_Clean:          0 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:         0 kB</span><br><span class="line">Private_Dirty:       256 kB</span><br><span class="line">Referenced:          256 kB</span><br><span class="line">Anonymous:           256 kB</span><br></pre></td></tr></table></figure>

<p>由此可见</p>
<ol>
<li><p>进程虚拟地址空间泄漏还是有可能会存在的，尽管可能概率非常低，对系统危害也比物理内存泄漏小很<br>多。但是一旦发生，他的危害对于业务本身也是致命的，必须重启业务或者系统来恢复。</p>
</li>
<li><p>编程习惯养好，一定需要检查函数返回值。</p>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T11:00:00.000Z" title="1/15/2021, 7:00:00 PM">2021-01-15</time>发表</span><span class="level-item"><time dateTime="2021-01-18T06:07:42.051Z" title="1/18/2021, 2:07:42 PM">2021-01-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">7 分钟读完 (大约992个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/15/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/">文件资源泄漏问题</a></h1><div class="content"><h2 id="资源泄漏"><a href="#资源泄漏" class="headerlink" title="资源泄漏"></a>资源泄漏</h2><p>资源泄漏在实际编程中是一不小心就会遇到的一个问题，最常见的就是 <code>内存泄漏</code>。<br>内存泄漏：对于短时间存在的进程，线程即使存在内存泄漏，往往也不会变现出来，开发人员也很难感知到。<br>但是一旦是长时间运行的进程，线程存在内存泄漏的问题，那将是一个灾难，要么过一会被OOM KILL，要么<br>自己重启，更严重的就是重启机器。</p>
<p>内存泄漏是指内存被分配出来，但是后续一直未使用，且失去了这个内存的引用，一直无法释放的问题。</p>
<p>但是除了最常见内存泄漏之外，还有其他各种资源泄漏的问题，比如这次的 <code>进程文件资源泄漏</code>。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>虽然是嵌入式平台，也有一些业务需要做压力测试连续几天到一个月不关机长时间跑测试。</p>
<p>某个业务在运行两天之后就会出现进程挂掉的问题。</p>
<h2 id="代码复现"><a href="#代码复现" class="headerlink" title="代码复现"></a>代码复现</h2><p>如果能用简单代码复现的问题，都不大</p>
<p><a target="_blank" rel="noopener" href="https://github.com/liulangrenaaa/test_modules/tree/main">代码</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#define DIR_NAME        &quot;&#x2F;tmp&#x2F;asdf&quot;</span><br><span class="line"></span><br><span class="line">int sync_dir(char *dir)</span><br><span class="line">&#123;</span><br><span class="line">        if(!dir) return -1;</span><br><span class="line">        int fd &#x3D; open(dir, O_ASYNC);</span><br><span class="line">        if (-1 &#x3D;&#x3D; fd) return -1;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int ret &#x3D; -1;</span><br><span class="line">        for (i &#x3D; 0; i &lt; 1024 * 1024 * 64; i++) &#123;</span><br><span class="line">                ret &#x3D; sync_dir(DIR_NAME);</span><br><span class="line">                if (ret)        printf(&quot;sync_dir failed. i &#x3D; %d, ret &#x3D; %d\n&quot;, i, ret);</span><br><span class="line">                else            printf(&quot;sync_dir sucess. i &#x3D; %d\n&quot;, i);</span><br><span class="line">                usleep(1000 * 10);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>嵌入式设备上的资源限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@device_gls:&#x2F;proc&#x2F;sys&#x2F;fs # cat file-nr</span><br><span class="line">800     0       21378</span><br><span class="line">root@device_gls:&#x2F;proc&#x2F;sys&#x2F;fs #</span><br></pre></td></tr></table></figure>
<p>意思是当前系统允许打开 <code>21378</code> 个文件，已经打开了 <code>800</code>个文件了</p>
<p>我选择用 <code>ubuntu</code> 系统去复现，先将 系统 fd上限制调制与设备一样的水平</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-max</span><br><span class="line">9223372036854775807</span><br><span class="line">tencent_clould@1ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# sudo su</span><br><span class="line">VM-0-11-ubuntu# echo 21378 &gt; file-max</span><br><span class="line">VM-0-11-ubuntu# exit</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-max</span><br><span class="line">21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs#</span><br></pre></td></tr></table></figure>

<p>尝试复现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@130ubuntu: ~&#x2F;workspace&#x2F;hexo_blog&#x2F;source&#x2F;_posts&#x2F;资源管理# .&#x2F;a.out</span><br><span class="line">sync_dir sucess. i &#x3D; 0</span><br><span class="line">sync_dir sucess. i &#x3D; 1</span><br><span class="line">....</span><br><span class="line">sync_dir sucess. i &#x3D; 5</span><br><span class="line">sync_dir sucess. i &#x3D; 18194</span><br><span class="line">sync_dir sucess. i &#x3D; 18195</span><br><span class="line">...</span><br><span class="line">sync_dir failed. i &#x3D; 18196, ret &#x3D; -1</span><br></pre></td></tr></table></figure>


<p>同时观察 <code> /proc/sys/fs/file-nr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">4704    0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">9824    0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">17760   0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">20224   0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">21024   0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">21216   0       21378</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">zsh: pipe failed: too many open files in system</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat file-nr</span><br><span class="line">zsh: pipe failed: too many open files in system</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>a.out</code> 最后无法 通过 <code>open</code> 打开文件了，且同时 <code>zsh</code> shell 都无法打开<br><code>file-nr</code>了。</p>
<p>与此同时，看到 <code>dmesg</code> 的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[57615.006011] VFS: file-max limit 21378 reached</span><br><span class="line">[57616.671617] VFS: file-max limit 21378 reached</span><br></pre></td></tr></table></figure>
<p>也可以比较容易定位出来。</p>
<p>这个问题困扰了当时开发同事很久，最后发现原来是 系统 <code>fd</code> 资源全部泄漏殆尽导致的。</p>
<h2 id="其他限制资源使用的方式"><a href="#其他限制资源使用的方式" class="headerlink" title="其他限制资源使用的方式"></a>其他限制资源使用的方式</h2><ol>
<li>其实还有其他方式限制资源 如 <code>ulimit</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# ulimit -a</span><br><span class="line">-t: cpu time (seconds)              unlimited</span><br><span class="line">-f: file size (blocks)              unlimited</span><br><span class="line">-d: data seg size (kbytes)          unlimited</span><br><span class="line">-s: stack size (kbytes)             8192</span><br><span class="line">-c: core file size (blocks)         0</span><br><span class="line">-m: resident set size (kbytes)      unlimited</span><br><span class="line">-u: processes                       7582</span><br><span class="line">-n: file descriptors                1024</span><br><span class="line">-l: locked-in-memory size (kbytes)  65536</span><br><span class="line">-v: address space (kbytes)          unlimited</span><br><span class="line">-x: file locks                      unlimited</span><br><span class="line">-i: pending signals                 7582</span><br><span class="line">-q: bytes in POSIX msg queues       819200</span><br><span class="line">-e: max nice                        0</span><br><span class="line">-r: max rt priority                 0</span><br><span class="line">-N 15:                              unlimited</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs#</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>/proc/pid/limits<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs# cat &#x2F;proc&#x2F;4833&#x2F;limits</span><br><span class="line">Limit                     Soft Limit           Hard Limit           Units</span><br><span class="line">Max cpu time              unlimited            unlimited            seconds</span><br><span class="line">Max file size             unlimited            unlimited            bytes</span><br><span class="line">Max data size             unlimited            unlimited            bytes</span><br><span class="line">Max stack size            8388608              unlimited            bytes</span><br><span class="line">Max core file size        0                    unlimited            bytes</span><br><span class="line">Max resident set          unlimited            unlimited            bytes</span><br><span class="line">Max processes             7582                 7582                 processes</span><br><span class="line">Max open files            1024                 1048576              files</span><br><span class="line">Max locked memory         67108864             67108864             bytes</span><br><span class="line">Max address space         unlimited            unlimited            bytes</span><br><span class="line">Max file locks            unlimited            unlimited            locks</span><br><span class="line">Max pending signals       7582                 7582                 signals</span><br><span class="line">Max msgqueue size         819200               819200               bytes</span><br><span class="line">Max nice priority         0                    0</span><br><span class="line">Max realtime priority     0                    0</span><br><span class="line">Max realtime timeout      unlimited            unlimited            us</span><br><span class="line">tencent_clould@ubuntu: &#x2F;proc&#x2F;sys&#x2F;fs#</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><code>/etc/security/limits.conf</code></li>
</ol>
<p>这里可以预先配置。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-09T02:00:40.000Z" title="1/9/2021, 10:00:40 AM">2021-01-09</time>发表</span><span class="level-item"><time dateTime="2021-01-14T16:53:25.527Z" title="1/15/2021, 12:53:25 AM">2021-01-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">31 分钟读完 (大约4592个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/09/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/systemTap/How%20to%20Use%20system%20Tap/">How to Use system Tap</a></h1><div class="content"><p>SystemTap允许使用者监控Linux系统当前的运行情况，以便进一步分析。这将有助于运维或开发人员缉查bug或性能问题的罪魁祸首。<br>SystemTap提供了一门领域特定语言，使得用户可以编写自定义脚本，调查和监控各种内核函数、系统调用，<br>和其它发生在内核空间的事件。</p>
<p>就此而言，SystemTap不仅仅是个工具，它是一个让你能够自定义内核取证和监控工具的生态系统。</p>
<p>当前版本的SystemTap提供的探测内核空间事件的众多选项，可以在不同版本的内核下使用。<br>然而，SystemTap对探测用户空间事件的支持依赖于内核的支持（需要uprobe机制），而多数内核缺乏这一支持。<br>结果是，仅有部分内核上的SystemTap版本支持用户空间探测。</p>
<h2 id="安装SystemTap"><a href="#安装SystemTap" class="headerlink" title="安装SystemTap"></a>安装SystemTap</h2><p>安装 systemtap 软件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@ubuntu: &#x2F;var&#x2F;crash# sudo apt install systemtap</span><br><span class="line">Inspiron-5548@ubuntu: &#x2F;var&#x2F;crash# sudo apt install systemtap-runtime</span><br></pre></td></tr></table></figure>

<p>安装 kernel debug info</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@ubuntu: &#x2F;var&#x2F;crash# sudo apt install systemtap</span><br><span class="line">Inspiron-5548@ubuntu: &#x2F;var&#x2F;crash# sudo apt install systemtap-runtime</span><br></pre></td></tr></table></figure>
<h2 id="SystemTap-可以用来干什么"><a href="#SystemTap-可以用来干什么" class="headerlink" title="SystemTap 可以用来干什么"></a>SystemTap 可以用来干什么</h2><p>SystemTap允许用户仅需编写和重用简单的脚本即可获取Linux繁多的运行数据。通过SystemTap脚本，<br>你可以又好又快地提取数据、过滤数据、汇总数据。诊断复杂的性能问题（或功能问题）再也不是难事。<br>整个SystemTap脚本所做的，无非就是声明感兴趣的事件，然后添加对应的处理程序。当SystemTap脚本运行时，SystemTap会监控声明的事件；<br>一旦事件发生，Linux内核会临时切换到对应的处理程序，完成后再重拾原先的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可供监控的事件种类繁多：进入&#x2F;退出某个函数，定时器到期，会话终止，等等。处理程序由一组SystemTap语句构成，指明事件发生后要做的工作。</span><br><span class="line">其中包括从事件上下文中提取数据，存储到内部变量中，输出结果。</span><br></pre></td></tr></table></figure>

<h2 id="SystemTap-使用"><a href="#SystemTap-使用" class="headerlink" title="SystemTap 使用"></a>SystemTap 使用</h2><h3 id="最简单的一行代码"><a href="#最简单的一行代码" class="headerlink" title="最简单的一行代码"></a>最简单的一行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@127ubuntu: ~&#x2F;workspace# echo &quot;probe timer.s(1) &#123;exit()&#125;&quot; | sudo stap -v -</span><br><span class="line"></span><br><span class="line">Pass 1: parsed user script and 476 library scripts using 108312virt&#x2F;90968res&#x2F;7440shr&#x2F;83392data kb, in 260usr&#x2F;30sys&#x2F;315real ms.</span><br><span class="line">Pass 2: analyzed script: 1 probe, 1 function, 0 embeds, 0 globals using 109896virt&#x2F;92776res&#x2F;7688shr&#x2F;84976data kb, in 10usr&#x2F;0sys&#x2F;9real ms.</span><br><span class="line">Pass 3: translated to C into &quot;&#x2F;tmp&#x2F;stappbkhvF&#x2F;stap_629b1ee8abda600005ad17f270124c66_947_src.c&quot; using 110032virt&#x2F;92776res&#x2F;7688shr&#x2F;85112data kb, in 0usr&#x2F;0sys&#x2F;1real ms.</span><br><span class="line">Pass 4: compiled C into &quot;stap_629b1ee8abda600005ad17f270124c66_947.ko&quot; in 15530usr&#x2F;2160sys&#x2F;17963real ms.</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">Pass 5: run completed in 20usr&#x2F;30sys&#x2F;1459real ms.</span><br><span class="line">Inspiron-5548@ubuntu: ~&#x2F;workspace#</span><br></pre></td></tr></table></figure>
<p>可以看出 SystemTap 脚本运行需要结果5个步骤，在加载 SystemTap脚本过程(生成ko)的时候，SystemTap 耗时较多，尤其是CPU资源。</p>
<p>SystemTap脚本运行时，会启动一个对应的SystemTap会话。整个会话大致流程如下：</p>
<p>首先，SystemTap会检查脚本中用到的tapset，确保它们都存在于tapset库中（通常是/usr/share/systemtap/tapset/）。然后SystemTap会把找到的tapset替换成在tapset库中对应的定义。<br>tapset是tap（听诊器）的集合，指一些预定义的SystemTap事件或函数。<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/tapsets/">完整的tapset列表</a></p>
<p>SystemTap接着会把脚本转化成C代码，运行系统的C编译器编译出一个内核模块。完成这一步的工具包含在systemtap包中<br>SystemTap随即加载该模块，并启用脚本中所有的探针（包括事件和对应的处理程序）。这一步由system-runtime包的staprun完成。<br>每当被监控的事件发生，对应的处理程序就会被执行。<br>一旦SystemTap会话终止，探针会被禁用，内核模块也会被卸载。<br>这一串流程皆始于一个简单的命令行程序：stap。这个程序包揽了SystemTap主要的功能。</p>
<h3 id="脚本如何编写"><a href="#脚本如何编写" class="headerlink" title="脚本如何编写"></a>脚本如何编写</h3><p>在大多数情况下，SystemTap脚本是每个SystemTap会话的基石。SystemTap脚本决定了需要收集的信息类型，也决定了对收集到的信息的处理方式。<br>SystemTap脚本由两部分组成：事件和处理程序。<br>一旦SystemTap会话准备就绪，SystemTap会监控操作系统中特定的事件，并在事件发生的时候触发对应的处理程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个事件和它对应的处理程序合称探针。一个SystemTap脚本可以有多个探针。 一个探针的处理程序部分通常称之为探针主体（probe body）</span><br></pre></td></tr></table></figure>

<p>与应用开发的方式类比，使用事件和处理程序就像在程序的特定位置插入打日志的语句。每当程序运行时，这些日志会帮助你查看程序执行的流程。<br>但是SystemTasp脚本允许你在无需重新编译代码，即可插入检测指令，而且处理程序也不限于单纯地打印数据。<br>事件会触发对应的处理程序；对应的处理程序记录下感兴趣的数据，并以你指定的格式输出。</p>
<p>SystemTap脚本的后缀是.stp，并以这样的语句表示一个探针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">probe   event &#123;statements&#125;</span><br></pre></td></tr></table></figure>

<p>SystemTap支持给一个探针指定多个事件；每个事件以逗号隔开。<br>如果给某一个探针指定了多个事件，只要其中一个事件发生，SystemTap就会执行对应的处理程序。<br>每个探针有自己对应的语句块。语句块由花括号 {} 括住，包含事件发生时需要执行的所有语句。<br>SystemTap会顺序执行这些语句；语句间通常不需要特殊的分隔符或终止符。</p>
<p>SystemTap还允许你编写函数来提取探针间公共的逻辑。<br>所以，与其在多个探针间复制粘贴重复的语句，你不如把它们放入函数中，就像函数调用一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function function_name(arguments) &#123;statements&#125;</span><br><span class="line"></span><br><span class="line">probe event &#123;function_name(arguments)&#125;</span><br></pre></td></tr></table></figure>
<p>当探针被触发时，function_name中的语句会被执行。arguments是传递给函数的可选的入参。</p>
<h3 id="SystemTap-事件"><a href="#SystemTap-事件" class="headerlink" title="SystemTap 事件"></a>SystemTap 事件</h3><p>我们还需要了解SystemTap 事件，这里主要分为 <code>同步事件</code> 和 <code>异步事件</code>。</p>
<h4 id="同步事件"><a href="#同步事件" class="headerlink" title="同步事件"></a>同步事件</h4><p>同步事件会在任意进程执行到内核特定位置时触发。你可以用它来作为其它事件的参照点，毕竟同步事件有着清晰的上下文信息。<br>包括：</p>
<p><code>syscall.system_call</code></p>
<p>进入名为system_call的系统调用。如果想要监控的是退出某个系统调用的事件，在后面添加.return。举个例子，要想监控进入和退出系统调用close的事件，应该使用syscall.close和syscall.close.return。</p>
<p><code>vfs.file_operation</code></p>
<p>进入虚拟文件系统（VFS）名为file_operation的文件操作。跟系统调用事件一样，在后面添加.return可以监控对应的退出事件。 译注：file_operation取值的范畴，取决于当前内核中struct file_operations的定义的操作.</p>
<p><code>kernel.function(&quot;function&quot;)</code></p>
<p>进入名为function的内核函数。举个例子，kernel.function(“sys_open”)即内核函数sys_open被调用时所触发的事件。同样，kernel.function(“sys_open”).return会在sys_open函数调用返回时被触发。</p>
<p>在定义探测事件时，可以使用像*这样的通配符。你也可以用内核源码文件名限定要跟踪的函数。看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">probe kernel.function(&quot;*@net&#x2F;socket.c&quot;) &#123; &#125;</span><br><span class="line">probe kernel.function(&quot;*@net&#x2F;socket.c&quot;).return &#123; &#125;</span><br></pre></td></tr></table></figure>


<p><code>kernel.trace(&quot;tracepoint&quot;)</code><br>到达名为tracepoint的静态内核探测点（tracepoint）。较新的内核（&gt;= 2.6.30）包含了特定事件的检测代码。这些事件一般会被标记成静态内核探测点。一个例子是，kernel.trace(“kfree_skb”)表示内核释放了一个网络缓冲区的事件。（译注：想知道当前内核设置了哪些静态内核探测点吗？你需要运行sudo perf list。）</p>
<p><code>module(&quot;module&quot;).function(&quot;function&quot;)</code></p>
<p>进入指定模块module的函数function。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">probe module(&quot;ext3&quot;).function(&quot;*&quot;) &#123; &#125;</span><br><span class="line">probe module(&quot;ext3&quot;).function(&quot;*&quot;).return &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h4><p>异步事件跟特定的指令或代码的位置无关。 这部分事件主要包含计数器、定时器和其它类似的东西。</p>
<p><code>begin</code></p>
<p>SystemTap会话的启动事件，会在脚本开始时触发。</p>
<p><code>end</code></p>
<p>SystemTap会话的结束事件，会在脚本结束时触发。</p>
<p><code>timer events</code></p>
<p>用于周期性执行某段处理程序。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">probe timer.s(4) &#123; printf(&quot;hello world\n&quot;) &#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，每隔4秒就会输出hello world。还可以使用其它规格的定时器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timer.ms(milliseconds)</span><br><span class="line">timer.us(microseconds)</span><br><span class="line">timer.ns(nanoseconds)</span><br><span class="line">timer.hz(hertz)</span><br><span class="line">timer.jiffies(jiffies)</span><br></pre></td></tr></table></figure>

<p>定时事件总是跟其它事件搭配使用。其它事件负责收集信息，而定时事件定期输出当前状况，让你看到数据随时间的变化情况。</p>
<h3 id="SystemTap-处理程序"><a href="#SystemTap-处理程序" class="headerlink" title="SystemTap 处理程序"></a>SystemTap 处理程序</h3><p>有了事件之后，我们还需要在事件发生之后进行处理。</p>
<p>example1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">probe begin</span><br><span class="line">&#123;</span><br><span class="line">  printf (&quot;hello world\n&quot;)</span><br><span class="line">  exit ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SystemTap脚本会一直运行，直到执行了exit()函数。如果你想中途退出一个脚本，可以用Ctrl+c中断。<br>这是一个异步事件 <code>begin</code> 之后开始打印 一个字符串.</p>
<p><code>printf</code> 是一个标准输出函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf (&quot;format string\n&quot;, arguments)</span><br></pre></td></tr></table></figure>


<p>example2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">probe syscall.open</span><br><span class="line">&#123;</span><br><span class="line">  printf (&quot;%s(%d) open\n&quot;, execname(), pid())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &#39; probe syscall.open &#123;  printf (&quot;%s(%d) open\n&quot;, execname(), pid()) &#125;&#39; | sudo stap -v -</span><br></pre></td></tr></table></figure>
<p>example2中 SystemTap会在每次open被调用时，输出调用程序的名字和PID。</p>
<p>该探针输出的结果看上去会是这样(not in zsh, in bash)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:~&#x2F;workspace$ echo &#39; probe syscall.open &#123;  printf (&quot;%s(%d) open\n&quot;, execname(), pid()) &#125;&#39; | sudo stap -v -</span><br><span class="line">Pass 1: parsed user script and 476 library scripts using 108308virt&#x2F;90696res&#x2F;7172shr&#x2F;83388data kb, in 290usr&#x2F;40sys&#x2F;364real ms.</span><br><span class="line">Pass 2: analyzed script: 4 probes, 5 functions, 97 embeds, 4 globals using 110292virt&#x2F;93060res&#x2F;7724shr&#x2F;85372data kb, in 230usr&#x2F;330sys&#x2F;575real</span><br><span class="line"> ms.</span><br><span class="line">Pass 3: using cached &#x2F;root&#x2F;.systemtap&#x2F;cache&#x2F;4c&#x2F;stap_4cd2c557b5457e5f955c640275432033_64778.c</span><br><span class="line">Pass 4: using cached &#x2F;root&#x2F;.systemtap&#x2F;cache&#x2F;4c&#x2F;stap_4cd2c557b5457e5f955c640275432033_64778.ko</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">rg(25671) open</span><br><span class="line">rg(25671) open</span><br><span class="line">rg(25671) open</span><br><span class="line">rg(25671) open</span><br><span class="line">rg(25671) open</span><br></pre></td></tr></table></figure>

<p>下面是常用的 SystemTap 内建函数：</p>
<p><code>tid()</code></p>
<p>当前的tid（thread id）。</p>
<p><code>uid()</code></p>
<p>当前的uid。</p>
<p><code>cpu()</code></p>
<p>当前的CPU号</p>
<p><code>gettimeofday_s()</code></p>
<p>自epoch以来的秒数</p>
<p><code>ctime()</code></p>
<p>将上一个函数返回的秒数转化成时间字符串</p>
<p><code>pp()</code></p>
<p>返回描述当前处理的探测点的字符串</p>
<p><code>thread_indent()</code></p>
<p><code>name</code></p>
<p>返回系统调用的名字。这个变量只能在syscall.system_call触发的处理程序中使用。</p>
<p><code>target()</code></p>
<p>当你通过stap script -x PID或stap script -c command来执行某个脚本script时，target()会返回你指定的PID或命令名。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">probe syscall.* &#123;</span><br><span class="line">  if (pid() &#x3D;&#x3D; target())</span><br><span class="line">    printf(&quot;%s\n&quot;, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo &#39; probe syscall.* &#123; if (pid() &#x3D;&#x3D; target()) printf(&quot;%s\n&quot;, name) &#125;&#39; | sudo stap -v -</span><br></pre></td></tr></table></figure>
<p>这个 SystemTap 脚本使用了通配符 probe了所以系统调用，在对脚本解析，编译成为 kernel module ko的时候尤其耗时，<br>在我 I5 5200U的机器上居然准备工作做了进1min…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">top - 12:38:07 up 12:53,  2 users,  load average: 2.56, 1.77, 1.14</span><br><span class="line">任务: 277 total,   5 running, 271 sleeping,   0 stopped,   1 zombie</span><br><span class="line">%Cpu(s): 10.0 us, 17.6 sy,  0.0 ni, 66.9 id,  0.0 wa,  0.0 hi,  5.5 si,  0.0 st</span><br><span class="line">MiB Mem :   3658.2 total,    196.4 free,   2043.1 used,   1418.8 buff&#x2F;cache</span><br><span class="line">MiB Swap:   2048.0 total,   1572.1 free,    475.9 used.    986.8 avail Mem</span><br><span class="line"></span><br><span class="line"> 进程号 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">  54775 root      20   0  171592 154320  18248 R  99.7   4.1   1:05.72 stap</span><br><span class="line">    932 ubuntu    20   0 1750472  40364  14900 S   3.7   1.1  11:16.15 Xorg</span><br><span class="line">   1279 ubuntu    20   0 4777288 218332  57988 S   3.0   5.8  12:57.76 gnome-shell</span><br><span class="line">   2458 ubuntu    20   0 4633228 103048  65556 R   3.0   2.8   0:10.23 chrome</span><br><span class="line">   1747 ubuntu    20   0  987308  43280  31604 S   1.7   1.2   0:46.33 gnome-terminal-</span><br><span class="line">   2371 ubuntu    20   0 1342876 232676  99800 S   0.7   6.2   8:23.72 chrome</span><br><span class="line">     18 root      20   0       0      0      0 S   0.3   0.0   0:01.14 ksoftirqd&#x2F;1</span><br><span class="line">     30 root      20   0       0      0      0 S   0.3   0.0   0:00.87 ksoftirqd&#x2F;3</span><br><span class="line">Inspiron-5548@ubuntu: ~&#x2F;workspace&#x2F;linux-stable&#x2F;drivers#</span><br></pre></td></tr></table></figure>
<p>输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:~&#x2F;workspace$ echo &#39; probe syscall.* &#123; if (pid() &#x3D;&#x3D; target()) printf(&quot;%s\n&quot;, name) &#125;&#39; | sudo stap -v -x 2371 -</span><br><span class="line">Pass 1: parsed user script and 476 library scripts using 108312virt&#x2F;90872res&#x2F;7344shr&#x2F;83392data kb, in 510usr&#x2F;40sys&#x2F;559real ms.</span><br><span class="line">qWARNING: cross-file global variable reference to identifier &#39;syscall_string_trunc&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;syscalls_cfg_trunc.s</span><br><span class="line">tp:3:8 from: identifier &#39;syscall_string_trunc&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;sysc_add_key.stp:19:59</span><br><span class="line"> source:                         user_buffer_quoted(payload_uaddr, plen, syscall_string_trunc),</span><br><span class="line">                                                                         ^</span><br><span class="line">        in expansion of macro: operator &#39;@_SYSCALL_ADD_KEY_ARGSTR&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;sysc_add_key.stp:72:2</span><br><span class="line"> source:        @_SYSCALL_ADD_KEY_ARGSTR</span><br><span class="line">                ^</span><br><span class="line">WARNING: cross-file global variable reference to identifier &#39;syscall_string_trunc&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;syscalls_cfg_trunc.st</span><br><span class="line">p:3:8 from: identifier &#39;syscall_string_trunc&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;sysc_mount.stp:31:46</span><br><span class="line"> source:        data &#x3D; user_string_n_quoted(pointer_arg(5), syscall_string_trunc)</span><br><span class="line">                                                            ^</span><br><span class="line">WARNING: cross-file global variable reference to identifier &#39;syscall_string_trunc&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;syscalls_cfg_trunc.st</span><br><span class="line">p:3:8 from: identifier &#39;syscall_string_trunc&#39; at :23:49</span><br><span class="line"> source:        buf_str &#x3D; user_buffer_quoted(buf_uaddr, count, syscall_string_trunc)</span><br><span class="line">                                                               ^</span><br><span class="line">        in expansion of macro: operator &#39;@_SYSCALL_WRITE_REGARGS&#39; at &#x2F;usr&#x2F;share&#x2F;systemtap&#x2F;tapset&#x2F;linux&#x2F;sysc_write.stp:100:2</span><br><span class="line"> source:        @_SYSCALL_WRITE_REGARGS</span><br><span class="line">                ^</span><br><span class="line">Pass 2: analyzed script: 853 probes, 29 functions, 100 embeds, 5 globals using 129252virt&#x2F;113636res&#x2F;9172shr&#x2F;104332data kb, in 35560usr&#x2F;79740s</span><br><span class="line">ys&#x2F;116322real ms.</span><br><span class="line">Pass 3: using cached &#x2F;root&#x2F;.systemtap&#x2F;cache&#x2F;e2&#x2F;stap_e2b35608bd8c0499c68f451dc8b09a85_432536.c</span><br><span class="line">Pass 4: using cached &#x2F;root&#x2F;.systemtap&#x2F;cache&#x2F;e2&#x2F;stap_e2b35608bd8c0499c68f451dc8b09a85_432536.ko</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">recvmsg</span><br><span class="line">write</span><br><span class="line">write</span><br><span class="line">epoll_wait</span><br><span class="line">epoll_wait</span><br><span class="line">epoll_wait</span><br><span class="line">recvmsg</span><br><span class="line">read</span><br><span class="line">sendto</span><br><span class="line">futex</span><br><span class="line">recvmsg</span><br><span class="line">recvmsg</span><br><span class="line">recvmsg</span><br><span class="line">poll</span><br><span class="line">recvmsg</span><br><span class="line">recvmsg</span><br></pre></td></tr></table></figure>



<h3 id="SystemTap-处理程序的基本结构"><a href="#SystemTap-处理程序的基本结构" class="headerlink" title="SystemTap 处理程序的基本结构"></a>SystemTap 处理程序的基本结构</h3><p>SystemTap 在处理程序中 它们的语法基本上类似于C或awk。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>处理程序里面当然可以使用变量，你所需的不过是给它取个好名字，把函数或表达式的值赋给它，然后就可以使用它了。<br>SystemTap可以自动判定变量的类型。举个例子，如果你用gettimeofday_s()给变量foo赋值，那么foo就是数值类型的，<br>可以在printf()中通过%d输出。</p>
<p>变量默认只能在其所定义的探针内可用。这意味着变量的生命周期仅仅是处理程序的某次运行。<br>不过你也可以在探针外定义变量，并使用global修饰它们，这样就能在探针间共享变量了。 ⁠</p>
<p>example1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">global count_jiffies, count_ms</span><br><span class="line">probe timer.jiffies(100) &#123; count_jiffies ++ &#125;</span><br><span class="line">probe timer.ms(100) &#123; count_ms ++ &#125;</span><br><span class="line">probe timer.ms(12345)</span><br><span class="line">&#123;</span><br><span class="line">  hz&#x3D;(1000*count_jiffies) &#x2F; count_ms</span><br><span class="line">  printf (&quot;jiffies:ms ratio %d:%d &#x3D;&gt; CONFIG_HZ&#x3D;%d\n&quot;,</span><br><span class="line">    count_jiffies, count_ms, hz)</span><br><span class="line">  exit ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>example1 中 timer-jiffies.stp 通过累加jiffies和milliseconds，来求出内核的CONFIG_HZ配置。<br>global语句使得count_jiffies和count_ms在每个探针中可用。</p>
<h4 id="目标变量-Target-Variables"><a href="#目标变量-Target-Variables" class="headerlink" title="目标变量(Target Variables)"></a>目标变量(Target Variables)</h4><p>跟内核代码相关的事件，如kernel.function(“function”)和kernel.statement(“statement”)，<br>允许使用目标变量获取这部分代码中可访问到的变量的值。<br>你可以使用-L选项来列出特定探测点下可用的目标变量。<br>如果已经安装了内核调试信息，你可以通过这个命令获取vfs_read中可用的目标变量</p>
<p>由于 我当前笔记本环境问题，暂时没法使用这个，会报错，后续补充</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:&#x2F;etc&#x2F;apt$ sudo stap -L &#39;kernel.function(&quot;vfs_read&quot;)&#39;</span><br><span class="line">Tip: &#x2F;usr&#x2F;share&#x2F;doc&#x2F;systemtap&#x2F;README.Debian should help you get started.</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:&#x2F;etc&#x2F;apt$ sudo stap -e &#39;probe kernel.function(&quot;vfs_read&quot;) &#123;</span><br><span class="line">&gt;            printf (&quot;current files_stat max_files: %d\n&quot;,</span><br><span class="line">&gt;                    @var(&quot;[email protected]&#x2F;file_table.c&quot;)-&gt;max_files);</span><br><span class="line">&gt;            exit(); &#125;&#39;</span><br><span class="line">semantic error: while resolving probe point: identifier &#39;kernel&#39; at &lt;input&gt;:1:7</span><br><span class="line">        source: probe kernel.function(&quot;vfs_read&quot;) &#123;</span><br><span class="line">                      ^</span><br><span class="line"></span><br><span class="line">semantic error: missing x86_64 kernel&#x2F;module debuginfo [man warning::debuginfo] under &#39;&#x2F;lib&#x2F;modules&#x2F;5.4.0-58-generic&#x2F;build&#39;</span><br><span class="line"></span><br><span class="line">Pass 2: analysis failed.  [man error::pass2]</span><br><span class="line">Tip: &#x2F;usr&#x2F;share&#x2F;doc&#x2F;systemtap&#x2F;README.Debian should help you get started.</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:&#x2F;etc&#x2F;apt$</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Inspiron-5548@ubuntu: ~&#x2F;workspace&#x2F;linux-stable&#x2F;drivers# stap -l &#39;syscall.*&#39;</span><br><span class="line">syscall.accept</span><br><span class="line">syscall.accept4</span><br><span class="line">syscall.accesso</span><br><span class="line">syscall.acct</span><br><span class="line">syscall.add_key</span><br><span class="line">syscall.adjtimex</span><br><span class="line">syscall.alarm</span><br><span class="line">syscall.arch_prctl</span><br></pre></td></tr></table></figure>


<h4 id="整齐打印目标变量（Pretty-Printing-Target-Variables）"><a href="#整齐打印目标变量（Pretty-Printing-Target-Variables）" class="headerlink" title="整齐打印目标变量（Pretty Printing Target Variables）"></a>整齐打印目标变量（Pretty Printing Target Variables）</h4><p>某些场景中，我们可能需要输出当前可访问的各种变量，以便于记录底层的变化。SystemTap提供了一些操作，可以生成描述特定目标变量的字符串：</p>
<p><code>$$vars</code></p>
<p>输出作用域内每个变量的值。等价于sprintf(“parm1=%x … parmN=%x var1=%x … varN=%x”, parm1, …, parmN, var1, …, varN)。如果变量的值在运行时找不到，输出=?。</p>
<p><code>$$locals</code></p>
<p>同<code>$$vars</code>，只输出本地变量。</p>
<p><code>$$parms</code></p>
<p>同<code>$$vars</code>，只输出函数入参。</p>
<p><code>$$return</code></p>
<p>仅在带return的探针中可用。如果被监控的函数有返回值，它等价于sprintf(“return=%x”, $return)，否则为空字符串。</p>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>有些时候，你写的SystemTap脚本较为复杂，可能需要用上条件语句。SystemTap支持C风格的条件语句，另外还支持foreach (VAR in ARRAY) {}形式的遍历。</p>
<h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p>通过$或@加个数字的形式可以访问对应位置的命令行参数。用$会把用户输入当作整数，用@会把用户输入当作字符串。</p>
<p>probe kernel.function(@1) { }<br>probe kernel.function(@1).return { }<br>上面的脚本期望用户把要监控的函数作为命令行参数传递进来。你可以让脚本接受多个命令行参数，分别命名为@1，@2等等，按用户输入的次序逐个对应。</p>
<h2 id="Tapsets"><a href="#Tapsets" class="headerlink" title="Tapsets"></a>Tapsets</h2><p>tapsets是一些包含常用的探针和函数的内置脚本，你可以在SystemTap脚本中复用它们。</p>
<p>当用户运行一个SystemTap脚本时，SystemTap会检测脚本中的事件和处理程序，并在翻译脚本成C代码之前，加载用到的tapset。<br>就像SystemTap脚本一样，tapset的拓展名也是.stp。<br>默认情况下tapset位于/usr/share/systemtap/tapset/。</p>
<p>跟SystemTap脚本不同的是，tapset不能被直接运行；它只能作为库使用。<br>tapset库让用户能够在更高的抽象层次上定义事件和函数。<br>tapset提供了一些常用的内核函数的别名，这样用户就不需要记住完整的内核函数名了（尤其是有些函数名可能会因内核版本的不同而不同）。<br>另外tapset也提供了常用的辅助函数，比如之前我们见过的thread_indent()。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SystemTap 使用过程中发现 他解析编译极其慢，很耗费 CPU资源，最好做到一次解析编译模块，可以到处<br>部署，实际SystemTap 也已经支持了这样的做法。</p>
<p>参考<a target="_blank" rel="noopener" href="https://spacewander.gitbooks.io/systemtapbeginnersguide_zh/content/2_3_RunningSystemTapScripts.html">SystemTap 内核文档</a></p>
<p>参考 <a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html-single/systemtap_beginners_guide/index">RedHat systemTap 文档</a></p>
<p>参考 <a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide/index.html">文档</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-07T12:00:40.000Z" title="1/7/2021, 8:00:40 PM">2021-01-07</time>发表</span><span class="level-item"><time dateTime="2021-01-14T16:53:25.527Z" title="1/15/2021, 12:53:25 AM">2021-01-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">4 分钟读完 (大约526个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/07/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/tools/vmtouch%20%E8%A7%82%E6%B5%8B%E6%96%87%E4%BB%B6page%20cache/">vmtouch 观测文件page cache</a></h1><div class="content"><h2 id="vmtouch-介绍"><a href="#vmtouch-介绍" class="headerlink" title="vmtouch 介绍"></a>vmtouch 介绍</h2><p><code>便携式文件系统缓存诊断和控制</code> 是 <code>vmtouch</code> 作者对于vmtouch的的定义。<br>首先他可以很方便的知道某一个文件当前有多少在 kernel memory 里面作为<br><code>pagecache</code> 存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ vmtouch haha</span><br><span class="line">           Files: 1</span><br><span class="line">     Directories: 0</span><br><span class="line">  Resident Pages: 11584&#x2F;1024000  45M&#x2F;3G  1.13%</span><br><span class="line">         Elapsed: 0.031335 seconds</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ cat haha</span><br><span class="line">^C</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ vmtouch haha</span><br><span class="line">           Files: 1</span><br><span class="line">     Directories: 0</span><br><span class="line">  Resident Pages: 36800&#x2F;1024000  143M&#x2F;3G  3.59%</span><br><span class="line">         Elapsed: 0.033472 seconds</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$</span><br></pre></td></tr></table></figure>

<p>明显可以看到在经过 <code>cat</code> 访问之后 文件更多部分被读入 memory，作为 pagecache。</p>
<p>作者对于他的功能介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 发现你的操作系统正在缓存哪些文件</span><br><span class="line">2. 告诉操作系统缓存或清除某些文件或文件区域</span><br><span class="line">3. 将文件锁定在内存中，这样操作系统就不会删除它们</span><br><span class="line">4. 在服务器故障转移时保留虚拟内存配置文件</span><br><span class="line">5. 保持“热备”文件服务器</span><br><span class="line">6. 绘制文件系统缓存随时间的使用情况</span><br><span class="line">7. 维护缓存使用的“软配额”</span><br></pre></td></tr></table></figure>



<h2 id="vmtouch-使用"><a href="#vmtouch-使用" class="headerlink" title="vmtouch 使用"></a>vmtouch 使用</h2><h3 id="控制增加-pagecache"><a href="#控制增加-pagecache" class="headerlink" title="控制增加 pagecache"></a>控制增加 pagecache</h3><p>可以将整个文件读入内存，其实我们通过访问这个文件（从头到尾）也可以做到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ vmtouch -vt haha</span><br><span class="line">haha</span><br><span class="line">[OOo                                                         ] 44737&#x2F;1024000</span><br><span class="line">[OOOOOo                                                      ] 90849&#x2F;1024000</span><br><span class="line">[OOOOOOOOo                                                   ] 150209&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOo                                               ] 215937&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOo                                            ] 271489&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOo                                        ] 326305&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOo                                      ] 370721&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOo                                   ] 414305&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOo                                ] 469697&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo                             ] 524289&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo                          ] 577153&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo                     ] 652481&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo                  ] 705953&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo               ] 757281&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo            ] 810593&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo        ] 876769&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo      ] 920545&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOo  ] 973473&#x2F;1024000</span><br><span class="line">[OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO] 1024000&#x2F;1024000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           Files: 1</span><br><span class="line">     Directories: 0</span><br><span class="line">   Touched Pages: 1024000 (3G)</span><br><span class="line">         Elapsed: 9.4376 seconds</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$</span><br></pre></td></tr></table></figure>


<h3 id="控制减少-pagecache"><a href="#控制减少-pagecache" class="headerlink" title="控制减少 pagecache"></a>控制减少 pagecache</h3><p>evict a file from memory<br>将一个文件的pagecache 从内存中移除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ vmtouch -ve haha</span><br><span class="line">Evicting haha</span><br><span class="line"></span><br><span class="line">           Files: 1</span><br><span class="line">     Directories: 0</span><br><span class="line">   Evicted Pages: 1024000 (3G)</span><br><span class="line">         Elapsed: 0.085208 seconds</span><br></pre></td></tr></table></figure>

<p>与<code>drop cache</code>不同，<code>vmtouch</code>做到了精准控制单个文件page_cache的效果，而 drop cache不行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu-Inspiron-5548:&#x2F;home&#x2F;ubuntu# echo 1 &gt;  &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span><br><span class="line">root@ubuntu-Inspiron-5548:&#x2F;home&#x2F;ubuntu# echo 3 &gt;  &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span><br></pre></td></tr></table></figure>

<h3 id="保持文件在pagecache中"><a href="#保持文件在pagecache中" class="headerlink" title="保持文件在pagecache中"></a>保持文件在pagecache中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ vmtouch -dl haha</span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$ vmtouch: FATAL: mlock: haha (Cannot allocate memory)</span><br><span class="line"></span><br><span class="line">ubuntu@ubuntu-Inspiron-5548:~$</span><br></pre></td></tr></table></figure>
<p>(内存4G，文件4G 是没办法将文件常驻在 内存中的)<br>从此报错信息可以看出 <code>vmtouch</code> 也是通过 <code>mlock</code> 系统调用来实现 文件内容 或者 文件目录内容锁定在 内存中的</p>
<p><a target="_blank" rel="noopener" href="https://hoytech.com/vmtouch/">vmtouch 作者的文章</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-07T02:00:40.000Z" title="1/7/2021, 10:00:40 AM">2021-01-07</time>发表</span><span class="level-item"><time dateTime="2021-01-14T16:53:25.527Z" title="1/15/2021, 12:53:25 AM">2021-01-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">1 分钟读完 (大约143个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/07/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/systemTap/examples/SystemTap%20examples/">SystemTap examples</a></h1><div class="content"><p>SystemTap脚本集锦<br>本章列举了若干可用于监控和调查内核子系统的SystemTap脚本。所有这些示例都能在 <code>centos</code>的<br> <code>/usr/share/systemtap/testsuite/systemtap.examples/</code>下找到。</p>
<h2 id="SystemTap脚本集锦"><a href="#SystemTap脚本集锦" class="headerlink" title="SystemTap脚本集锦"></a>SystemTap脚本集锦</h2><p><a target="_blank" rel="noopener" href="https://spacewander.gitbooks.io/systemtapbeginnersguide_zh/content/5_UsefulSystemTapScripts.html">SystemTap脚本集锦</a></p>
<h2 id="解读错误信息"><a href="#解读错误信息" class="headerlink" title="解读错误信息"></a>解读错误信息</h2><p><a target="_blank" rel="noopener" href="https://spacewander.gitbooks.io/systemtapbeginnersguide_zh/content/6_UnderstandingSystemTapErrors.html">解读错误信息</a></p>
<p> 参考<a target="_blank" rel="noopener" href="https://spacewander.gitbooks.io/systemtapbeginnersguide_zh/content/2_3_RunningSystemTapScripts.html">SystemTap 内核文档</a></p>
<p>参考 <a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html-single/systemtap_beginners_guide/index">RedHat systemTap 文档</a></p>
<p>参考 <a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide/index.html">文档</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-21T11:00:00.000Z" title="9/21/2020, 7:00:00 PM">2020-09-21</time>发表</span><span class="level-item"><time dateTime="2021-02-19T06:01:01.845Z" title="2/19/2021, 2:01:01 PM">2021-02-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">8 分钟读完 (大约1165个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/21/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%85%B3%E4%BA%8Epreempt_count%E7%9A%84%E6%80%9D%E8%80%83/">关于preempt_count的思考</a></h1><div class="content"><p>preempt_conut 本质就是一个int型的数，是每个 <code>task_struct</code> 的 <code>thread_info</code> 的一个成员变量，但是他和系统的调度密切相关，当然也十分重要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct thread_info &#123;</span><br><span class="line">	unsigned long		flags;		&#x2F;* low level flags *&#x2F;</span><br><span class="line">	int			preempt_count;	&#x2F;* 0 &#x3D;&gt; preemptable, &lt;0 &#x3D;&gt; bug *&#x2F;</span><br><span class="line">    .......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>inlcude/linux/preempt.h</code> 文件看相关定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline int preempt_count(void)</span><br><span class="line">&#123;</span><br><span class="line">	return READ_ONCE(current_thread_info()-&gt;preempt_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> *         PREEMPT_MASK:	0x000000ff</span><br><span class="line"> *         SOFTIRQ_MASK:	0x0000ff00</span><br><span class="line"> *         HARDIRQ_MASK:	0x000f0000</span><br><span class="line"> *             NMI_MASK:	0x00100000</span><br><span class="line"> * PREEMPT_NEED_RESCHED:	0x80000000</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define PREEMPT_BITS	8</span><br><span class="line">#define SOFTIRQ_BITS	8</span><br><span class="line">#define HARDIRQ_BITS	4</span><br><span class="line">#define NMI_BITS	1</span><br><span class="line"></span><br><span class="line">#define PREEMPT_SHIFT	0</span><br><span class="line">#define SOFTIRQ_SHIFT	(PREEMPT_SHIFT + PREEMPT_BITS)</span><br><span class="line">#define HARDIRQ_SHIFT	(SOFTIRQ_SHIFT + SOFTIRQ_BITS)</span><br><span class="line">#define NMI_SHIFT	(HARDIRQ_SHIFT + HARDIRQ_BITS)</span><br><span class="line"></span><br><span class="line">#define hardirq_count()	(preempt_count() &amp; HARDIRQ_MASK)</span><br><span class="line">#define softirq_count()	(preempt_count() &amp; SOFTIRQ_MASK)</span><br><span class="line">#define irq_count()	(preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK \</span><br><span class="line">				 | NMI_MASK))</span><br><span class="line"></span><br><span class="line">#define in_irq()		(hardirq_count())</span><br><span class="line">#define in_softirq()		(softirq_count())</span><br><span class="line">#define in_interrupt()		(irq _count())</span><br><span class="line">#define in_serving_softirq()	(softirq_count() &amp; SOFTIRQ_OFFSET)</span><br><span class="line">#define in_nmi()		(preempt_count() &amp; NMI_MASK)</span><br><span class="line">#define in_task()		(!(preempt_count() &amp; \</span><br><span class="line">				   (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_OFFSET)))</span><br></pre></td></tr></table></figure>

<p>可以看出 <code>preempt_count</code> 0-7 bit被用来抢占计数，8-15 bit被用来软中断计数，16-19 bit被用来硬件中断计数，20bit 被用来 NMI中断计数，31 bit被用来记录是否需要立即sched.</p>
<p>in_interrupt() 这些宏本质也是根据 preempt_count()来判断的。</p>
<h2 id="hard-irq"><a href="#hard-irq" class="headerlink" title="hard irq"></a>hard irq</h2><p>在进入irq的时候通过 <code>irq_enter</code> 将preempt_count 的 16-19bit ++，在退出irq的时候通过 <code>irq_exit</code> 将preempt_count 的 16-19bit –，但是由于目前linux中的中断往往是不可嵌套的，所以一般 hardirq 只会用到 16 bit，为什么linux给 hardirq 保留了4bit呢，這是歷史原因造成的，早期hardirq还是可以嵌套的。</p>
<p>irq_enter()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define preempt_count_add(val)	__preempt_count_add(val)</span><br><span class="line"></span><br><span class="line">#define __irq_enter()					\</span><br><span class="line">	do &#123;						\</span><br><span class="line">		account_irq_enter_time(current);	\</span><br><span class="line">		preempt_count_add(HARDIRQ_OFFSET);	\  &#x2F;&#x2F; preempt_count 和 hardirq相关++</span><br><span class="line">		trace_hardirq_enter();			\</span><br><span class="line">	&#125; while (0)</span><br><span class="line"></span><br><span class="line">void irq_enter(void) &#x2F;&#x2F;进入中断上下文</span><br><span class="line">&#123;</span><br><span class="line">	rcu_irq_enter();</span><br><span class="line">	if (is_idle_task(current) &amp;&amp; !in_interrupt()) &#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * Prevent raise_softirq from needlessly waking up ksoftirqd</span><br><span class="line">		 * here, as softirq will be serviced on return from interrupt.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		local_bh_disable();</span><br><span class="line">		tick_irq_enter();</span><br><span class="line">		_local_bh_enable();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__irq_enter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>irq_exit()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define preempt_count_sub(val)	__preempt_count_sub(val)</span><br><span class="line"></span><br><span class="line">void irq_exit(void) &#x2F;&#x2F;退出中断上下文</span><br><span class="line">&#123;</span><br><span class="line">#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED</span><br><span class="line">	local_irq_disable();</span><br><span class="line">#else</span><br><span class="line">	lockdep_assert_irqs_disabled();</span><br><span class="line">#endif</span><br><span class="line">	account_irq_exit_time(current);</span><br><span class="line">	preempt_count_sub(HARDIRQ_OFFSET); &#x2F;&#x2F; preempt_count 和 hardirq相关--</span><br><span class="line">	if (!in_interrupt() &amp;&amp; local_softirq_pending())</span><br><span class="line">		invoke_softirq();</span><br><span class="line"></span><br><span class="line">	tick_irq_exit();</span><br><span class="line">	rcu_irq_exit();</span><br><span class="line">	trace_hardirq_exit(); &#x2F;* must be last! *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="soft-irq"><a href="#soft-irq" class="headerlink" title="soft irq"></a>soft irq</h2><p>preempt_count中的第8到15个bit表示softirq count，它记录了进入softirq的嵌套次数，如果softirq count的值为正数，说明现在正处于softirq上下文中。<br>由于softirq在单个CPU上是不会嵌套执行的，因此和hardirq count一样，实际只需要一个bit(bit 8)就可以了。<br>还有一种情况，softirq count 会用到不止 bit8，在禁用中断下半部的情况下，每禁用一次softirq count 就会增加1，理论上最多可以嵌套16次。</p>
<p>进入退出软中断的case</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible void __softirq_entry __do_softirq(void)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);</span><br><span class="line">    ......</span><br><span class="line">	while ((softirq_bit &#x3D; ffs(pending))) &#123;</span><br><span class="line">        ......</span><br><span class="line">		h-&gt;action(h);</span><br><span class="line">        ......</span><br><span class="line">	&#125;</span><br><span class="line">    ......</span><br><span class="line">	__local_bh_enable(SOFTIRQ_OFFSET);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>禁止、开启中断下半部的case</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void __local_bh_enable_ip(unsigned long ip, unsigned int cnt)</span><br><span class="line">&#123;</span><br><span class="line">    ...xxx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void local_bh_enable_ip(unsigned long ip)</span><br><span class="line">&#123;</span><br><span class="line">	__local_bh_enable_ip(ip, SOFTIRQ_DISABLE_OFFSET);&#x2F;&#x2F; 开启中断下半部的preempt_count 和 softirq相关++</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;开启下半部</span><br><span class="line">---------------</span><br><span class="line">&#x2F;&#x2F;禁止下半部</span><br><span class="line">static __always_inline void __local_bh_disable_ip(unsigned long ip, unsigned int cnt)</span><br><span class="line">&#123;</span><br><span class="line">	preempt_count_add(cnt);</span><br><span class="line">	barrier();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void __raw_spin_lock_bh(raw_spinlock_t *lock)</span><br><span class="line">&#123;</span><br><span class="line">	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET); &#x2F;&#x2F; 禁止中断下半部的preempt_count 和 softirq相关++</span><br><span class="line">	spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)</span><br><span class="line">&#123;</span><br><span class="line">	__raw_spin_lock_bh(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define raw_spin_lock_bh(lock)		_raw_spin_lock_bh(lock)</span><br><span class="line"></span><br><span class="line">static __always_inline void spin_lock_bh(spinlock_t *lock)</span><br><span class="line">&#123;</span><br><span class="line">	raw_spin_lock_bh(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来执行软中断 和 禁止中断下半部都属于软中断上下文。<br>（我有个疑问，禁止hard irq 属于硬件中断上下文吗？从 in_irq的定义上看不是，但是和软中断不太一样）</p>
<h2 id="process-context"><a href="#process-context" class="headerlink" title="process context"></a>process context</h2><p>进程上下文，当然不仅仅是进程，只要不是出于NMI、HARD IRQ、SOFT IRQ上下文的都算进程上下文，包括内核线程（包括ksoftirqd、kworker内核线程等）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define in_task()		(!(preempt_count() &amp; \</span><br><span class="line">				   (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_OFFSET)))</span><br></pre></td></tr></table></figure>

<p>中断上下文不会发生进程切换，是一种隐式的进制调度方法。通常也可以使用 <code>preempt_disable</code> 来显式关闭调度，对 preempt_count ++。</p>
<h2 id="atomic-context"><a href="#atomic-context" class="headerlink" title="atomic context"></a>atomic context</h2><p>处于中断上下文中(NMI、hard、soft) 或者 禁止抢占的情况下，都属于原子上下文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline int preempt_count(void)</span><br><span class="line">&#123;</span><br><span class="line">	return READ_ONCE(current_thread_info()-&gt;preempt_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define in_atomic()	(preempt_count() !&#x3D; 0)</span><br></pre></td></tr></table></figure>

<p>参考：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/88883239">Linux中的preempt_count</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-20T11:00:00.000Z" title="9/20/2020, 7:00:00 PM">2020-09-20</time>发表</span><span class="level-item"><time dateTime="2021-02-19T06:01:01.845Z" title="2/19/2021, 2:01:01 PM">2021-02-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">10 分钟读完 (大约1445个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/20/%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/softirq%E4%BD%95%E6%97%B6%E4%BC%9A%E8%A2%AB%E6%89%A7%E8%A1%8C/">softirq何时会被执行</a></h1><div class="content"><p>很多人可能都知道中断irq，但是对软中断softfirq却比较陌生，软中断这个概念是纯软件意义上的，与中断依赖于硬件行为不一样。在linux中，软中断主要用于执行irq中没有执行，但又不是很紧急的事情，现在linux内核中为每个CPU都分配了一个线程 <code>[ksoftirqd/n]</code>，用来执行软中断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh@ubuntu[root]:&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing# ps -aux |grep soft</span><br><span class="line">root          10  0.0  0.0      0     0 ?        S    9月19   0:19 [ksoftirqd&#x2F;0]</span><br><span class="line">root          18  0.0  0.0      0     0 ?        S    9月19   0:17 [ksoftirqd&#x2F;1]</span><br><span class="line">root          24  0.0  0.0      0     0 ?        S    9月19   0:18 [ksoftirqd&#x2F;2]</span><br><span class="line">root          30  0.0  0.0      0     0 ?        S    9月19   0:21 [ksoftirqd&#x2F;3]</span><br></pre></td></tr></table></figure>

<p>具体软中断分以下几种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum&#123;</span><br><span class="line">	HI_SOFTIRQ&#x3D;0,</span><br><span class="line">	TIMER_SOFTIRQ,</span><br><span class="line">	NET_TX_SOFTIRQ,</span><br><span class="line">	NET_RX_SOFTIRQ,</span><br><span class="line">	BLOCK_SOFTIRQ,</span><br><span class="line">	IRQ_POLL_SOFTIRQ,</span><br><span class="line">	TASKLET_SOFTIRQ,</span><br><span class="line">	SCHED_SOFTIRQ,</span><br><span class="line">	HRTIMER_SOFTIRQ, &#x2F;* Unused, but kept as tools rely on the numbering. Sigh! *&#x2F;</span><br><span class="line">	RCU_SOFTIRQ,    &#x2F;* Preferable RCU should always be the last softirq *&#x2F;</span><br><span class="line">	NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过 <code>open_softirq</code> 初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void open_softirq(int nr, void (*action)(struct softirq_action *))</span><br><span class="line">&#123;</span><br><span class="line">	softirq_vec[nr].action &#x3D; action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发软中断的时候通过 <code>raise_softirq</code> 来触发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void raise_softirq(unsigned int nr)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	raise_softirq_irqoff(nr);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但tasklet机制直接使用了 <code>raise_softirq_irqoff</code>，搜索代码可以发现其他类型的softirq也基本都是用 <code>raise_softirq_irqoff</code> 触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void __tasklet_schedule_common(struct tasklet_struct *t,</span><br><span class="line">				      struct tasklet_head __percpu *headp,</span><br><span class="line">				      unsigned int softirq_nr)</span><br><span class="line">&#123;</span><br><span class="line">	struct tasklet_head *head;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	head &#x3D; this_cpu_ptr(headp);</span><br><span class="line">	t-&gt;next &#x3D; NULL;</span><br><span class="line">	*head-&gt;tail &#x3D; t;</span><br><span class="line">	head-&gt;tail &#x3D; &amp;(t-&gt;next);</span><br><span class="line">	raise_softirq_irqoff(softirq_nr);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看下 <code>raise_softirq_irqoff</code> 实现，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define local_softirq_pending_ref irq_stat.__softirq_pending</span><br><span class="line">#define or_softirq_pending(x)	(__this_cpu_or(local_softirq_pending_ref, (x)))</span><br><span class="line"></span><br><span class="line">void __raise_softirq_irqoff(unsigned int nr)</span><br><span class="line">&#123;</span><br><span class="line">	trace_softirq_raise(nr);       &#x2F;&#x2F; 软中断 raise 的 tracepoint 点</span><br><span class="line">	or_softirq_pending(1UL &lt;&lt; nr); &#x2F;&#x2F; 设置当前cpu的软中断pending状态</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void raise_softirq_irqoff(unsigned int nr)</span><br><span class="line">&#123;</span><br><span class="line">	__raise_softirq_irqoff(nr);</span><br><span class="line">	if (!in_interrupt())</span><br><span class="line">		wakeup_softirqd(); &#x2F;&#x2F;如果不是中断上下文，就需要唤醒 ksoftirqd来执行相关软中断，这也保证了在线程上下文中软中断可以得到较快执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__raise_softirq_irqoff 仅仅是设置 __softirq_pending 标志位，这有两个作用</p>
<ol>
<li>如果当前是中断irq上下文，在 irq_exit 之后，检查 local_softirq_pending，判断有软中断需要执行</li>
<li>如果当前是线程上下文，在 ksoftirq 线程中检查标志位，最后执行相关的软中断</li>
<li>如果当前在临界区上，在打开中断时，可以检测pending的软中断如何去执行</li>
</ol>
<p>irq_exit的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static inline void invoke_softirq(void)</span><br><span class="line">&#123; &#x2F;&#x2F;不考虑软中断强制线程化，简化代码</span><br><span class="line">	if (ksoftirqd_running(local_softirq_pending()))</span><br><span class="line">		return;</span><br><span class="line">   __do_softirq();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void irq_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED</span><br><span class="line">	local_irq_disable();</span><br><span class="line">#else</span><br><span class="line">	lockdep_assert_irqs_disabled();</span><br><span class="line">#endif</span><br><span class="line">	account_irq_exit_time(current);</span><br><span class="line">	preempt_count_sub(HARDIRQ_OFFSET);</span><br><span class="line">	if (!in_interrupt() &amp;&amp; local_softirq_pending())</span><br><span class="line">		invoke_softirq();   &#x2F;&#x2F;在中断退出之后，如果有 pending的软中断，就需要执行 软中断</span><br><span class="line"></span><br><span class="line">	tick_irq_exit();</span><br><span class="line">	rcu_irq_exit();</span><br><span class="line">	trace_hardirq_exit(); &#x2F;* must be last! *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ksoftirq线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void run_ksoftirqd(unsigned int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	local_irq_disable();</span><br><span class="line">	if (local_softirq_pending()) &#123;</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * We can safely run softirq on inline stack, as we are not deep</span><br><span class="line">		 * in the task stack here.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		__do_softirq();</span><br><span class="line">		local_irq_enable();</span><br><span class="line">		cond_resched();</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	local_irq_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启中断的情况下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void __local_bh_enable_ip(unsigned long ip, unsigned int cnt)</span><br><span class="line">&#123;</span><br><span class="line">	WARN_ON_ONCE(in_irq());</span><br><span class="line">	lockdep_assert_irqs_enabled();</span><br><span class="line">	preempt_count_sub(cnt - 1);</span><br><span class="line">	if (unlikely(!in_interrupt() &amp;&amp; local_softirq_pending())) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果不在中断中，且 softirq 有pending的位，就需要执行软中断</span><br><span class="line">		do_softirq();</span><br><span class="line">	&#125;</span><br><span class="line">	preempt_count_dec();</span><br><span class="line">	preempt_check_resched();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__local_bh_enable_ip);</span><br><span class="line"></span><br><span class="line">static inline void local_bh_enable(void)</span><br><span class="line">&#123;</span><br><span class="line">	__local_bh_enable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="do-softirq"><a href="#do-softirq" class="headerlink" title="__do_softirq"></a>__do_softirq</h2><p>不管是退出中断时执行软中断，还是在ksoftirqd中執行软中断，最终都会执行到 <code>__do_softirq</code> 这个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_SOFTIRQ_TIME  msecs_to_jiffies(2)       &#x2F;&#x2F;2ms</span><br><span class="line">#define MAX_SOFTIRQ_RESTART 10</span><br><span class="line"></span><br><span class="line">asmlinkage __visible void __softirq_entry __do_softirq(void)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long end &#x3D; jiffies + MAX_SOFTIRQ_TIME;</span><br><span class="line">	unsigned long old_flags &#x3D; current-&gt;flags;</span><br><span class="line">	int max_restart &#x3D; MAX_SOFTIRQ_RESTART;</span><br><span class="line">	struct softirq_action *h;</span><br><span class="line">	bool in_hardirq;</span><br><span class="line">	__u32 pending;</span><br><span class="line">	int softirq_bit;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Mask out PF_MEMALLOC as the current task context is borrowed for the</span><br><span class="line">	 * softirq. A softirq handled, such as network RX, might set PF_MEMALLOC</span><br><span class="line">	 * again if the socket is related to swapping.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	current-&gt;flags &amp;&#x3D; ~PF_MEMALLOC;</span><br><span class="line"></span><br><span class="line">	pending &#x3D; local_softirq_pending();</span><br><span class="line">	account_irq_enter_time(current);</span><br><span class="line"></span><br><span class="line">	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);</span><br><span class="line">	in_hardirq &#x3D; lockdep_softirq_start();</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">	&#x2F;* Reset the pending bitmask before enabling irqs *&#x2F;</span><br><span class="line">	set_softirq_pending(0);</span><br><span class="line"></span><br><span class="line">	local_irq_enable();</span><br><span class="line"></span><br><span class="line">	h &#x3D; softirq_vec;</span><br><span class="line"></span><br><span class="line">	while ((softirq_bit &#x3D; ffs(pending))) &#123; &#x2F;&#x2F;循环执行 pending的软中断</span><br><span class="line">		unsigned int vec_nr;</span><br><span class="line">		int prev_count;</span><br><span class="line"></span><br><span class="line">		h +&#x3D; softirq_bit - 1;</span><br><span class="line"></span><br><span class="line">		vec_nr &#x3D; h - softirq_vec;</span><br><span class="line">		prev_count &#x3D; preempt_count();</span><br><span class="line"></span><br><span class="line">		kstat_incr_softirqs_this_cpu(vec_nr);</span><br><span class="line"></span><br><span class="line">		trace_softirq_entry(vec_nr);  &#x2F;&#x2F;trace 软中断执行</span><br><span class="line">		h-&gt;action(h);</span><br><span class="line">		trace_softirq_exit(vec_nr);   &#x2F;&#x2F;trace 软中断退出</span><br><span class="line">		if (unlikely(prev_count !&#x3D; preempt_count())) &#123;</span><br><span class="line">			pr_err(&quot;huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\n&quot;,</span><br><span class="line">			       vec_nr, softirq_to_name[vec_nr], h-&gt;action,</span><br><span class="line">			       prev_count, preempt_count());</span><br><span class="line">			preempt_count_set(prev_count);</span><br><span class="line">		&#125;</span><br><span class="line">		h++;</span><br><span class="line">		pending &gt;&gt;&#x3D; softirq_bit;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (__this_cpu_read(ksoftirqd) &#x3D;&#x3D; current)</span><br><span class="line">		rcu_softirq_qs();</span><br><span class="line">	local_irq_disable();</span><br><span class="line"></span><br><span class="line">	pending &#x3D; local_softirq_pending();</span><br><span class="line">	if (pending) &#123;</span><br><span class="line">		if (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp;</span><br><span class="line">		    --max_restart) &#x2F;&#x2F;如果又有pending的软中断了，看看是否执行超时了 2ms，且 restart 不能超过10次</span><br><span class="line">			goto restart; &#x2F;&#x2F;未超时</span><br><span class="line"></span><br><span class="line">		wakeup_softirqd(); &#x2F;&#x2F;超时 2ms，唤醒softirqd去执行软中断</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lockdep_softirq_end(in_hardirq);</span><br><span class="line">	account_irq_exit_time(current);</span><br><span class="line">	__local_bh_enable(SOFTIRQ_OFFSET);</span><br><span class="line">	WARN_ON_ONCE(in_interrupt());</span><br><span class="line">	current_restore_flags(old_flags, PF_MEMALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="do-softirq-1"><a href="#do-softirq-1" class="headerlink" title="do_softirq"></a>do_softirq</h2><p><code>do_softirq</code> 和 其他代码路径下执行软中断不一样，最终执行代码的是 <code>do_softirq_own_stack</code>，后续分析 -=-！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void do_softirq_own_stack(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct irq_stack *irqstk;</span><br><span class="line">	u32 *isp, *prev_esp;</span><br><span class="line"></span><br><span class="line">	irqstk &#x3D; __this_cpu_read(softirq_stack_ptr);</span><br><span class="line"></span><br><span class="line">	&#x2F;* build the stack frame on the softirq stack *&#x2F;</span><br><span class="line">	isp &#x3D; (u32 *) ((char *)irqstk + sizeof(*irqstk));</span><br><span class="line"></span><br><span class="line">	&#x2F;* Push the previous esp onto the stack *&#x2F;</span><br><span class="line">	prev_esp &#x3D; (u32 *)irqstk;</span><br><span class="line">	*prev_esp &#x3D; current_stack_pointer;</span><br><span class="line"></span><br><span class="line">	call_on_stack(__do_softirq, isp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asmlinkage __visible void do_softirq(void)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	if (local_softirq_pending() &amp;&amp; !ksoftirqd_running(pending))</span><br><span class="line">		do_softirq_own_stack();</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何观察softirq"><a href="#如何观察softirq" class="headerlink" title="如何观察softirq"></a>如何观察softirq</h2><p>在softirq处理过程中（非ksoftirqd线程），在该local cpu上的其他进程是无法进行调度的，不管进程有多高的优先级。因此这点势必对系统实时性造成影响。</p>
<ol>
<li>通过 <code>/proc/softirqs</code> ，配合 <code>watch</code> 命令来观察</li>
<li>通过一些tracepoint来观察</li>
</ol>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/linux%E5%86%85%E6%A0%B8/page/2/">上一页</a></div><div class="pagination-next"><a href="/categories/linux%E5%86%85%E6%A0%B8/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/linux%E5%86%85%E6%A0%B8/">1</a></li><li><a class="pagination-link" href="/categories/linux%E5%86%85%E6%A0%B8/page/2/">2</a></li><li><a class="pagination-link is-current" href="/categories/linux%E5%86%85%E6%A0%B8/page/3/">3</a></li><li><a class="pagination-link" href="/categories/linux%E5%86%85%E6%A0%B8/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Hui Su"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Hui Su</p><p class="is-size-6 is-block">liulangren bolg</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">62</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">98</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liulangrenaaa" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liulangrenaaa"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.google.com.hk/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Google</span></span><span class="level-right"><span class="level-item tag">www.google.com.hk</span></span></a></li><li><a class="level is-mobile" href="https://lkml.org/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">LKML</span></span><span class="level-right"><span class="level-item tag">lkml.org</span></span></a></li><li><a class="level is-mobile" href="https://mail.google.com/mail" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gmail</span></span><span class="level-right"><span class="level-item tag">mail.google.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhihu.com/explore" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/contest/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 剑指offer</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 周赛</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://tongji.baidu.com/web/32051076/overview/index?siteId=16230094" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">百度分析</span></span><span class="level-right"><span class="level-item tag">tongji.baidu.com</span></span></a></li><li><a class="level is-mobile" href="https://analytics.google.com/analytics/web/#/a187909645p259761261/admin/streams/table/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">google分析</span></span><span class="level-right"><span class="level-item tag">analytics.google.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/KASAN/"><span class="tag">KASAN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OOM/"><span class="tag">OOM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpf/"><span class="tag">bpf</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpftrace/"><span class="tag">bpftrace</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup/"><span class="tag">cgroup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/crash/"><span class="tag">crash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/deadlock/"><span class="tag">deadlock</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/double-free/"><span class="tag">double free</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/drop-caches/"><span class="tag">drop_caches</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/event-trace/"><span class="tag">event trace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ext2/"><span class="tag">ext2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/filesystem/"><span class="tag">filesystem</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ftrace/"><span class="tag">ftrace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gdb/"><span class="tag">gdb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hardlockup/"><span class="tag">hardlockup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hrtimer/"><span class="tag">hrtimer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hungtask/"><span class="tag">hungtask</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt/"><span class="tag">intrrrupt</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt-storm/"><span class="tag">intrrrupt storm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/irq/"><span class="tag">irq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kdump/"><span class="tag">kdump</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kernel-patch/"><span class="tag">kernel patch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kmemleak/"><span class="tag">kmemleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kprobes/"><span class="tag">kprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kretprobes/"><span class="tag">kretprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ksoftirqd/"><span class="tag">ksoftirqd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kthread/"><span class="tag">kthread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvm/"><span class="tag">kvm</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvmtool/"><span class="tag">kvmtool</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/launch-json/"><span class="tag">launch.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lockdep/"><span class="tag">lockdep</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/makedumpfile/"><span class="tag">makedumpfile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memleak/"><span class="tag">memleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mount/"><span class="tag">mount</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oops/"><span class="tag">oops</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-cache/"><span class="tag">page_cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-owner/"><span class="tag">page_owner</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pagecache/"><span class="tag">pagecache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/panic/"><span class="tag">panic</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/per-cpu/"><span class="tag">per-cpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/perf/"><span class="tag">perf</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preempt-count/"><span class="tag">preempt_count</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pressure/"><span class="tag">pressure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psi/"><span class="tag">psi</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rcu/"><span class="tag">rcu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/read-code/"><span class="tag">read code</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/schedule/"><span class="tag">schedule</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub/"><span class="tag">slub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub-debug/"><span class="tag">slub_debug</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/softlockup/"><span class="tag">softlockup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stack-overflow/"><span class="tag">stack_overflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systemTap/"><span class="tag">systemTap</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-json/"><span class="tag">task.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-struct/"><span class="tag">task_struct</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tasklet/"><span class="tag">tasklet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thread-info/"><span class="tag">thread_info</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ubuntu/"><span class="tag">ubuntu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/use-after-free/"><span class="tag">use after free</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/valgrind/"><span class="tag">valgrind</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmstat/"><span class="tag">vmstat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmtouch/"><span class="tag">vmtouch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vscode/"><span class="tag">vscode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/x86/"><span class="tag">x86</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xattr/"><span class="tag">xattr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zone/"><span class="tag">zone</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%B6%8A%E7%95%8C/"><span class="tag">内存泄漏越界</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"><span class="tag">内存泄露</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内核内存泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C/"><span class="tag">内核内存越界</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"><span class="tag">内核同步</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0/"><span class="tag">内核抢占</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%A0%88%E6%BA%A2%E5%87%BA/"><span class="tag">内核栈溢出</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E7%AE%A1%E7%AE%A1%E7%90%86/"><span class="tag">内管管理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"><span class="tag">函数调用</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/"><span class="tag">性能稳定性</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B3%84%E6%BC%8F/"><span class="tag">文件描述符泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><span class="tag">文件系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E9%A1%B9/"><span class="tag">杂项</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%88/"><span class="tag">栈</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/"><span class="tag">死锁检测</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="tag">生活感悟</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%A8%E6%88%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">用户内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A9%BA%E6%8C%87%E9%92%88/"><span class="tag">空指针</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F/"><span class="tag">虚拟地址空间泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F/"><span class="tag">资源泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%B8%AD%E6%96%AD/"><span class="tag">软中断</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"><span class="tag">进程调度</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/"><span class="tag">通用寄存器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81%E7%B2%92%E5%BA%A6/"><span class="tag">锁粒度</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E7%B3%BB%E7%BB%9F/"><span class="tag">问题系统</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/kernel-debug/"><span class="level-start"><span class="level-item">kernel debug</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-kernel/"><span class="level-start"><span class="level-item">linux kernel</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/"><span class="level-start"><span class="level-item">linux schedule</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/deadline-schedule/"><span class="level-start"><span class="level-item">deadline schedule</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/linux%E5%86%85%E6%A0%B8/"><span class="level-start"><span class="level-item">linux内核</span></span><span class="level-end"><span class="level-item tag">40</span></span></a></li><li><a class="level is-mobile" href="/categories/qemu/"><span class="level-start"><span class="level-item">qemu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/server/"><span class="level-start"><span class="level-item">server</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/shell%E8%84%9A%E6%9C%AC/"><span class="level-start"><span class="level-item">shell脚本</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="level-start"><span class="level-item">生活感悟</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-12T11:00:00.000Z">2021-04-12</time></p><p class="title"><a href="/2021/04/12/schedule/%E7%BF%BB%E8%AF%91/Capacity%20awareness%20for%20the%20deadline%20scheduler/">Capacity awareness for the deadline scheduler</a></p><p class="categories"><a href="/categories/linux-kernel/">linux kernel</a> / <a href="/categories/linux-kernel/linux-schedule/">linux schedule</a> / <a href="/categories/linux-kernel/linux-schedule/deadline-schedule/">deadline schedule</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-12T11:00:00.000Z">2021-04-12</time></p><p class="title"><a href="/2021/04/12/schedule/sched%20concepts/">sched concepts</a></p><p class="categories"><a href="/categories/linux-kernel/">linux kernel</a> / <a href="/categories/linux-kernel/linux-schedule/">linux schedule</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-12T11:00:00.000Z">2021-04-12</time></p><p class="title"><a href="/2021/04/12/schedule/sched%20domain/">sched domain</a></p><p class="categories"><a href="/categories/linux-kernel/">linux kernel</a> / <a href="/categories/linux-kernel/linux-schedule/">linux schedule</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-09T11:00:00.000Z">2021-04-09</time></p><p class="title"><a href="/2021/04/09/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/qemu%E5%90%AF%E5%8A%A8%E7%9A%84ubuntu%20img%E5%88%B6%E4%BD%9C/">qemu启动的ubuntu img制作</a></p><p class="categories"><a href="/categories/qemu/">qemu</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-18T11:00:00.000Z">2021-03-18</time></p><p class="title"><a href="/2021/03/18/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/arm64%20kernel%20%E7%BC%96%E8%AF%91%20+%20vscode%E8%A7%A3%E6%9E%90/">arm64 kernel 编译 + vscode解析</a></p><p class="categories"><a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Su Hui</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>