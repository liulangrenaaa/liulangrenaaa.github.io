<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: linux内核 - liulangren Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="liulangren blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="liulangren blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="liulangren Blog"><meta property="og:url" content="https://liulangrenaaa.github.io/"><meta property="og:site_name" content="liulangren Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liulangrenaaa.github.io/img/og_image.png"><meta property="article:author" content="Su Hui"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liulangrenaaa.github.io"},"headline":"liulangren Blog","image":["https://liulangrenaaa.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Su Hui"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cabdc5b9b70bb83fa919a6ebeb439f93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=PTKX6HMR55" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'PTKX6HMR55');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">linux内核</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-12T11:00:40.000Z" title="7/12/2021, 7:00:40 PM">2021-07-12</time>发表</span><span class="level-item"><time dateTime="2021-07-12T08:32:09.972Z" title="7/12/2021, 4:32:09 PM">2021-07-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">6 分钟读完 (大约853个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/07/12/filesystem/file%20attr/">file attr</a></h1><div class="content"><h2 id="file-attributes-概念"><a href="#file-attributes-概念" class="headerlink" title="file attributes 概念"></a>file attributes 概念</h2><p>除了控制用户和组读取，写和执行权限的文件模式位之外，几个文件系统支持文件属性，<br>可以进一步自定义允许的文件操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apart from the file mode bits that control user and group read, write and execute permissions, several file systems support file attributes that enable further customization of allowable file operations. This section describes some of these attributes and how to work with them.</span><br></pre></td></tr></table></figure>

<p><code>cp</code> <code>rsync</code> 等操作不会保留 <code>file attributes</code>。<br>只有部分 filesystem 支持这样的属性，常见的 <code>ext2</code> <code>ext3</code> <code>ext4</code> 都是支持的。</p>
<h2 id="file-attributes-FLAG"><a href="#file-attributes-FLAG" class="headerlink" title="file attributes FLAG"></a>file attributes FLAG</h2><p><code>include/uapi/linux/fs.h</code> 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Inode flags (FS_IOC_GETFLAGS &#x2F; FS_IOC_SETFLAGS)</span><br><span class="line"> *</span><br><span class="line"> * Note: for historical reasons, these flags were originally used and</span><br><span class="line"> * defined for use by ext2&#x2F;ext3, and then other file systems started</span><br><span class="line"> * using these flags so they wouldn&#39;t need to write their own version</span><br><span class="line"> * of chattr&#x2F;lsattr (which was shipped as part of e2fsprogs).  You</span><br><span class="line"> * should think twice before trying to use these flags in new</span><br><span class="line"> * contexts, or trying to assign these flags, since they are used both</span><br><span class="line"> * as the UAPI and the on-disk encoding for ext2&#x2F;3&#x2F;4.  Also, we are</span><br><span class="line"> * almost out of 32-bit flags.  :-)</span><br><span class="line"> *</span><br><span class="line"> * We have recently hoisted FS_IOC_FSGETXATTR &#x2F; FS_IOC_FSSETXATTR from</span><br><span class="line"> * XFS to the generic FS level interface.  This uses a structure that</span><br><span class="line"> * has padding and hence has more room to grow, so it may be more</span><br><span class="line"> * appropriate for many new use cases.</span><br><span class="line"> *</span><br><span class="line"> * Please do not change these flags or interfaces before checking with</span><br><span class="line"> * linux-fsdevel@vger.kernel.org and linux-api@vger.kernel.org.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define	FS_SECRM_FL			0x00000001 &#x2F;* Secure deletion *&#x2F;</span><br><span class="line">#define	FS_UNRM_FL			0x00000002 &#x2F;* Undelete *&#x2F;</span><br><span class="line">#define	FS_COMPR_FL			0x00000004 &#x2F;* Compress file *&#x2F;</span><br><span class="line">#define FS_SYNC_FL			0x00000008 &#x2F;* Synchronous updates *&#x2F;</span><br><span class="line">#define FS_IMMUTABLE_FL			0x00000010 &#x2F;* Immutable file *&#x2F;</span><br><span class="line">#define FS_APPEND_FL			0x00000020 &#x2F;* writes to file may only append *&#x2F;</span><br><span class="line">#define FS_NODUMP_FL			0x00000040 &#x2F;* do not dump file *&#x2F;</span><br><span class="line">#define FS_NOATIME_FL			0x00000080 &#x2F;* do not update atime *&#x2F;</span><br></pre></td></tr></table></figure>

<p>这些 FLAG get set 都是通过 ioctl(FS_IOC_FSGETXATTR / FS_IOC_FSSETXATTR) 命令来实现的。</p>
<p>可以通过<code>chattr</code>的 如下命令修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a  -- append only</span><br><span class="line">A  -- no atime updates</span><br><span class="line">c  -- compressed</span><br><span class="line">C  -- no copy on write</span><br><span class="line">d  -- no dump</span><br><span class="line">D  -- no synchronous directory updates</span><br><span class="line">e  -- extent format</span><br><span class="line">i  -- immutable</span><br><span class="line">j  -- data journalling</span><br><span class="line">P  -- project hierarchy</span><br><span class="line">s  -- secure deletion</span><br><span class="line">S  -- synchronous updates</span><br><span class="line">t  -- no tail-merging</span><br><span class="line">T  -- top of directory hierarchy</span><br><span class="line">u  -- undeletable</span><br></pre></td></tr></table></figure>


<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p><code>i</code> 属性就是 <code>immutable</code>，意思是不可变的。</p>
<h3 id="immutable-不可变属性"><a href="#immutable-不可变属性" class="headerlink" title="immutable 不可变属性"></a>immutable 不可变属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# touch 1</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# touch 2</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# lsattr</span><br><span class="line">-------------------- .&#x2F;1</span><br><span class="line">-------------------- .&#x2F;2</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# chattr +i 1</span><br><span class="line">chattr: Operation not permitted while setting flags on 1</span><br><span class="line">stable_kernel@1kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# sudo chattr +i 1</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# lsattr</span><br><span class="line">----i--------------- .&#x2F;1</span><br><span class="line">-------------------- .&#x2F;2</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# rm 1</span><br><span class="line">rm: cannot remove &#39;1&#39;: Operation not permitted</span><br><span class="line">stable_kernel@1kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# rm 2</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# ls</span><br><span class="line">1</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# sudo rm 1</span><br><span class="line">rm: cannot remove &#39;1&#39;: Operation not permitted</span><br><span class="line">stable_kernel@1kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# chattr -i 1</span><br><span class="line">chattr: Operation not permitted while setting flags on 1</span><br><span class="line">stable_kernel@1kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# sudo chattr -i 1</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# rm 1</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# ls</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123#</span><br></pre></td></tr></table></figure>

<h3 id="file-attributes-cp-时保留吗？"><a href="#file-attributes-cp-时保留吗？" class="headerlink" title="file attributes cp 时保留吗？"></a>file attributes cp 时保留吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# touch 1</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# lsattr</span><br><span class="line">-------------------- .&#x2F;1</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# sudo chattr +i 1</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# lsattr</span><br><span class="line">----i--------------- .&#x2F;1</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# cp 1 2</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# lsattr</span><br><span class="line">----i--------------- .&#x2F;1</span><br><span class="line">-------------------- .&#x2F;2</span><br><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# mv 1 11</span><br><span class="line">mv: cannot move &#39;1&#39; to &#39;11&#39;: Operation not permitted</span><br><span class="line">stable_kernel@1kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# sudo mv 1 11</span><br><span class="line">mv: cannot move &#39;1&#39; to &#39;11&#39;: Operation not permitted</span><br><span class="line">stable_kernel@1kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123#</span><br></pre></td></tr></table></figure>

<p>可以看到在 执行 <code>cp</code> 命令时， file attributes 是不保留的。</p>
<h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><p><code>chattr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# sudo strace chattr +i 1</span><br><span class="line">execve(&quot;&#x2F;usr&#x2F;bin&#x2F;chattr&quot;, [&quot;chattr&quot;, &quot;+i&quot;, &quot;1&quot;], 0x7fffa9701fd0 &#x2F;* 22 vars *&#x2F;) &#x3D; 0</span><br><span class="line">......</span><br><span class="line">openat(AT_FDCWD, &quot;1&quot;, O_RDONLY|O_NONBLOCK) &#x3D; 3</span><br><span class="line">ioctl(3, FS_IOC_GETFLAGS, 0x7ffe9578ee3c) &#x3D; 0</span><br><span class="line">close(3)                                &#x3D; 0</span><br><span class="line">lstat(&quot;1&quot;, &#123;st_mode&#x3D;S_IFREG|0664, st_size&#x3D;0, ...&#125;) &#x3D; 0</span><br><span class="line">openat(AT_FDCWD, &quot;1&quot;, O_RDONLY|O_NONBLOCK) &#x3D; 3</span><br><span class="line">ioctl(3, FS_IOC_SETFLAGS, 0x7ffe9578ee3c) &#x3D; 0</span><br><span class="line">close(3)                                &#x3D; 0</span><br><span class="line">......</span><br></pre></td></tr></table></figure>


<p><code>lsattr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stable_kernel@kernel: ~&#x2F;workspace&#x2F;fs&#x2F;ext2_dir&#x2F;123# strace lsattr</span><br><span class="line">execve(&quot;&#x2F;usr&#x2F;bin&#x2F;lsattr&quot;, [&quot;lsattr&quot;], 0x7ffca62b1850 &#x2F;* 37 vars *&#x2F;) &#x3D; 0</span><br><span class="line">openat(AT_FDCWD, &quot;.&#x2F;2&quot;, O_RDONLY|O_NONBLOCK) &#x3D; 4</span><br><span class="line">ioctl(4, FS_IOC_GETFLAGS, 0x7ffc5889dbac) &#x3D; 0</span><br><span class="line">close(4)                                &#x3D; 0</span><br><span class="line">write(1, &quot;-------------------- .&#x2F;2\n&quot;, 25-------------------- .&#x2F;2</span><br><span class="line">) &#x3D; 25</span><br><span class="line">getdents64(3, &#x2F;* 0 entries *&#x2F;, 32768)   &#x3D; 0</span><br><span class="line">close(3)                                &#x3D; 0</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-11T11:00:00.000Z" title="6/11/2021, 7:00:00 PM">2021-06-11</time>发表</span><span class="level-item"><time dateTime="2021-06-11T09:22:33.005Z" title="6/11/2021, 5:22:33 PM">2021-06-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">4 分钟读完 (大约661个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/11/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/kfence%20%E4%BD%BF%E7%94%A8/">kfence 使用</a></h1><div class="content"><h2 id="Kfence-配置"><a href="#Kfence-配置" class="headerlink" title="Kfence 配置"></a>Kfence 配置</h2><p>看下<code>.config</code>的改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:~&#x2F;workspace&#x2F;linux $ diff .&#x2F;out&#x2F;.config &#x2F;tmp&#x2F;.config</span><br><span class="line">4713c4713,4717</span><br><span class="line">&lt; # CONFIG_KFENCE is not set</span><br><span class="line">---</span><br><span class="line">&gt; CONFIG_KFENCE&#x3D;y</span><br><span class="line">&gt; CONFIG_KFENCE_STATIC_KEYS&#x3D;y</span><br><span class="line">&gt; CONFIG_KFENCE_SAMPLE_INTERVAL&#x3D;100</span><br><span class="line">&gt; CONFIG_KFENCE_NUM_OBJECTS&#x3D;255</span><br><span class="line">&gt; CONFIG_KFENCE_STRESS_TEST_FAULTS&#x3D;0</span><br></pre></td></tr></table></figure>

<h2 id="Kfence-使用"><a href="#Kfence-使用" class="headerlink" title="Kfence 使用"></a>Kfence 使用</h2><p>写了一个test case，参考<a target="_blank" rel="noopener" href="https://github.com/liulangrenaaa/test_modules/blob/main/memory/kfence/kfence_debug.c">代码</a></p>
<h3 id="oob检测"><a href="#oob检测" class="headerlink" title="oob检测"></a>oob检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static int kfence_debug_oob(void *data)</span><br><span class="line">&#123;</span><br><span class="line">	char *p[100] &#x3D; &#123;NULL, &#125;;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	data &#x3D; data;</span><br><span class="line"></span><br><span class="line">	msleep(1000 * 5);</span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">		p[i] &#x3D; (char *)kmalloc(32, GFP_KERNEL);</span><br><span class="line">		p[i][32] &#x3D; &#39;a&#39;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while(!kthread_should_stop()) &#123;</span><br><span class="line">		msleep_interruptible(1000);</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是越界写了 1byte的 kmalloc数据。</p>
<p>insmod 之后立刻报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[  779.341929] kfence_debug: loading out-of-tree module taints kernel.</span><br><span class="line">[  784.638024] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[  784.641414] BUG: KFENCE: out-of-bounds write in kfence_debug_oob+0x26&#x2F;0x60 [kfence_debug]</span><br><span class="line"></span><br><span class="line">[  784.643513] Out-of-bounds write at 0x00000000514f5e22 (32B right of kfence-#176):</span><br><span class="line">[  784.644142]  kfence_debug_oob+0x26&#x2F;0x60 [kfence_debug]</span><br><span class="line">[  784.644144]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[  784.644146]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line"></span><br><span class="line">[  784.644283] kfence-#176 [0x000000001f204f03-0x00000000533650da, size&#x3D;32, cache&#x3D;kmalloc-32] allocated by task 3757:</span><br><span class="line">[  784.644288]  kfence_debug_oob+0x26&#x2F;0x60 [kfence_debug]</span><br><span class="line">[  784.644289]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[  784.644290]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line"></span><br><span class="line">[  784.644423] CPU: 2 PID: 3757 Comm: kfence_debug Kdump: loaded Tainted: G           O      5.13.0-rc5+ #4</span><br><span class="line">[  784.645207] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04&#x2F;01&#x2F;2014</span><br><span class="line">[  784.646006] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p><code>oob</code> 的 代码堆栈直接也打印出来了，十分清晰</p>
<h3 id="use-after-free-检测"><a href="#use-after-free-检测" class="headerlink" title="use after free 检测"></a>use after free 检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static int kfence_debug_use_after_free(void *data)</span><br><span class="line">&#123;</span><br><span class="line">	char *p[100] &#x3D; &#123;NULL, &#125;;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	data &#x3D; data;</span><br><span class="line"></span><br><span class="line">	msleep(1000 * 5);</span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">		p[i] &#x3D; (char *)kmalloc(32, GFP_KERNEL);</span><br><span class="line">		p[i][30] &#x3D; &#39;a&#39;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">		kfree(p[i]);</span><br><span class="line">		msleep_interruptible(100);</span><br><span class="line">		p[i][30] &#x3D; &#39;a&#39;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while(!kthread_should_stop()) &#123;</span><br><span class="line">		msleep_interruptible(1000);</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>user after free:</p>
<ul>
<li>kmalloc 32 bytes mem =&gt; p</li>
<li>assign val to p[30]</li>
<li>free p</li>
<li>assign val to p[30]</li>
</ul>
<p>insmod 之后立刻报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[ 1779.536493] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[ 1779.539850] BUG: KFENCE: use-after-free write in kfence_debug_use_after_free+0x7e&#x2F;0xd0 [kfence_debug]</span><br><span class="line"></span><br><span class="line">[ 1779.542427] Use-after-free write at 0x0000000013fef528 (in kfence-#218):</span><br><span class="line">[ 1779.542985]  kfence_debug_use_after_free+0x7e&#x2F;0xd0 [kfence_debug]</span><br><span class="line">[ 1779.542987]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[ 1779.542990]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line"></span><br><span class="line">[ 1779.543123] kfence-#218 [0x000000007dc7fe8d-0x0000000000dd0a85, size&#x3D;32, cache&#x3D;kmalloc-32] allocated by task 3868:</span><br><span class="line">[ 1779.543127]  kfence_debug_use_after_free+0x58&#x2F;0xd0 [kfence_debug]</span><br><span class="line">[ 1779.543129]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[ 1779.543130]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line">[ 1779.543131]</span><br><span class="line">               freed by task 3868:</span><br><span class="line">[ 1779.543133]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[ 1779.543134]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line"></span><br><span class="line">[ 1779.543266] CPU: 1 PID: 3868 Comm: kfence_debug Kdump: loaded Tainted: G    B      O      5.13.0-rc5+ #4</span><br><span class="line">[ 1779.544051] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04&#x2F;01&#x2F;2014</span><br><span class="line">[ 1779.544818] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>可以看出这是一个 <code>kmalloc-32</code> 的 mem，且是 <code>allocated</code> by task 3868，<code>freed</code> by task 3868。<br>也可以看到详细堆栈。</p>
<h3 id="double-free-检测"><a href="#double-free-检测" class="headerlink" title="double free 检测"></a>double free 检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int kfence_debug_double_free(void *data)</span><br><span class="line">&#123;</span><br><span class="line">	char *p[100] &#x3D; &#123;NULL, &#125;;</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	data &#x3D; data;</span><br><span class="line"></span><br><span class="line">	msleep(1000 * 5);</span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">		p[i] &#x3D; (char *)kmalloc(32, GFP_KERNEL);</span><br><span class="line">		p[i][30] &#x3D; &#39;a&#39;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">		kfree(p[i]);</span><br><span class="line">		msleep_interruptible(100);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">		kfree(p[i]);</span><br><span class="line">		msleep_interruptible(100);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while(!kthread_should_stop()) &#123;</span><br><span class="line">		msleep_interruptible(1000);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>double free:</p>
<ul>
<li>kmalloc 32 bytes mem =&gt; p</li>
<li>free p</li>
<li>free p</li>
</ul>
<p>insmod 之后立刻报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[ 2489.576810] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[ 2489.577668] BUG: KFENCE: invalid free in kthread+0xf9&#x2F;0x130</span><br><span class="line"></span><br><span class="line">[ 2489.578464] Invalid free of 0x00000000ed008e01 (in kfence-#160):</span><br><span class="line">[ 2489.579128]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[ 2489.579131]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line"></span><br><span class="line">[ 2489.579305] kfence-#160 [0x00000000ed008e01-0x0000000086ffed42, size&#x3D;32, cache&#x3D;kmalloc-32] allocated by task 3914:</span><br><span class="line">[ 2489.579310]  kfence_debug_double_free+0x58&#x2F;0xd0 [kfence_debug]</span><br><span class="line">[ 2489.579312]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[ 2489.579313]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line">[ 2489.579315]</span><br><span class="line">               freed by task 3914:</span><br><span class="line">[ 2489.579318]  kthread+0xf9&#x2F;0x130</span><br><span class="line">[ 2489.579319]  ret_from_fork+0x22&#x2F;0x30</span><br><span class="line"></span><br><span class="line">[ 2489.579492] CPU: 3 PID: 3914 Comm: kfence_debug Kdump: loaded Tainted: G    B      O      5.13.0-rc5+ #4</span><br><span class="line">[ 2489.580590] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04&#x2F;01&#x2F;2014</span><br><span class="line">[ 2489.581698] &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>可以看出这是一个 <code>kmalloc-32</code> 的 mem，且是 <code>allocated</code> by task 3914, <code>freed</code> by task 3914。<br>也可以看到详细堆栈。</p>
<h2 id="Kfence-原理"><a href="#Kfence-原理" class="headerlink" title="Kfence 原理"></a>Kfence 原理</h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-24T11:00:00.000Z" title="4/24/2021, 7:00:00 PM">2021-04-24</time>发表</span><span class="level-item"><time dateTime="2021-04-22T06:24:26.660Z" title="4/22/2021, 2:24:26 PM">2021-04-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">18 分钟读完 (大约2771个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/24/schedule/pelt/">pelt</a></h1><div class="content"><p>参考<a target="_blank" rel="noopener" href="http://www.wowotech.net/process_management/450.html">wowo文章</a></p>
<h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY?"></a>WHY?</h2><p>为了让调度器更加的聪明，我们总是希望系统满足最大吞吐量同时又最大限度的降低功耗。虽然可能有些矛盾，但是现实总是这样。PELT算法是Linux 3.8合入的，那么在此之前，我们存在什么问题才引入PELT算法呢？在Linux 3.8之前，CFS以每个运行队列（runqueue，简称rq）为基础跟踪负载。但是这种方法，我们无法确定当前负载的来源。同时，即使工作负载相对稳定的情况下，在rq级别跟踪负载，其值也会产生很大变化。为了解决以上的问题，PELT算法会跟踪每个调度实体（per-scheduling entity）的负载情况。</p>
<h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW?"></a>HOW?</h2><p>为了做到Per-entity的负载跟踪，时间（物理时间，不是虚拟时间）被分成了1024us的序列，在每一个1024us的周期中，一个entity对系统负载的贡献可以根据该实体处于runnable状态（正在CPU上运行或者等待cpu调度运行）的时间进行计算。</p>
<p>如果在该周期内，runnable的时间是x，那么对系统负载的贡献就是（x/1024）。当然，一个实体在一个计算周期内的负载可能会超过1024us，这是因为我们会累积在过去周期中的负载，当然，对于过去的负载我们在计算的时候需要乘一个衰减因子。如果我们让Li表示在周期pi中该调度实体的对系统负载贡献，那么一个调度实体对系统负荷的总贡献可以表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L &#x3D; L0 + L1 * y + L2 * y2 + L3 * y3 + ... + Ln * yn</span><br><span class="line"></span><br><span class="line">其中：y32 &#x3D; 0.5, y &#x3D; 0.97857206</span><br></pre></td></tr></table></figure>

<p>如果有一个task，从第一次加入rq后开始一直运行4096us后一直睡眠，那么在1023us、2047us、3071us、4095us、5119us、6143us、7167us和8191us时间的每一个时刻负载贡献分别是多少呢？<br>        /<br>        |<br>       1|———————–|<br>        |                       |<br>       0|                       |——————————————<br>——————————————————————————-&gt;<br>                |       |       |       |       |       |       |       |<br>              1023    2047    4095    5119    7167    8191</p>
<p>可以计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L0 &#x3D; 1023 * y0 &#x3D; 1023</span><br><span class="line">L1 &#x3D; 1023 * y0 + 1024 * y1 &#x3D; 1023 + (L0 + 1) * y &#x3D; 2025</span><br><span class="line">L2 &#x3D; 1023 * y0 + 1024 * y1 + 1024 * y2 &#x3D; 1023 + (L1 + 1) * y1 &#x3D; 3005</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>可以得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ln &#x3D; Load(This)  + Ln-1 * y &#x3D;  当前周期负载 + 上一周期负载 * 衰减系数y</span><br></pre></td></tr></table></figure>

<p>需要经常计算 Ln-1 * y的值，但是内核并不是 简单计算  Ln-1 * y，也可能需要计算<br>Ln-m * ym，kernel中使用decay_laod()函数。<br>为了提高精度和计算速度，采用乘法  和 位移算法进行计算，输入是:</p>
<ol>
<li>val: 前n个负载计算周期的负载</li>
<li>n: 衰减n个周期之后的实际负载<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">decay_load(val, n) &#x3D; val * yn &#x3D; (val * yn) * (232 &gt;&gt;32)</span><br><span class="line">                              &#x3D; val * (yn * 232) &gt;&gt;  32</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>可以看到 yn * 232的值其实是固定的（n确定的情况下是一个数组）<br><code>runnable_avg_yN_inv[n] = yn*232, n &gt; 0 &amp;&amp; n &lt; 32</code><br>kernel中使用了一个数组来保存这些值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static const u32 runnable_avg_yN_inv[] &#x3D; &#123;</span><br><span class="line">	0xffffffff, 0xfa83b2da, 0xf5257d14, 0xefe4b99a, 0xeac0c6e6, 0xe5b906e6,</span><br><span class="line">	0xe0ccdeeb, 0xdbfbb796, 0xd744fcc9, 0xd2a81d91, 0xce248c14, 0xc9b9bd85,</span><br><span class="line">	0xc5672a10, 0xc12c4cc9, 0xbd08a39e, 0xb8fbaf46, 0xb504f333, 0xb123f581,</span><br><span class="line">	0xad583ee9, 0xa9a15ab4, 0xa5fed6a9, 0xa2704302, 0x9ef5325f, 0x9b8d39b9,</span><br><span class="line">	0x9837f050, 0x94f4efa8, 0x91c3d373, 0x8ea4398a, 0x8b95c1e3, 0x88980e80,</span><br><span class="line">	0x85aac367, 0x82cd8698,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是<code>decay_load</code>实际代码：</p>
<ol>
<li>如果衰减周期大于 <code>LOAD_AVG_PERIOD * 63</code>，那么我们认为<code>LOAD_AVG_PERIOD * 63</code>之前的负载val对现在的贡献是 0</li>
<li>如果<code>n &gt;= 32</code>，由于 <code>runnable_avg_yN_inv</code> 只包含了y31的值，所以 必须将n 归一化到 <code>&lt; 32</code>，每归一化一次，负载贡献就减半 (val = val &gt;&gt; 1)</li>
<li>最后衰减的负载是 <code>val * runnable_avg_yN_inv[local_n] &gt;&gt; 32</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Approximate:</span><br><span class="line"> *   val * y^n,    where y^32 ~&#x3D; 0.5 (~1 scheduling period)</span><br><span class="line"> *&#x2F;</span><br><span class="line">static u64 decay_load(u64 val, u64 n)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int local_n;</span><br><span class="line"></span><br><span class="line">	if (unlikely(n &gt; LOAD_AVG_PERIOD * 63))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;* after bounds checking we can collapse to 32-bit *&#x2F;</span><br><span class="line">	local_n &#x3D; n;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * As y^PERIOD &#x3D; 1&#x2F;2, we can combine</span><br><span class="line">	 *    y^n &#x3D; 1&#x2F;2^(n&#x2F;PERIOD) * y^(n%PERIOD)</span><br><span class="line">	 * With a look-up table which covers y^n (n&lt;PERIOD)</span><br><span class="line">	 *</span><br><span class="line">	 * To achieve constant time decay_load.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (unlikely(local_n &gt;&#x3D; LOAD_AVG_PERIOD)) &#123;</span><br><span class="line">		val &gt;&gt;&#x3D; local_n &#x2F; LOAD_AVG_PERIOD;</span><br><span class="line">		local_n %&#x3D; LOAD_AVG_PERIOD;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val &#x3D; mul_u64_u32_shr(val, runnable_avg_yN_inv[local_n], 32);</span><br><span class="line">	return val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="负载信息如何记录？"><a href="#负载信息如何记录？" class="headerlink" title="负载信息如何记录？"></a>负载信息如何记录？</h2><p>首先负载计算是相对于<code>调度实体se 和  就绪队列rq</code>的：<br>对于 <code>struct sched_entity</code>  <code>struct cfs_rq</code> <code>struct rq</code> 结构来说都内嵌了 <code>struct sched_avg</code> 结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">struct sched_avg &#123;</span><br><span class="line">	u64				last_update_time; &#x2F;&#x2F; 上一次负载更新的时间</span><br><span class="line">	u64				load_sum; &#x2F;&#x2F; running + runnable 的负载</span><br><span class="line">	u64				runnable_load_sum;&#x2F;&#x2F; 姑且等于 load_sum</span><br><span class="line">	u32				util_sum; &#x2F;&#x2F; running 的负载</span><br><span class="line">	u32				period_contrib;</span><br><span class="line">	unsigned long			load_avg; &#x2F;&#x2F; running + runnable 的平均负载</span><br><span class="line">	unsigned long			runnable_load_avg; &#x2F;&#x2F; 姑且等于 load_avg</span><br><span class="line">	unsigned long			util_avg; &#x2F;&#x2F; running 的平均负载</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct sched_entity &#123;</span><br><span class="line">      	struct load_weight		load;</span><br><span class="line">	unsigned long			runnable_weight;</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Per entity load average tracking.</span><br><span class="line">	 *</span><br><span class="line">	 * Put into separate cache line so it does not</span><br><span class="line">	 * collide with read-mostly values above.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct sched_avg		avg;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct cfs_rq &#123;</span><br><span class="line">	struct load_weight	load;</span><br><span class="line">	unsigned long		runnable_weight;</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * CFS load tracking</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct sched_avg	avg;</span><br><span class="line">#ifndef CONFIG_64BIT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct rq &#123;</span><br><span class="line">	&#x2F;* runqueue lock: *&#x2F;</span><br><span class="line">	raw_spinlock_t		lock;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * nr_running and cpu_load should be in the same cacheline because</span><br><span class="line">	 * remote CPUs use both these fields when doing load calculation.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	unsigned int		nr_running;</span><br><span class="line">	struct sched_avg	avg_rt;</span><br><span class="line">	struct sched_avg	avg_dl;</span><br><span class="line">#ifdef CONFIG_HAVE_SCHED_AVG_IRQ</span><br><span class="line">	struct sched_avg	avg_irq;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>通过init可以更清楚知道他们含义，如果<code>se</code>是：</p>
<ol>
<li><code>task</code>，那么 runnable_load_avg = load_avg 都和 se的权重相等</li>
<li><code>group se</code>，runnable_load_avg = load_avg = 0，也反映了此时<code>group se</code>还没有任何任务。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void init_entity_runnable_average(struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_avg *sa &#x3D; &amp;se-&gt;avg;</span><br><span class="line"></span><br><span class="line">	memset(sa, 0, sizeof(*sa));</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Tasks are initialized with full load to be seen as heavy tasks until</span><br><span class="line">	 * they get a chance to stabilize to their real load level.</span><br><span class="line">	 * Group entities are initialized with zero load to reflect the fact that</span><br><span class="line">	 * nothing has been attached to the task group yet.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (entity_is_task(se))</span><br><span class="line">		sa-&gt;runnable_load_avg &#x3D; sa-&gt;load_avg &#x3D; scale_load_down(se-&gt;load.weight);</span><br><span class="line"></span><br><span class="line">	se-&gt;runnable_weight &#x3D; se-&gt;load.weight;</span><br><span class="line"></span><br><span class="line">	&#x2F;* when this task enqueue&#39;ed, it will contribute to its cfs_rq&#39;s load_avg *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="那么如何计算当前se的负载？"><a href="#那么如何计算当前se的负载？" class="headerlink" title="那么如何计算当前se的负载？"></a>那么如何计算当前se的负载？</h2><p>假设一个task从0时刻一直开始运行，在1022us时刻负载是多少？<br>由于还没有之前运行周期可以凑满1024us 一个衰减周期，所以负载是1022，<br>又运行了10us之后负载应该如何计算？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L  &#x3D; (10 - (1024 - 1022)) +(1024 - 1022 + 1022)y</span><br><span class="line">   &#x3D; (10 -2) + (1022 + 2) * y1</span><br><span class="line">   &#x3D; 8 +  1024 *  y1</span><br></pre></td></tr></table></figure>

<p>假设上一时刻负载贡献是u，经历d时间后的负载贡献如何计算呢？根据上面的例子，我们可以把时间d分成3和部分：<br>d1是离当前时间最远（不完整的）period 的剩余部分，d2 是完整period时间，而d3是（不完整的）当前 period 的剩余部分。<br>假设时间d是经过p个周期（d=d1+d2+d3, p=1+d2/1024）。d1，d2，d3 的示意图如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">      d1          d2           d3</span><br><span class="line">      ^           ^            ^</span><br><span class="line">      |           |            |</span><br><span class="line">    |&lt;-&gt;|&lt;-----------------&gt;|&lt;---&gt;|</span><br><span class="line">|---x---|------| ... |------|-----x (now)</span><br><span class="line">    |</span><br><span class="line">   u时刻</span><br><span class="line"></span><br><span class="line">u&#39;  &#x3D; (u + d1) y^p + 1024 * (y^1 + y^2 + ...  + y^p-1) + d3 * y^0</span><br><span class="line">                           p-1</span><br><span class="line">    &#x3D; (u + d1) y^p + 1024 \Sum y^n + d3 y^0</span><br><span class="line">                           n&#x3D;1</span><br><span class="line"></span><br><span class="line">    &#x3D; u y^p +                                 ---&gt; Step1</span><br><span class="line">                     p-1</span><br><span class="line">    &#x3D; d1 y^p + 1024 \Sum y^n + d3 y^0         ---&gt; Step2</span><br><span class="line">                     n&#x3D;1</span><br></pre></td></tr></table></figure>


<p>kernel中是用 <code>accumulate_sum()</code> 实现这个当前时刻负载计算的</p>
<ol>
<li>period_contrib记录的是上次更新负载不足1024us周期的时间。delta是经过的时间，为了计算经过的周期个数需要加上period_contrib，然后整除1024。</li>
<li>计算周期个数</li>
<li>调用decay_load()函数计算公式中的step1部分</li>
<li>__accumulate_pelt_segments()负责计算公式step2部分</li>
<li>更新period_contrib为本次不足1024us部分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">static u32 __accumulate_pelt_segments(u64 periods, u32 d1, u32 d3)</span><br><span class="line">&#123;</span><br><span class="line">	u32 c1, c2, c3 &#x3D; d3; &#x2F;* y^0 &#x3D;&#x3D; 1 *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * c1 &#x3D; d1 y^p</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	c1 &#x3D; decay_load((u64)d1, periods);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 *            p-1</span><br><span class="line">	 * c2 &#x3D; 1024 \Sum y^n</span><br><span class="line">	 *            n&#x3D;1</span><br><span class="line">	 *</span><br><span class="line">	 *              inf        inf</span><br><span class="line">	 *    &#x3D; 1024 ( \Sum y^n - \Sum y^n - y^0 )</span><br><span class="line">	 *              n&#x3D;0        n&#x3D;p</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	c2 &#x3D; LOAD_AVG_MAX - decay_load(LOAD_AVG_MAX, periods) - 1024;</span><br><span class="line"></span><br><span class="line">	return c1 + c2 + c3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Accumulate the three separate parts of the sum; d1 the remainder</span><br><span class="line"> * of the last (incomplete) period, d2 the span of full periods and d3</span><br><span class="line"> * the remainder of the (incomplete) current period.</span><br><span class="line"> *</span><br><span class="line"> *           d1          d2           d3</span><br><span class="line"> *           ^           ^            ^</span><br><span class="line"> *           |           |            |</span><br><span class="line"> *         |&lt;-&gt;|&lt;-----------------&gt;|&lt;---&gt;|</span><br><span class="line"> * ... |---x---|------| ... |------|-----x (now)</span><br><span class="line"> *</span><br><span class="line"> *                           p-1</span><br><span class="line"> * u&#39; &#x3D; (u + d1) y^p + 1024 \Sum y^n + d3 y^0</span><br><span class="line"> *                           n&#x3D;1</span><br><span class="line"> *</span><br><span class="line"> *    &#x3D; u y^p +					(Step 1)</span><br><span class="line"> *</span><br><span class="line"> *                     p-1</span><br><span class="line"> *      d1 y^p + 1024 \Sum y^n + d3 y^0		(Step 2)</span><br><span class="line"> *                     n&#x3D;1</span><br><span class="line"> *&#x2F;</span><br><span class="line">static __always_inline u32</span><br><span class="line">accumulate_sum(u64 delta, struct sched_avg *sa,</span><br><span class="line">	       unsigned long load, unsigned long runnable, int running)</span><br><span class="line">&#123;</span><br><span class="line">	u32 contrib &#x3D; (u32)delta; &#x2F;* p &#x3D;&#x3D; 0 -&gt; delta &lt; 1024 *&#x2F;</span><br><span class="line">	u64 periods;</span><br><span class="line"></span><br><span class="line">	delta +&#x3D; sa-&gt;period_contrib;</span><br><span class="line">	periods &#x3D; delta &#x2F; 1024; &#x2F;* A period is 1024us (~1ms) *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Step 1: decay old *_sum if we crossed period boundaries.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (periods) &#123;</span><br><span class="line">		sa-&gt;load_sum &#x3D; decay_load(sa-&gt;load_sum, periods);</span><br><span class="line">		sa-&gt;runnable_load_sum &#x3D;</span><br><span class="line">			decay_load(sa-&gt;runnable_load_sum, periods);</span><br><span class="line">		sa-&gt;util_sum &#x3D; decay_load((u64)(sa-&gt;util_sum), periods);</span><br><span class="line"></span><br><span class="line">		&#x2F;*</span><br><span class="line">		 * Step 2</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		delta %&#x3D; 1024;</span><br><span class="line">		contrib &#x3D; __accumulate_pelt_segments(periods,</span><br><span class="line">				1024 - sa-&gt;period_contrib, delta);</span><br><span class="line">	&#125;</span><br><span class="line">	sa-&gt;period_contrib &#x3D; delta;</span><br><span class="line"></span><br><span class="line">	if (load)</span><br><span class="line">		sa-&gt;load_sum +&#x3D; load * contrib;</span><br><span class="line">	if (runnable)</span><br><span class="line">		sa-&gt;runnable_load_sum +&#x3D; runnable * contrib;</span><br><span class="line">	if (running)</span><br><span class="line">		sa-&gt;util_sum +&#x3D; contrib &lt;&lt; SCHED_CAPACITY_SHIFT;</span><br><span class="line"></span><br><span class="line">	return periods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p>其中 <code>___update_load_sum()</code> 函数 计算的都是<em>sum</em>负载总和，函数返回值是</p>
<ol>
<li>0，如果和上次更新时间之间 没有 经历过一次完整的period</li>
<li>1，如果和上次更新时间之间 经历过一次完整的period</li>
</ol>
<p>如果经历过一个 <code>full period</code>之后，就需要更新 <code>load_avg</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline void</span><br><span class="line">___update_load_avg(struct sched_avg *sa, unsigned long load, unsigned long runnable)</span><br><span class="line">&#123;</span><br><span class="line">	u32 divider &#x3D; LOAD_AVG_MAX - 1024 + sa-&gt;period_contrib;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Step 2: update *_avg.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	sa-&gt;load_avg &#x3D; div_u64(load * sa-&gt;load_sum, divider);</span><br><span class="line">	sa-&gt;runnable_load_avg &#x3D;	div_u64(runnable * sa-&gt;runnable_load_sum, divider);</span><br><span class="line">	WRITE_ONCE(sa-&gt;util_avg, sa-&gt;util_sum &#x2F; divider);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __update_load_avg_se(u64 now, struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	if (___update_load_sum(now, &amp;se-&gt;avg, !!se-&gt;on_rq, !!se-&gt;on_rq,</span><br><span class="line">				cfs_rq-&gt;curr &#x3D;&#x3D; se)) &#123;</span><br><span class="line"></span><br><span class="line">		___update_load_avg(&amp;se-&gt;avg, se_weight(se), se_runnable(se));</span><br><span class="line">		cfs_se_util_change(&amp;se-&gt;avg);</span><br><span class="line">		trace_pelt_se_tp(se);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>                      |&lt;--1024--&gt;|</code></pre>
<p>|———————————————|—|——|<br>                          |-|-|<br>                      period_contrib</p>
<p>divider = LOAD_AVG_MAX - (1024 - period_contrib)<br>    = LOAD_AVG_MAX - 1024 + period_contrib</p>
<p>可以大概理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load_avg &#x3D; load_weight * (load_sum &#x2F;  time_sum)</span><br><span class="line">util_avg &#x3D; util_sum &#x2F; time_sum</span><br></pre></td></tr></table></figure>


<p>当一个task一直运行，负载足够高时，可以认为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load_sum &#x3D;&#x3D;  time_sum</span><br><span class="line">util_sum &#x3D;&#x3D; time_sum</span><br><span class="line">load_avg &#x3D; load_weight</span><br><span class="line">util_avg &#x3D; 1</span><br></pre></td></tr></table></figure>

<h2 id="如何计算当前cfs-rq的负载"><a href="#如何计算当前cfs-rq的负载" class="headerlink" title="如何计算当前cfs_rq的负载"></a>如何计算当前cfs_rq的负载</h2><p>我们跟踪<code>se</code>的负载，更多的想更精确的知道每时每刻 <code>rq</code>上有负载变化，从而对scheduler的行为作出指导。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">int __update_load_avg_cfs_rq(u64 now, struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	if (___update_load_sum(now, &amp;cfs_rq-&gt;avg,</span><br><span class="line">				scale_load_down(cfs_rq-&gt;load.weight),</span><br><span class="line">				scale_load_down(cfs_rq-&gt;runnable_weight),</span><br><span class="line">				cfs_rq-&gt;curr !&#x3D; NULL)) &#123;</span><br><span class="line"></span><br><span class="line">		___update_load_avg(&amp;cfs_rq-&gt;avg, 1, 1);</span><br><span class="line">		trace_pelt_cfs_tp(cfs_rq);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * update_cfs_rq_load_avg - update the cfs_rq&#39;s load&#x2F;util averages</span><br><span class="line"> * @now: current time, as per cfs_rq_clock_pelt()</span><br><span class="line"> * @cfs_rq: cfs_rq to update</span><br><span class="line"> *</span><br><span class="line"> * The cfs_rq avg is the direct sum of all its entities (blocked and runnable)</span><br><span class="line"> * avg. The immediate corollary is that all (fair) tasks must be attached, see</span><br><span class="line"> * post_init_entity_util_avg().</span><br><span class="line"> *</span><br><span class="line"> * cfs_rq-&gt;avg is used for task_h_load() and update_cfs_share() for example.</span><br><span class="line"> *</span><br><span class="line"> * Returns true if the load decayed or we removed load.</span><br><span class="line"> *</span><br><span class="line"> * Since both these conditions indicate a changed cfs_rq-&gt;avg.load we should</span><br><span class="line"> * call update_tg_load_avg() when this function returns true.</span><br><span class="line"> *&#x2F;</span><br><span class="line"> &#x2F;*</span><br><span class="line"> * cfs_rq avg 是 cfs_rq中所有 entities 的 sum。</span><br><span class="line"> * 返回值：1 如果 有线程被移出这个 cfs_rq 或者经过了一个衰减周期</span><br><span class="line"> *        0</span><br><span class="line"> *&#x2F;</span><br><span class="line">static inline int</span><br><span class="line">update_cfs_rq_load_avg(u64 now, struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long removed_load &#x3D; 0, removed_util &#x3D; 0, removed_runnable_sum &#x3D; 0;</span><br><span class="line">	struct sched_avg *sa &#x3D; &amp;cfs_rq-&gt;avg;</span><br><span class="line">	int decayed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	if (cfs_rq-&gt;removed.nr) &#123;</span><br><span class="line">		unsigned long r;</span><br><span class="line">		u32 divider &#x3D; LOAD_AVG_MAX - 1024 + sa-&gt;period_contrib;</span><br><span class="line"></span><br><span class="line">		raw_spin_lock(&amp;cfs_rq-&gt;removed.lock);</span><br><span class="line">		swap(cfs_rq-&gt;removed.util_avg, removed_util);</span><br><span class="line">		swap(cfs_rq-&gt;removed.load_avg, removed_load);</span><br><span class="line">		swap(cfs_rq-&gt;removed.runnable_sum, removed_runnable_sum);</span><br><span class="line">		cfs_rq-&gt;removed.nr &#x3D; 0;</span><br><span class="line">		raw_spin_unlock(&amp;cfs_rq-&gt;removed.lock);</span><br><span class="line"></span><br><span class="line">		r &#x3D; removed_load;</span><br><span class="line">		sub_positive(&amp;sa-&gt;load_avg, r);</span><br><span class="line">		sub_positive(&amp;sa-&gt;load_sum, r * divider);</span><br><span class="line"></span><br><span class="line">		r &#x3D; removed_util;</span><br><span class="line">		sub_positive(&amp;sa-&gt;util_avg, r);</span><br><span class="line">		sub_positive(&amp;sa-&gt;util_sum, r * divider);</span><br><span class="line"></span><br><span class="line">		add_tg_cfs_propagate(cfs_rq, -(long)removed_runnable_sum);</span><br><span class="line"></span><br><span class="line">		decayed &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	decayed |&#x3D; __update_load_avg_cfs_rq(now, cfs_rq);</span><br><span class="line"></span><br><span class="line">#ifndef CONFIG_64BIT</span><br><span class="line">	smp_wmb();</span><br><span class="line">	cfs_rq-&gt;load_last_update_time_copy &#x3D; sa-&gt;last_update_time;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	return decayed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-04T11:00:40.000Z" title="3/4/2021, 7:00:40 PM">2021-03-04</time>发表</span><span class="level-item"><time dateTime="2021-07-22T09:21:52.820Z" title="7/22/2021, 5:21:52 PM">2021-07-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">2 分钟读完 (大约262个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/04/interrupt/%E5%92%8C%E4%B8%AD%E6%96%AD%E6%8A%A2%E5%8D%A0%E7%9B%B8%E5%85%B3api/">和中断抢占相关api</a></h1><div class="content"><h2 id="开关关中断api"><a href="#开关关中断api" class="headerlink" title="开关关中断api"></a>开关关中断api</h2><p>api1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define local_irq_enable()	do &#123; raw_local_irq_enable(); &#125; while (0)</span><br><span class="line">#define local_irq_disable()	do &#123; raw_local_irq_disable(); &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>api2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define local_irq_save(flags)	do &#123; raw_local_irq_save(flags); &#125; while (0)</span><br><span class="line">#define local_irq_restore(flags) do &#123; raw_local_irq_restore(flags); &#125; while (0)</span><br></pre></td></tr></table></figure>



<h2 id="this-cpu-read-amp-amp-this-cpu-read"><a href="#this-cpu-read-amp-amp-this-cpu-read" class="headerlink" title="__this_cpu_read &amp;&amp; this_cpu_read"></a>__this_cpu_read &amp;&amp; this_cpu_read</h2><h3 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h3><p>可以在中断上下文中使用，无需考虑被中断或者进程强占</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Operations for contexts that are safe from preemption&#x2F;interrupts.  These</span><br><span class="line"> * operations verify that preemption is disabled.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define __this_cpu_read(pcp)						\</span><br><span class="line">(&#123;									\</span><br><span class="line">	__this_cpu_preempt_check(&quot;read&quot;);				\</span><br><span class="line">	raw_cpu_read(pcp);						\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#define __this_cpu_write(pcp, val)					\</span><br><span class="line">(&#123;									\</span><br><span class="line">	__this_cpu_preempt_check(&quot;write&quot;);				\</span><br><span class="line">	raw_cpu_write(pcp, val);					\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>可以在进程上下文中使用，实现了 强占、中断保护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Operations with implied preemption&#x2F;interrupt protection.  These</span><br><span class="line"> * operations can be used without worrying about preemption or interrupt.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define this_cpu_read(pcp)		__pcpu_size_call_return(this_cpu_read_, pcp)</span><br><span class="line">#define this_cpu_write(pcp, val)	__pcpu_size_call(this_cpu_write_, pcp, val)</span><br></pre></td></tr></table></figure>

<p>参考<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?id=8afecaa68df1e94a9d634f1f961533a925f239fc">patch1</a><br>参考<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?id=17c891ab349138e8d8a59ca2700f42ce8af96f4e">patch2</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-04T11:00:40.000Z" title="3/4/2021, 7:00:40 PM">2021-03-04</time>发表</span><span class="level-item"><time dateTime="2021-03-08T08:11:46.200Z" title="3/8/2021, 4:11:46 PM">2021-03-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">7 分钟读完 (大约1013个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/04/interrupt/hrtimer/">hrtimer</a></h1><div class="content"><p>hrtimer没有使用时间轮对定时器进行管理，而是选用了更加通用、性能稳定的红黑树。红黑树查找，插入和删除平均时间复杂度是O(logN)。虽然查找的时间复杂度达不到O(1)，但是避免了时间轮的迁移。</p>
<p>因此在平均性能上红黑树和时间轮会较为接近。 hrtimer红黑树是在红黑树的基础上做了简单的封装，hrtimer红黑树节点使用数据结构struct timerqueue_node，比rb_node多了一个expires字段，用于记录超时时刻。<br>hrtimer的数据结构与动态定时器的数据结构类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">struct timerqueue_node &#123;</span><br><span class="line">	struct rb_node node;</span><br><span class="line">	ktime_t expires;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; include&#x2F;linux&#x2F;hrtimer.h</span><br><span class="line">&#x2F;**</span><br><span class="line"> * struct hrtimer - the basic hrtimer structure</span><br><span class="line"> * @node:	timerqueue node, which also manages node.expires,</span><br><span class="line"> *		the absolute expiry time in the hrtimers internal</span><br><span class="line"> *		representation. The time is related to the clock on</span><br><span class="line"> *		which the timer is based. Is setup by adding</span><br><span class="line"> *		slack to the _softexpires value. For non range timers</span><br><span class="line"> *		identical to _softexpires.</span><br><span class="line"> * @_softexpires: the absolute earliest expiry time of the hrtimer.</span><br><span class="line"> *		The time which was given as expiry time when the timer</span><br><span class="line"> *		was armed.</span><br><span class="line"> * @function:	timer expiry callback function</span><br><span class="line"> * @base:	pointer to the timer base (per cpu and per clock)</span><br><span class="line"> * @state:	state information (See bit values above)</span><br><span class="line"> * @is_rel:	Set if the timer was armed relative</span><br><span class="line"> * @is_soft:	Set if hrtimer will be expired in soft interrupt context.</span><br><span class="line"> * @is_hard:	Set if hrtimer will be expired in hard interrupt context</span><br><span class="line"> *		even on RT.</span><br><span class="line"> *</span><br><span class="line"> * The hrtimer structure must be initialized by hrtimer_init()</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct hrtimer &#123;</span><br><span class="line">	struct timerqueue_node		node;</span><br><span class="line">	ktime_t				_softexpires;</span><br><span class="line">	enum hrtimer_restart		(*function)(struct hrtimer *);</span><br><span class="line">	struct hrtimer_clock_base	*base;</span><br><span class="line">	u8				state;</span><br><span class="line">	u8				is_rel;</span><br><span class="line">	u8				is_soft;</span><br><span class="line">	u8				is_hard;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * struct hrtimer_sleeper - simple sleeper structure</span><br><span class="line"> * @timer:	embedded timer structure</span><br><span class="line"> * @task:	task to wake up</span><br><span class="line"> *</span><br><span class="line"> * task is set to NULL, when the timer expires.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct hrtimer_sleeper &#123;</span><br><span class="line">	struct hrtimer timer;</span><br><span class="line">	struct task_struct *task;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>hrtimer和动态定时器一样拥有超时计数字段_softexpires和超时后的回调函数。 通过比较当前时间是否大于_softexpires来决定定时器超时，执行回调函数。 在红黑树的node中同样保存了一份expires，node.expires大于等于_softexpires。 这样做的目的是在高精度模式下，在_softexpires到node.expires期间设定定时器被触发的时间。</p>
<p>hrtimer管理器结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct hrtimer_cpu_base &#123;</span><br><span class="line">	raw_spinlock_t			lock;</span><br><span class="line">	unsigned int			cpu;</span><br><span class="line">	unsigned int			active_bases;</span><br><span class="line">	unsigned int			clock_was_set_seq;</span><br><span class="line">	unsigned int			hres_active		: 1,</span><br><span class="line">					in_hrtirq		: 1,</span><br><span class="line">					hang_detected		: 1,</span><br><span class="line">					softirq_activated       : 1;</span><br><span class="line">#ifdef CONFIG_HIGH_RES_TIMERS</span><br><span class="line">	unsigned int			nr_events;</span><br><span class="line">	unsigned short			nr_retries;</span><br><span class="line">	unsigned short			nr_hangs;</span><br><span class="line">	unsigned int			max_hang_time;</span><br><span class="line">#endif</span><br><span class="line">	ktime_t				expires_next;</span><br><span class="line">	struct hrtimer			*next_timer;</span><br><span class="line">	ktime_t				softirq_expires_next;</span><br><span class="line">	struct hrtimer			*softirq_next_timer;</span><br><span class="line">	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>

<p><code>running</code> 字段指向正在执行的 <code>hrtimer</code>。 next_timer字段指向第一个超时的hrtimer。 clock_base字段是当前CPU维护的定时器树。 目前每个CPU都维护了若干组定时器树，其中包括单条递增时间HRTIMER_BASE_MONOTONIC,上墙时间HRTIMER_BASE_REALTIME等。<br>。</p>
<p>hrtimer有两种精度模式，高精度模式和低精度模式。那么同样的数据设计，如何实现两种精度呢？ 这里的关键就是调用检查hrtimer函数的地方。我们来看看两种精度的调用栈。</p>
<p>低精度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer_interrupt() -&gt; update_process_times() -&gt; run_local_timers() -&gt; hrtimer_run_queues() -&gt; __hrtimer_run_queues()</span><br></pre></td></tr></table></figure>

<p>高精度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hrtimer_interrupt() -&gt; __hrtimer_run_queues()</span><br></pre></td></tr></table></figure>

<p>当hrtimer处于低精度模式时，每次irq0上的时间中断，即每次tick事件，调用一次检查hrtimer函数。 tick的频率是1000hz，此时，hrtimer处于低精度模式。 在第一篇文章中，我们提到TSC、HPET都是可以提供纳秒级的时间设备。 当hrtimer处于高精度模式时，Linux把hrtimer_interrupt()绑定到高精度的时间设备，这时就可以提供纳秒级的定时器服务了。 但是频繁的调用检查hrtimer函数会非常消耗机器性能。 为了避免这个缺陷，hrtimer_interrupt()的调用采用了one-shot的模式。每一次调用都会设定下一次调用的时间。</p>
<p>参考<a target="_blank" rel="noopener" href="http://rangechow.com/2016/04/19/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%AE%9A%E6%97%B6%E5%99%A8Hrtimer.html">高精度定时器Hrtimer</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-01T11:00:40.000Z" title="3/1/2021, 7:00:40 PM">2021-03-01</time>发表</span><span class="level-item"><time dateTime="2021-03-01T07:06:10.303Z" title="3/1/2021, 3:06:10 PM">2021-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">2 分钟读完 (大约254个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/01/interrupt/interrupt%20storm/">interrupt storm</a></h1><div class="content"><p>记录一下<code>hrtimer</code>使用问题导致的 <code>interrupt storm</code> （中断风暴）。</p>
<h2 id="hrtimer使用"><a href="#hrtimer使用" class="headerlink" title="hrtimer使用"></a>hrtimer使用</h2><ol>
<li><p>只想使用一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init -&gt; start -&gt; [return HRTIMER_NORESTART;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>想使用多次，timer 一直存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init -&gt; start -&gt; [hrtimer_forward_now; return HRTIMER_NORESTART;]</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>参考<a target="_blank" rel="noopener" href="https://github.com/liulangrenaaa/test_modules/blob/main/misc/hrtimer/hrtimer.c">代码</a></p>
<p>init:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hrtimer_init( &amp;hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span><br><span class="line">hr_timer.function &#x3D; &amp;my_hrtimer_callback;</span><br></pre></td></tr></table></figure>

<p>start:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hrtimer_start(&amp;hr_timer, ms_to_ktime(500), HRTIMER_MODE_REL);</span><br></pre></td></tr></table></figure>

<p>callback: (产生中断风暴)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int once_timer &#x3D; 1;</span><br><span class="line">int interrupt_storm &#x3D; 0;</span><br><span class="line"></span><br><span class="line">enum hrtimer_restart my_hrtimer_callback( struct hrtimer *hr_timer)</span><br><span class="line">&#123;</span><br><span class="line">	printk(&quot;my_hrtimer_callback called (%ld).\n&quot;, jiffies );</span><br><span class="line"></span><br><span class="line">	if (interrupt_storm) &#123;</span><br><span class="line">		if (once_timer) &#123;</span><br><span class="line">			return HRTIMER_NORESTART;</span><br><span class="line">		&#125;</span><br><span class="line">		hrtimer_forward_now(hr_timer, ms_to_ktime(500));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return HRTIMER_RESTART;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="中断风暴"><a href="#中断风暴" class="headerlink" title="中断风暴"></a>中断风暴</h2><p>安装这个模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stable_kernel@kernel: &#x2F;tmp&#x2F;share&#x2F;test_modules&#x2F;misc&#x2F;hrtimer# sudo insmod hrtimer.ko</span><br></pre></td></tr></table></figure>

<p>产生如下警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ 1130.893739] rcu: INFO: rcu_sched detected stalls on CPUs&#x2F;tasks:</span><br><span class="line">[ 1130.893750] rcu: 	3-...0: (5 GPs behind) idle&#x3D;b3e&#x2F;0&#x2F;0x1 softirq&#x3D;17149&#x2F;17149 fqs&#x3D;6500</span><br><span class="line">[ 1208.887926] rcu: INFO: rcu_sched detected stalls on CPUs&#x2F;tasks:</span><br><span class="line">[ 1208.888716] rcu: 	3-...0: (5 GPs behind) idle&#x3D;b3e&#x2F;0&#x2F;0x1 softirq&#x3D;17149&#x2F;17149 fqs&#x3D;24703</span><br><span class="line"></span><br><span class="line">rlk-Standard-PC-i440FX-PIIX-1996 login:</span><br><span class="line">rlk-Standard-PC-i440FX-PIIX-1996 login: [ 1286.883226] rcu: INFO: rcu_sched detected stalls on CPUs&#x2F;tasks:</span><br><span class="line">[ 1286.884781] rcu: 	3-...0: (5 GPs behind) idle&#x3D;b3e&#x2F;0&#x2F;0x1 softirq&#x3D;17149&#x2F;17149 fqs&#x3D;42700</span><br></pre></td></tr></table></figure>


<p>然后<code>crash</code>,看现场信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>






























</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-26T11:00:40.000Z" title="2/26/2021, 7:00:40 PM">2021-02-26</time>发表</span><span class="level-item"><time dateTime="2021-03-01T05:20:02.847Z" title="3/1/2021, 1:20:02 PM">2021-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">4 分钟读完 (大约565个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/26/rcu/rcu%E7%AE%80%E4%BB%8B/">rcu简介</a></h1><div class="content"><p>RCU顾名思义–Read Copy Update，我的理解是：<br>读者直接读，没有任何开销，写者需要先Copy，然后等待合适的时机(宽限期)，去更新 Update。</p>
<p>记得之前有一道笔试题叫 无锁编程？<br>现在想想应该是有以下几类吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 原子操作</span><br><span class="line">2. CAS操作</span><br><span class="line">3. 使用rcu编程</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h2 id="WHY-RCU"><a href="#WHY-RCU" class="headerlink" title="WHY RCU?"></a>WHY RCU?</h2><p>在RCU的实现过程中，我们主要解决以下问题：</p>
<ol>
<li>在读取过程中，另外一个线程删除了一个节点。删除线程可以把这个节点从链表中移除，但它不能直接销毁这个节点，必须等到所有的读取线程读取完成以后，才进行销毁操作。RCU中把这个过程称为宽限期（Grace period）。</li>
<li>在读取过程中，另外一个线程插入了一个新节点，而读线程读到了这个节点，那么需要保证读到的这个节点是完整的。这里涉及到了发布-订阅机制（Publish-Subscribe Mechanism）。</li>
<li>保证读取链表的完整性。新增或者删除一个节点，不至于导致遍历一个链表从中间断开。但是RCU并不保证一定能读到新增的节点或者不读到要被删除的节点。</li>
</ol>
<p>关于 RCU 和 其他锁的性能对比:</p>
<ol>
<li>RCU 的性能优势（scalblity）往往体现在多核上</li>
<li>相对于 rwlock等锁来说，RCU的效率可以高到10 - 100倍</li>
</ol>
<h2 id="rcu-的编程API"><a href="#rcu-的编程API" class="headerlink" title="rcu 的编程API"></a>rcu 的编程API</h2><p>For reader:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rcu_read_lock(void);</span><br><span class="line">rcu_read_unlock(void);</span><br><span class="line">rcu_read_lock_bh(void);</span><br><span class="line">rcu_read_unlock_bh(void);</span><br></pre></td></tr></table></figure>

<p>For writer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void call_rcu(struct rcu_head *head, rcu_callback_t func);</span><br><span class="line">void synchronize_rcu(void);</span><br><span class="line"></span><br><span class="line">#define rcu_assign_pointer(p, v)</span><br><span class="line">#define rcu_replace_pointer(rcu_ptr, ptr, c)</span><br><span class="line">rcu_dereferencercu_read_unlock(void);</span><br></pre></td></tr></table></figure>

<p>和调度器相关的 API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __sched notrace __schedule(bool preempt)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">	rcu_note_context_switch(preempt);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RCU类型"><a href="#RCU类型" class="headerlink" title="RCU类型"></a>RCU类型</h2><p><code>TINY RCU</code> 一般只有arm32 UP系统使用了，使用场景很少。<br><code>TREE RCU</code> 从4核 到 1024 核心都可以很好的支持。</p>
<p>arm64平台 和 x86平台 defconfig 都是使用的是 <code>TREE RCU</code>。<br>所以重点还是放在 <code>TREE RCU</code>，同时需要关注 <code>SRCU</code>。</p>
<h2 id="CONFIG-PREEMPT-RCU"><a href="#CONFIG-PREEMPT-RCU" class="headerlink" title="CONFIG_PREEMPT_RCU"></a>CONFIG_PREEMPT_RCU</h2><p>抢占式 RCU含义是？</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-25T11:00:40.000Z" title="2/25/2021, 7:00:40 PM">2021-02-25</time>发表</span><span class="level-item"><time dateTime="2021-04-19T01:49:45.960Z" title="4/19/2021, 9:49:45 AM">2021-04-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">5 分钟读完 (大约679个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/25/mycase/softlockup%20+%20rcu%20+%20oom/">softlockup + rcu + oom</a></h1><div class="content"><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>产生oom，业务A被干掉了</p>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><ol>
<li>根据oom现场 dump的信息查看 各个进程都没有占用太多内存，排除<code>用户空间进程内存泄漏</code></li>
<li>查看 <code>slab</code> 信息，发现确实有某些<code>slab</code> 变得很大，发现是图传驱动创建的一个slab。</li>
<li>严重 怀疑是 <code>slab 内存泄漏</code>，最后导致的内存泄漏，排查相关<code>create alloc free</code> 代码之后，没什么收获。</li>
<li>使用 bpftrace 跟踪 申请释放的kprobe点，跟踪几分钟，十几分钟，看 输出几乎是成对出现的，应该不存在 <code>slab内存泄漏</code></li>
<li>查看驱动自己封装的接口，发现<code>释放slab</code> 是直接使用 call_rcu()的一个接口，怀疑可能是跟 call_rcu接口有关系。</li>
<li>rcu 涉及到 宽限期的问题，怀疑可能是某个 cpu 发生了 softlockup 或者不调度，部署panic_on_oom 抓取现场。</li>
<li>看到确实有 一个驱动线程 一直占用cpu,看这个线程的 backtrace发现是在一个驱动的重新初始化上 一直 while，且之前获取过 spin_lock()，这样就基本构成了发生 softlockup的必要条件，之所以没有看到softlockup的原因就是时间还没到。</li>
<li>到这一步，大概基本80～90%怀疑是 驱动代码 + 外设导致的 softlockup，最后导致rcu的宽限期不能通过，导致slab不能延迟释放，最后导致的 oom。</li>
<li>然后尝试手动触发一个 <code>softlockup</code>，来尝试复现这个问题，但是一直只能的到 softlockup的警告，并不能复现 oom的情况？</li>
<li>最后发现slab积累 释放的速率 和 业务场景有很大关系，研发机器经常烧录，在烧录之后参数区丢失，导致图传模式一直是默认模式，slab申请释放速率较低，但是QA都是OTA升级，一般使用 高画质，slab 申请释放 会比默认模式快很多，这也是为什么我本地不能复现这个 oom bug的原因。</li>
</ol>
<p>大概流程是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------+</span><br><span class="line">|    驱动先spin_lock之后，while等待  |</span><br><span class="line">|    一个初始化信号，由于外设异常，导致 |</span><br><span class="line">|    一直在while中,无法退出          |</span><br><span class="line">+-----------+---------------------+</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">            v</span><br><span class="line">+-----------+----------------------------+</span><br><span class="line">|                                         |</span><br><span class="line">|  具备产生 softlockup 的条件,              |</span><br><span class="line">|  但是时间还是比较短，所以还未发生            |</span><br><span class="line">|  softlockup                             |</span><br><span class="line">+----------+-----------------------------+</span><br><span class="line">           |</span><br><span class="line">           |</span><br><span class="line">           |</span><br><span class="line">+----------v-----------------------------+</span><br><span class="line">|                                        |</span><br><span class="line">|    系统中rcu的宽限期过不了，               |</span><br><span class="line">|    导致业务驱动使用频繁的slab积累          |</span><br><span class="line">|    太多看起来和slab内存泄漏一样            |</span><br><span class="line">|                                        |</span><br><span class="line">+---------+------------------------------+</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">+---------v-------------------+</span><br><span class="line">|                             |</span><br><span class="line">|  系统内存不足，导致oom         |</span><br><span class="line">|                             |</span><br><span class="line">+-----------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-22T11:00:40.000Z" title="2/22/2021, 7:00:40 PM">2021-02-22</time>发表</span><span class="level-item"><time dateTime="2021-04-19T01:49:13.970Z" title="4/19/2021, 9:49:13 AM">2021-04-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">4 分钟读完 (大约624个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/22/mycase/sched%20latency%20+%20memory%20direct%20reclaim/">sched latency + memory direct reclaim</a></h1><div class="content"><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>UAV在空中悬停，同时下载拍摄的视频到手机中，会导致飞机漂移较多。<br>飞控反馈说是感知的深度图数据频率不对，导致姿态问题。<br>感知深度图传输流程是linux侧的一个 hrtimer 中释放一个信号量给一个线程，驱动内核线程中会处理相关的数据然后给Cortex M核发送一个中断，飞控从中断中获得数据。<br>异构SOC上，Cortex-M核心反馈说 linux上送出去的数据延迟不确定，有时候会很大。</p>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><ol>
<li>首先看了 hrtimer的配置，基本没有问题，排除hrtimer频率不稳定导致的问题</li>
<li>怀疑是 hrtimer中，release sema之后，由于系统调度延迟很大，导致的线程没有及时投入运行，最后导致时间很不稳定</li>
<li>使用 <code>perf sched</code>抓取实际的调度相关数据，发现在未在空中飞行的时候<code>sched latency</code>是一个比较正常的值，由于 <code>perf</code> 运行时的overhead 较大，也不能直接将 perf部署之后飞上天。</li>
<li>寻找了 <code>bytedance</code>的开源工具<code>trace_noschedule</code>，其实就是一个内核模块；原理主要是一个hrtimer一直在采样，可以设置一个阈值a，可以将调度延迟大于多少的进程stack直接记录下来。</li>
<li>部署之后看了调度延迟之后，同场景测试之后，还是会出现飞机漂移，但是没有调度延迟特别高的线程。</li>
<li>只能关注系统其他类型的资源了，比如 memory io等，使用 <code>sar -B 1</code>在实际场景中测试发现他的<br>直接内存回收指标非常高</li>
<li>怀疑是 处理的驱动线程，在处理图像数据的时候，会申请较多内存导致的内存分配延迟较高，最后处理深度图时间从原来2ms，直接延长到10ms以上，导致linux -&gt; rtos中断不及时。</li>
<li>bpftrace vmscan_direct_reclaim_[begin,end] 相关接口，果然是 触发了内存直接回收，且看时间戳，延迟时间有10ms以上，找到问题根源</li>
<li>可以调整 vm_free_kbytes，使得 min 与 low水位之间间距变大，更早触发 kswapd 内存回收，更难触发 <code>direct reclaim</code>。</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-19T11:00:00.000Z" title="2/19/2021, 7:00:00 PM">2021-02-19</time>发表</span><span class="level-item"><time dateTime="2021-03-01T08:38:13.435Z" title="3/1/2021, 4:38:13 PM">2021-03-01</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></span><span class="level-item">11 分钟读完 (大约1578个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/19/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/task_struct%20%E5%92%8C%20thread_info%E7%BB%93%E6%9E%84/">task_struct 和 thread_info结构</a></h1><div class="content"><p>本文基于 <code>Linux 5.10</code> 代码，由于相关结构变化较大，不去考古以前代码了。</p>
<h2 id="什么是内核栈？"><a href="#什么是内核栈？" class="headerlink" title="什么是内核栈？"></a>什么是内核栈？</h2><p>进程在内核态运行时需要自己的堆栈信息，因此linux内核为每个进程都提供了一个内核栈<code>kernel stack</code>(这里的stack就是这个进程在内核态的堆栈信息！！！)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">#ifdef CONFIG_THREAD_INFO_IN_TASK</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * For reasons of header soup (see current_thread_info()), this</span><br><span class="line">	 * must be the first element of task_struct.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct thread_info		thread_info;</span><br><span class="line">#endif</span><br><span class="line">	void				*stack;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>void *stack</code> 就是栈指针，指针指向哪里呢？</p>
<p>内核态的进程访问处于内核数据段的栈，这个栈不同于用户态的进程所用的栈。<br>用户态进程所用的栈，是在进程线性地址空间中；</p>
<p>而内核栈是当进程从用户空间进入内核空间时，特权级发生变化，需要切换堆栈，内核空间中使用的就是这个内核栈。<br>因为内核控制路径使用很少的栈空间，所以只需要几千个字节的内核态堆栈。</p>
<h2 id="thread-info"><a href="#thread-info" class="headerlink" title="thread_info"></a>thread_info</h2><p>内核栈还需要存储每个进程的PCB信息,linux内核是支持不同体系的,但是不同的体系结构可能进程需要存储<br>的信息不尽相同,这就需要我们实现一种通用的方式,我们将体系结构相关的部分和无关的部分进行分离。</p>
<ol>
<li>用一种通用的方式来描述进程, 这就是struct task_struct</li>
<li>而thread_info就保存了特定体系结构的汇编代码段需要访问的那部分进程的数据<br>目前基本的配置中（x86_64、我们公司arm64平台都是开启了这个<code>CONFIG_THREAD_INFO_IN_TASK</code>）</li>
</ol>
<p>想通过 从 <code>task_struct</code> 找到 <code>thread_info</code> 就很简单了，直接结构体访问变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_THREAD_INFO_IN_TASK</span><br><span class="line">static inline struct thread_info *task_thread_info(struct task_struct *task)</span><br><span class="line">&#123;</span><br><span class="line">	return &amp;task-&gt;thread_info;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define current_thread_info() ((struct thread_info *)current)</span><br></pre></td></tr></table></figure>

<p>x86 架构中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct thread_info &#123;</span><br><span class="line">	unsigned long		flags;		&#x2F;* low level flags *&#x2F;</span><br><span class="line">	unsigned long		syscall_work;	&#x2F;* SYSCALL_WORK_ flags *&#x2F;</span><br><span class="line">	u32			status;		&#x2F;* thread synchronous flags *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>arm64架构中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct thread_info &#123;</span><br><span class="line">	unsigned long		flags;		&#x2F;* low level flags *&#x2F;</span><br><span class="line">#ifdef CONFIG_ARM64_SW_TTBR0_PAN</span><br><span class="line">	u64			ttbr0;		&#x2F;* saved TTBR0_EL1 *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">	union &#123;</span><br><span class="line">		u64		preempt_count;	&#x2F;* 0 &#x3D;&gt; preemptible, &lt;0 &#x3D;&gt; bug *&#x2F;</span><br><span class="line">		struct &#123;</span><br><span class="line">			u32	count;</span><br><span class="line">			u32	need_resched;</span><br><span class="line">		&#125; preempt;</span><br><span class="line">	&#125;;</span><br><span class="line">#ifdef CONFIG_SHADOW_CALL_STACK</span><br><span class="line">	void			*scs_base;</span><br><span class="line">	void			*scs_sp;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="如何直接找到-task-struct"><a href="#如何直接找到-task-struct" class="headerlink" title="如何直接找到 task_struct"></a>如何直接找到 <code>task_struct</code></h2><p>这就涉及到<code>thread_union</code>这个结构了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">union thread_union &#123;</span><br><span class="line">#ifndef CONFIG_ARCH_TASK_STRUCT_ON_STACK</span><br><span class="line">	struct task_struct task;</span><br><span class="line">#endif</span><br><span class="line">	unsigned long stack[THREAD_SIZE&#x2F;sizeof(long)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>我们大部分平台都是开启这个<code>CONFIG_ARCH_TASK_STRUCT_ON_STACK</code>宏定义的<br><code>arm64</code> <code>x86</code> 栈都是向下生长，这个结构大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">            +---------------------+</span><br><span class="line"> stack[8k]  |---------------------|  +</span><br><span class="line">            ||                   ||  |</span><br><span class="line">            ||                   ||  |</span><br><span class="line">            ||                   ||  |</span><br><span class="line">            ||                   ||  | Grow Down</span><br><span class="line">            ||                   ||  |</span><br><span class="line">            ||                   ||  |</span><br><span class="line">            ||                   ||  |</span><br><span class="line">            ||                   ||  |</span><br><span class="line">            ||                   ||  |</span><br><span class="line">            ||                   ||  |</span><br><span class="line">  sp&lt;----   +---------------------+  |</span><br><span class="line">            |                     |  |</span><br><span class="line">            |                     |  |</span><br><span class="line">            |                     |  |</span><br><span class="line">            |                     |  |</span><br><span class="line">            |                     |  |</span><br><span class="line">            |                     |  v</span><br><span class="line">            |                     |</span><br><span class="line">            |                     |</span><br><span class="line">            |                     |</span><br><span class="line">            |                     |</span><br><span class="line">            | +-----------------+ |</span><br><span class="line">            | |                 | |</span><br><span class="line">            | |                 | |</span><br><span class="line">            | |                 | |</span><br><span class="line">            | |                 | | +------&gt;   struct task_struct</span><br><span class="line">            | |                 | |</span><br><span class="line">            | |                 | |</span><br><span class="line">            | |                 | |</span><br><span class="line">            | |                 | |</span><br><span class="line">            | |                 | |</span><br><span class="line">            | +-----------------+ |</span><br><span class="line">            | |                 | |</span><br><span class="line">            | |                 | | +------&gt;   struct thread_info</span><br><span class="line">stack[0]    | +-----------------+ |</span><br><span class="line">            +---------------------+</span><br></pre></td></tr></table></figure>

<p>有个细节没有体现出来，就是task-&gt;stack应该指向 最下面。</p>
<p>我们可以通过 <code>current()</code> 获得当前正在运行的线程的 <code>task_struct</code> 结构：<br>arm64 平台</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static __always_inline struct task_struct *get_current(void)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long sp_el0;</span><br><span class="line"></span><br><span class="line">	asm (&quot;mrs %0, sp_el0&quot; : &quot;&#x3D;r&quot; (sp_el0));</span><br><span class="line"></span><br><span class="line">	return (struct task_struct *)sp_el0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define current get_current()</span><br></pre></td></tr></table></figure>
<p>ARM64增加了很多通用寄存器，使用寄存器传递进程描述符显然效率更高。<br>因此在ARM64架构里，current宏不再通过栈偏移量得到进程描述符地址，而是借用专门的寄存器 <code>sp_el0</code>。</p>
<p>ARM64使用sp_el0，在进程切换时暂存进程描述符地址。</p>
<p>可以看arm64 进程切换arch相关代码(arch/arm64/kernel/entry.S)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Register switch for AArch64. The callee-saved registers need to be saved</span><br><span class="line"> * and restored. On entry:</span><br><span class="line"> *   x0 &#x3D; previous task_struct (must be preserved across the switch)</span><br><span class="line"> *   x1 &#x3D; next task_struct</span><br><span class="line"> * Previous and next are guaranteed not to be the same.</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">SYM_FUNC_START(cpu_switch_to)</span><br><span class="line">	mov	x10, #THREAD_CPU_CONTEXT</span><br><span class="line">	add	x8, x0, x10</span><br><span class="line">	mov	x9, sp</span><br><span class="line">	stp	x19, x20, [x8], #16		&#x2F;&#x2F; store callee-saved registers</span><br><span class="line">	stp	x21, x22, [x8], #16</span><br><span class="line">	stp	x23, x24, [x8], #16</span><br><span class="line">	stp	x25, x26, [x8], #16</span><br><span class="line">	stp	x27, x28, [x8], #16</span><br><span class="line">	stp	x29, x9, [x8], #16</span><br><span class="line">	str	lr, [x8]</span><br><span class="line">	add	x8, x1, x10</span><br><span class="line">	ldp	x19, x20, [x8], #16		&#x2F;&#x2F; restore callee-saved registers</span><br><span class="line">	ldp	x21, x22, [x8], #16</span><br><span class="line">	ldp	x23, x24, [x8], #16</span><br><span class="line">	ldp	x25, x26, [x8], #16</span><br><span class="line">	ldp	x27, x28, [x8], #16</span><br><span class="line">	ldp	x29, x9, [x8], #16</span><br><span class="line">	ldr	lr, [x8]</span><br><span class="line">	mov	sp, x9</span><br><span class="line">	msr	sp_el0, x1</span><br><span class="line">	ptrauth_keys_install_kernel x1, x8, x9, x10</span><br><span class="line">	scs_save x0, x8</span><br><span class="line">	scs_load x1, x8</span><br><span class="line">	ret</span><br><span class="line">SYM_FUNC_END(cpu_switch_to)</span><br><span class="line">NOKPROBE(cpu_switch_to)</span><br></pre></td></tr></table></figure>

<p>线程切换的时候<br>THREAD_CPU_CONTEXT –&gt; x10<br>x8 保存的压栈大小<br>x10 + x8 –&gt; x1<br>x1 –&gt; sp_el0</p>
<p><code>THREAD_CPU_CONTEXT</code> 是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">DEFINE(THREAD_CPU_CONTEXT,	offsetof(struct task_struct, thread.cpu_context));</span><br><span class="line"></span><br><span class="line">struct task_struct &#123;</span><br><span class="line">	&#x2F;* CPU-specific state of this task: *&#x2F;</span><br><span class="line">	struct thread_struct		thread;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * WARNING: on x86, &#39;thread_struct&#39; contains a variable-sized</span><br><span class="line">	 * structure.  It *MUST* be at the end of &#39;task_struct&#39;.</span><br><span class="line">	 *</span><br><span class="line">	 * Do not put anything below here!</span><br><span class="line">	 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct thread_struct &#123;</span><br><span class="line">	struct cpu_context	cpu_context;	&#x2F;* cpu context *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Whitelisted fields for hardened usercopy:</span><br><span class="line">	 * Maintainers must ensure manually that this contains no</span><br><span class="line">	 * implicit padding.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct &#123;</span><br><span class="line">		unsigned long	tp_value;	&#x2F;* TLS register *&#x2F;</span><br><span class="line">		unsigned long	tp2_value;</span><br><span class="line">		struct user_fpsimd_state fpsimd_state;</span><br><span class="line">	&#125; uw;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct cpu_context &#123;</span><br><span class="line">	unsigned long x19;</span><br><span class="line">	unsigned long x20;</span><br><span class="line">	unsigned long x21;</span><br><span class="line">	unsigned long x22;</span><br><span class="line">	unsigned long x23;</span><br><span class="line">	unsigned long x24;</span><br><span class="line">	unsigned long x25;</span><br><span class="line">	unsigned long x26;</span><br><span class="line">	unsigned long x27;</span><br><span class="line">	unsigned long x28;</span><br><span class="line">	unsigned long fp;</span><br><span class="line">	unsigned long sp;</span><br><span class="line">	unsigned long pc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后面需要更加详细 分析，有空再学习一下然后写。</p>
<p>struct thread_struct &amp; struct pt_regs的区别<br>thread_struct结构体主要是在内核态两个进程发生切换时，thread_struct用来保存上一个进程的相关寄存器。<br>pt_regs结构体主要是当用户态的进程陷入到内核态时，需要使用pt_regs来保存用户态进程的寄存器状态。</p>
<p>x86 平台</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_PER_CPU(struct task_struct *, current_task);</span><br><span class="line"></span><br><span class="line">static __always_inline struct task_struct *get_current(void)</span><br><span class="line">&#123;</span><br><span class="line">	return this_cpu_read_stable(current_task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define current get_current()</span><br></pre></td></tr></table></figure>
<p>在 x86 平台中，直接使用了 一个 <code>percpu</code> 变量来缓存 <code>current_task</code> 指针</p>
<p>example: (x86 架构)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">WARNING: kernel relocated [512MB]: patching 137921 gdb minimal_symbol values                                                        [26&#x2F;162]</span><br><span class="line"></span><br><span class="line">      KERNEL: vmlinux</span><br><span class="line">    DUMPFILE: dump.202103011631  [PARTIAL DUMP]</span><br><span class="line">        CPUS: 4</span><br><span class="line">        DATE: Mon Mar  1 16:31:27 CST 2021</span><br><span class="line">      UPTIME: 00:02:00</span><br><span class="line">LOAD AVERAGE: 1.63, 0.53, 0.19</span><br><span class="line">       TASKS: 449</span><br><span class="line">    NODENAME: rlk-Standard-PC-i440FX-PIIX-1996</span><br><span class="line">     RELEASE: 5.12.0-rc1</span><br><span class="line">     VERSION: #24 SMP Mon Mar 1 14:25:47 CST 2021</span><br><span class="line">     MACHINE: x86_64  (3693 Mhz)</span><br><span class="line">      MEMORY: 4 GB</span><br><span class="line">       PANIC: &quot;Kernel panic - not syncing: softlockup: hung tasks&quot;</span><br><span class="line">         PID: 13</span><br><span class="line">     COMMAND: &quot;kworker&#x2F;0:1&quot;</span><br><span class="line">        TASK: ffff91344081b240  [THREAD_INFO: ffff91344081b240]</span><br><span class="line">         CPU: 0</span><br><span class="line">       STATE: TASK_RUNNING (PANIC)</span><br><span class="line"></span><br><span class="line">crash&gt; bt</span><br><span class="line">PID: 13     TASK: ffff91344081b240  CPU: 0   COMMAND: &quot;kworker&#x2F;0:1&quot;</span><br><span class="line">bt: seek error: kernel virtual address: ffff98357ffffff8  type: &quot;stack contents&quot;</span><br><span class="line">bt: read of stack at ffff98357ffffff8 failed</span><br><span class="line">crash&gt; struct task_struct ffff91344081b240</span><br><span class="line">struct task_struct &#123;</span><br><span class="line">  thread_info &#x3D; &#123;</span><br><span class="line">    flags &#x3D; 16392,</span><br><span class="line">    syscall_work &#x3D; 0,</span><br><span class="line">    status &#x3D; 0</span><br><span class="line">  &#125;,</span><br><span class="line">  state &#x3D; 0,</span><br><span class="line">  stack &#x3D; 0xffff983580070000,</span><br><span class="line">  usage &#x3D; &#123;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>task</code> <code>thread_info</code> 地址都是 <code>ffff91344081b240</code>。<br>stack地址是<code>0xffff983580070000</code>。</p>
<p>参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/296750228">linux 进程内核栈</a><br>参考<a target="_blank" rel="noopener" href="http://linux.laoqinren.net/kernel/sched/current/">Linux调度——神奇的current</a><br>参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1492374">Linux syscall过程分析</a><br>参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1603966">do_fork实现–下</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/linux%E5%86%85%E6%A0%B8/">上一页</a></div><div class="pagination-next"><a href="/categories/linux%E5%86%85%E6%A0%B8/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/linux%E5%86%85%E6%A0%B8/">1</a></li><li><a class="pagination-link is-current" href="/categories/linux%E5%86%85%E6%A0%B8/page/2/">2</a></li><li><a class="pagination-link" href="/categories/linux%E5%86%85%E6%A0%B8/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/linux%E5%86%85%E6%A0%B8/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Hui Su"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Hui Su</p><p class="is-size-6 is-block">liulangren bolg</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">101</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">130</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liulangrenaaa" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liulangrenaaa"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.google.com.hk/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Google</span></span><span class="level-right"><span class="level-item tag">www.google.com.hk</span></span></a></li><li><a class="level is-mobile" href="https://lkml.org/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">LKML</span></span><span class="level-right"><span class="level-item tag">lkml.org</span></span></a></li><li><a class="level is-mobile" href="https://mail.google.com/mail" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gmail</span></span><span class="level-right"><span class="level-item tag">mail.google.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhihu.com/explore" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/contest/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 剑指offer</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 周赛</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://tongji.baidu.com/web/32051076/overview/index?siteId=16230094" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">百度分析</span></span><span class="level-right"><span class="level-item tag">tongji.baidu.com</span></span></a></li><li><a class="level is-mobile" href="https://analytics.google.com/analytics/web/#/a187909645p259761261/admin/streams/table/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">google分析</span></span><span class="level-right"><span class="level-item tag">analytics.google.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BRK/"><span class="tag">BRK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KASAN/"><span class="tag">KASAN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OOM/"><span class="tag">OOM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QCOM/"><span class="tag">QCOM</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aarch64/"><span class="tag">aarch64</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpf/"><span class="tag">bpf</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpftrace/"><span class="tag">bpftrace</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup/"><span class="tag">cgroup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v1/"><span class="tag">cgroup v1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v2/"><span class="tag">cgroup v2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/crash/"><span class="tag">crash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dd/"><span class="tag">dd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/deadlock/"><span class="tag">deadlock</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debugfs/"><span class="tag">debugfs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/double-free/"><span class="tag">double free</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/drop-caches/"><span class="tag">drop_caches</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dumpe2fs/"><span class="tag">dumpe2fs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/event-trace/"><span class="tag">event trace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ext2/"><span class="tag">ext2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-attr/"><span class="tag">file attr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-hole/"><span class="tag">file hole</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/filesystem/"><span class="tag">filesystem</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fsck/"><span class="tag">fsck</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ftrace/"><span class="tag">ftrace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gdb/"><span class="tag">gdb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hardlockup/"><span class="tag">hardlockup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hrtimer/"><span class="tag">hrtimer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hugepage/"><span class="tag">hugepage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hungtask/"><span class="tag">hungtask</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/interrupt/"><span class="tag">interrupt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt/"><span class="tag">intrrrupt</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt-storm/"><span class="tag">intrrrupt storm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/irq/"><span class="tag">irq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kdump/"><span class="tag">kdump</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kernel-patch/"><span class="tag">kernel patch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kfence/"><span class="tag">kfence</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kmemleak/"><span class="tag">kmemleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kprobes/"><span class="tag">kprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kretprobes/"><span class="tag">kretprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ksoftirqd/"><span class="tag">ksoftirqd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kthread/"><span class="tag">kthread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvm/"><span class="tag">kvm</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvmtool/"><span class="tag">kvmtool</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/launch-json/"><span class="tag">launch.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-kernel/"><span class="tag">linux kernel</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-native-aio/"><span class="tag">linux native aio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lockdep/"><span class="tag">lockdep</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/makedumpfile/"><span class="tag">makedumpfile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memleak/"><span class="tag">memleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory/"><span class="tag">memory</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory-direct-reclaim/"><span class="tag">memory direct reclaim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mount/"><span class="tag">mount</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/namespace/"><span class="tag">namespace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oom/"><span class="tag">oom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oops/"><span class="tag">oops</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-cache/"><span class="tag">page_cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-owner/"><span class="tag">page_owner</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pagecache/"><span class="tag">pagecache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/panic/"><span class="tag">panic</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/per-cpu/"><span class="tag">per-cpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/perf/"><span class="tag">perf</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pid-namespace/"><span class="tag">pid namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preempt-count/"><span class="tag">preempt_count</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preemption/"><span class="tag">preemption</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pressure/"><span class="tag">pressure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psi/"><span class="tag">psi</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psoix-aio/"><span class="tag">psoix aio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/randomize-va-space/"><span class="tag">randomize_va_space</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rcu/"><span class="tag">rcu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/read-code/"><span class="tag">read code</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sched-latency/"><span class="tag">sched latency</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/schedule/"><span class="tag">schedule</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slab/"><span class="tag">slab</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub/"><span class="tag">slub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub-debug/"><span class="tag">slub_debug</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/softlockup/"><span class="tag">softlockup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stack-overflow/"><span class="tag">stack_overflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-key/"><span class="tag">static_key</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sync/"><span class="tag">sync</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systemTap/"><span class="tag">systemTap</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-json/"><span class="tag">task.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-struct/"><span class="tag">task_struct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tasklet/"><span class="tag">tasklet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thread-info/"><span class="tag">thread_info</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tracepoint/"><span class="tag">tracepoint</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ubuntu/"><span class="tag">ubuntu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/use-after-free/"><span class="tag">use after free</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uts-namespace/"><span class="tag">uts namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/valgrind/"><span class="tag">valgrind</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vdso/"><span class="tag">vdso</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmstat/"><span class="tag">vmstat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmtouch/"><span class="tag">vmtouch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vscode/"><span class="tag">vscode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/x86/"><span class="tag">x86</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xattr/"><span class="tag">xattr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zone/"><span class="tag">zone</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%B6%8A%E7%95%8C/"><span class="tag">内存泄漏越界</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"><span class="tag">内存泄露</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内核内存泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C/"><span class="tag">内核内存越界</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"><span class="tag">内核同步</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0/"><span class="tag">内核抢占</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%A0%88%E6%BA%A2%E5%87%BA/"><span class="tag">内核栈溢出</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E7%AE%A1%E7%AE%A1%E7%90%86/"><span class="tag">内管管理</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"><span class="tag">函数调用</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E9%9A%8F%E6%9C%BA%E5%8C%96/"><span class="tag">地址空间布局随机化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/"><span class="tag">性能稳定性</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B3%84%E6%BC%8F/"><span class="tag">文件描述符泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><span class="tag">文件系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E9%A1%B9/"><span class="tag">杂项</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%88/"><span class="tag">栈</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/"><span class="tag">死锁检测</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="tag">生活感悟</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%A8%E6%88%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">用户内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A9%BA%E6%8C%87%E9%92%88/"><span class="tag">空指针</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F/"><span class="tag">虚拟地址空间泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F/"><span class="tag">资源泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%B8%AD%E6%96%AD/"><span class="tag">软中断</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"><span class="tag">进程调度</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/"><span class="tag">通用寄存器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81%E7%B2%92%E5%BA%A6/"><span class="tag">锁粒度</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E7%B3%BB%E7%BB%9F/"><span class="tag">问题系统</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/QCOM/"><span class="level-start"><span class="level-item">QCOM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/cgroup-v1/"><span class="level-start"><span class="level-item">cgroup v1</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/cgroup-v1/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/kernel-debug/"><span class="level-start"><span class="level-item">kernel debug</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-kernel/"><span class="level-start"><span class="level-item">linux kernel</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/"><span class="level-start"><span class="level-item">linux schedule</span></span><span class="level-end"><span class="level-item tag">12</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/deadline-schedule/"><span class="level-start"><span class="level-item">deadline schedule</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/"><span class="level-start"><span class="level-item">frequency governer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/schedule-util/"><span class="level-start"><span class="level-item">schedule util</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/idle/"><span class="level-start"><span class="level-item">idle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/linux%E5%86%85%E6%A0%B8/"><span class="level-start"><span class="level-item">linux内核</span></span><span class="level-end"><span class="level-item tag">58</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/"><span class="level-start"><span class="level-item">namespace</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/namespace/pid-namespace/"><span class="level-start"><span class="level-item">pid namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/uts-namespace/"><span class="level-start"><span class="level-item">uts namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/qemu/"><span class="level-start"><span class="level-item">qemu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/server/"><span class="level-start"><span class="level-item">server</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/shell%E8%84%9A%E6%9C%AC/"><span class="level-start"><span class="level-item">shell脚本</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="level-start"><span class="level-item">生活感悟</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-23T11:00:00.000Z">2021-09-23</time></p><p class="title"><a href="/2021/09/23/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E9%9A%8F%E6%9C%BA%E5%8C%96/">地址空间布局随机化</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-14T11:00:00.000Z">2021-09-14</time></p><p class="title"><a href="/2021/09/14/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/static_key%E6%9C%BA%E5%88%B6/">static_key机制</a></p><p class="categories"><a href="/categories/kernel-debug/">kernel debug</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-14T11:00:00.000Z">2021-09-14</time></p><p class="title"><a href="/2021/09/14/%E7%BC%96%E8%AF%91%E5%99%A8/gnu%20built_in/">gnu built_in</a></p><p class="categories"><a href="/categories/kernel-debug/">kernel debug</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-14T11:00:00.000Z">2021-09-14</time></p><p class="title"><a href="/2021/09/14/interrupt/aarch64%20%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/">aarch64 中断处理</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-14T11:00:00.000Z">2021-09-14</time></p><p class="title"><a href="/2021/09/14/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/tracepoint%20%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/">tracepoint 原理与使用</a></p><p class="categories"><a href="/categories/kernel-debug/">kernel debug</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Su Hui</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>