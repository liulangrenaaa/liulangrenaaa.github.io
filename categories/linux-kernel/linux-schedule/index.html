<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: linux schedule - liulangren Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="liulangren blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="liulangren blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="liulangren Blog"><meta property="og:url" content="https://liulangrenaaa.github.io/"><meta property="og:site_name" content="liulangren Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liulangrenaaa.github.io/img/og_image.png"><meta property="article:author" content="Su Hui"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liulangrenaaa.github.io"},"headline":"liulangren Blog","image":["https://liulangrenaaa.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Su Hui"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cabdc5b9b70bb83fa919a6ebeb439f93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=PTKX6HMR55" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'PTKX6HMR55');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li><a href="/categories/linux-kernel/">linux kernel</a></li><li class="is-active"><a href="#" aria-current="page">linux schedule</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-01-05T11:00:00.000Z" title="1/5/2022, 7:00:00 PM">2022-01-05</time>发表</span><span class="level-item"><time dateTime="2022-01-05T03:06:10.391Z" title="1/5/2022, 11:06:10 AM">2022-01-05</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">几秒读完 (大约65个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/05/schedule/eas/">eas</a></h1><div class="content"><h2 id="energy-model"><a href="#energy-model" class="headerlink" title="energy_model"></a>energy_model</h2><p>mi11 kernel 中 <code>/sys/kernel/debug/energy_model</code> 目录就是 energy_model，是根据opp table 和 dts中信息来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">venus:&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;energy_model # ls</span><br><span class="line">pd0  pd4  pd7</span><br><span class="line">venus:&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;energy_model #</span><br></pre></td></tr></table></figure>
<p>是Qcom 888芯片，分为3 cluster，1+3+4架构</p>
<p>小核：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<p>小核：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<p>小核：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-15T11:00:00.000Z" title="6/15/2021, 7:00:00 PM">2021-06-15</time>发表</span><span class="level-item"><time dateTime="2021-06-15T08:20:49.884Z" title="6/15/2021, 4:20:49 PM">2021-06-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/idle/">idle</a></span><span class="level-item">3 分钟读完 (大约375个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/15/schedule/idle%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%B1%E6%9D%A5/">idle 进程的由来</a></h1><div class="content"><h2 id="idle-线程"><a href="#idle-线程" class="headerlink" title="idle 线程"></a>idle 线程</h2><p>linux 中给 per cpu都安排了一个结构<code>runqueue</code>，只要此 runqueue中有 runnable的thread,<br>scheduler 就不会进入 idle状态；相反，只要没有runnable的task，scheduler就会执行 <code>idle task</code>，使得cpu进入 idle模式。</p>
<h2 id="idle-线程如何产生的？"><a href="#idle-线程如何产生的？" class="headerlink" title="idle 线程如何产生的？"></a>idle 线程如何产生的？</h2><h3 id="单cpu-core架构中"><a href="#单cpu-core架构中" class="headerlink" title="单cpu core架构中"></a>单cpu core架构中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void cpu_startup_entry(enum cpuhp_state state)</span><br><span class="line">&#123;</span><br><span class="line">	arch_cpu_idle_prepare();</span><br><span class="line">	cpuhp_online_idle(state);</span><br><span class="line">	while (1)</span><br><span class="line">		do_idle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline void __ref rest_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">	cpu_startup_entry(CPUHP_ONLINE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __init __weak arch_call_rest_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	rest_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asmlinkage __visible void __init __no_sanitize_address start_kernel(void)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">      	arch_call_rest_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="smp架构中"><a href="#smp架构中" class="headerlink" title="smp架构中"></a>smp架构中</h3><p>smp 架构在boot的时候也是单cpu 先boot,然后结果smp_init()，将系统中其他cpu boot起来。<br>所以在 boot cpu中，idle线程还是通过 <code>rest_init()</code> 产生的。</p>
<p>非 <code>boot cpu</code> 的情况下，idle 线程是通过<code>idle_threads_init()</code> 产生的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static inline void idle_init(unsigned int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *tsk &#x3D; per_cpu(idle_threads, cpu);</span><br><span class="line"></span><br><span class="line">	if (!tsk) &#123;</span><br><span class="line">		tsk &#x3D; fork_idle(cpu);</span><br><span class="line">		if (IS_ERR(tsk))</span><br><span class="line">			pr_err(&quot;SMP: fork_idle() failed for CPU %u\n&quot;, cpu);</span><br><span class="line">		else</span><br><span class="line">			per_cpu(idle_threads, cpu) &#x3D; tsk;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * idle_threads_init - Initialize idle threads for all cpus</span><br><span class="line"> *&#x2F;</span><br><span class="line">void __init idle_threads_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int cpu, boot_cpu;</span><br><span class="line"></span><br><span class="line">	boot_cpu &#x3D; smp_processor_id();</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		if (cpu !&#x3D; boot_cpu)</span><br><span class="line">			idle_init(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Called by boot processor to activate the rest. *&#x2F;</span><br><span class="line">void __init smp_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">	idle_threads_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static noinline void __init kernel_init_freeable(void)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">	smp_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int __ref kernel_init(void *unused)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	kernel_init_freeable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline void __ref rest_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">	pid &#x3D; kernel_thread(kernel_init, NULL, CLONE_FS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rest_init<br>  – kernel_init<br>    – kernel_init_freeable<br>      – smp_init<br>        – idle_threads_init<br>          – idle_init</p>
<h2 id="idle-线程干了啥？"><a href="#idle-线程干了啥？" class="headerlink" title="idle 线程干了啥？"></a>idle 线程干了啥？</h2><p>后续熟悉 arm cpu指令再补充..</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-01T11:00:00.000Z" title="6/1/2021, 7:00:00 PM">2021-06-01</time>发表</span><span class="level-item"><time dateTime="2022-01-11T06:43:57.999Z" title="1/11/2022, 2:43:57 PM">2022-01-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">8 分钟读完 (大约1266个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/01/schedule/benchmark/">benchmark</a></h1><div class="content"><p>参考<a target="_blank" rel="noopener" href="https://lwn.net/Articles/725238/">LWN文章</a></p>
<h2 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h2><h2 id="hackbench"><a href="#hackbench" class="headerlink" title="hackbench"></a>hackbench</h2><p><code>hackbench</code> 包含在 <code>rt-tests</code> 中，主要是 rt性能 的测试。<br>可以下载<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/utils/rt-tests/rt-tests.git">源码</a>编译安装<br>或者<code>rt-tests</code>安装包安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;test $ sudo apt-cache search hackbench</span><br><span class="line">rt-tests - Test programs for rt kernels</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;test $</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;test $ hackbench</span><br><span class="line">Running in process mode with 10 groups using 40 file descriptors each (&#x3D;&#x3D; 400 tasks)</span><br><span class="line">Each sender will pass 100 messages of 100 bytes</span><br><span class="line">Time: 0.093</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;test $</span><br></pre></td></tr></table></figure>







<h2 id="schbench"><a href="#schbench" class="headerlink" title="schbench"></a>schbench</h2><p><code>schbench</code> 需要自己手动编译安装，地址在 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/mason/schbench.git/tree/">这里</a><br>下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;mason&#x2F;schbench.git</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ ls</span><br><span class="line">Makefile  schbench.c  schedstat.py</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ make</span><br><span class="line">gcc -o schbench.o -c -Wall -O2 -g -W -D_GNU_SOURCE -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS&#x3D;64 schbench.c</span><br><span class="line">gcc -Wall -O2 -g -W -D_GNU_SOURCE -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS&#x3D;64 -o schbench schbench.o -lpthread</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ ls</span><br><span class="line">Makefile  schbench  schbench.c  schbench.o  schedstat.py</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $</span><br></pre></td></tr></table></figure>

<p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ ls</span><br><span class="line">Makefile  schbench  schbench.c  schbench.o  schedstat.py</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ sudo mv schbench &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ ls</span><br><span class="line">Makefile  schbench.c  schbench.o  schedstat.py</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $ schbench</span><br><span class="line"></span><br><span class="line">warmup done, zeroing stats</span><br><span class="line">Latency percentiles (usec) runtime 10 (s) (1649 total samples)</span><br><span class="line">	50.0th: 80 (833 samples)</span><br><span class="line">	75.0th: 8040 (404 samples)</span><br><span class="line">	90.0th: 14352 (248 samples)</span><br><span class="line">	95.0th: 16016 (95 samples)</span><br><span class="line">	*99.0th: 24992 (54 samples)</span><br><span class="line">	99.5th: 28960 (7 samples)</span><br><span class="line">	99.9th: 31968 (8 samples)</span><br><span class="line">	min&#x3D;4, max&#x3D;31999</span><br><span class="line">Latency percentiles (usec) runtime 20 (s) (4929 total samples)</span><br><span class="line">	50.0th: 77 (2473 samples)</span><br><span class="line">	75.0th: 8056 (1234 samples)</span><br><span class="line">	90.0th: 14160 (735 samples)</span><br><span class="line">	95.0th: 15824 (247 samples)</span><br><span class="line">	*99.0th: 24736 (193 samples)</span><br><span class="line">	99.5th: 28000 (24 samples)</span><br><span class="line">	99.9th: 32032 (22 samples)</span><br><span class="line">	min&#x3D;3, max&#x3D;39652</span><br><span class="line">Latency percentiles (usec) runtime 30 (s) (8274 total samples)</span><br><span class="line">	50.0th: 75 (4163 samples)</span><br><span class="line">	75.0th: 8008 (2059 samples)</span><br><span class="line">	90.0th: 14096 (1226 samples)</span><br><span class="line">	95.0th: 15760 (415 samples)</span><br><span class="line">	*99.0th: 24096 (329 samples)</span><br><span class="line">	99.5th: 26976 (41 samples)</span><br><span class="line">	99.9th: 31968 (34 samples)</span><br><span class="line">	min&#x3D;3, max&#x3D;39652</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench $</span><br></pre></td></tr></table></figure>






<h2 id="adrestia"><a href="#adrestia" class="headerlink" title="adrestia"></a>adrestia</h2><p><code>adrestia</code> 需要自己手动编译安装，地址在 <a target="_blank" rel="noopener" href="https://github.com/mfleming/adrestia.git">这里</a></p>
<p>下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;mfleming&#x2F;adrestia.git</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench&#x2F;adrestia $ make</span><br><span class="line">cc -Wall -lpthread -I &#x2F;tmp&#x2F;schbench&#x2F;adrestia&#x2F;include -g   -c -o wake.o wake.c</span><br><span class="line">cc -Wall -lpthread -I &#x2F;tmp&#x2F;schbench&#x2F;adrestia&#x2F;include -g   -c -o stats.o stats.c</span><br><span class="line">cc -Wall -lpthread -I &#x2F;tmp&#x2F;schbench&#x2F;adrestia&#x2F;include -g adrestia.c wake.o stats.o -o adrestia -lpthread</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench&#x2F;adrestia $ .&#x2F;adrestia</span><br><span class="line">wakeup cost (single): 11us</span><br><span class="line">wakeup cost (periodic, 10us): 12us</span><br><span class="line">ubuntu@zeku_server:&#x2F;tmp&#x2F;schbench&#x2F;adrestia $</span><br></pre></td></tr></table></figure>










<h2 id="rt-app"><a href="#rt-app" class="headerlink" title="rt-app"></a>rt-app</h2><p><code>rt-app</code> 需要自己手动编译安装，地址在 <a target="_blank" rel="noopener" href="https://github.com/scheduler-tools/rt-app">这里</a></p>
<p>下载 编译 安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;scheduler-tools&#x2F;rt-app</span><br></pre></td></tr></table></figure>

<p>也可以直接安装包安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:~&#x2F;workspace&#x2F;rt-tests $ sudo apt-cache search rt-app</span><br><span class="line">pixelmed-webstart-apps - DICOM implementation containing Image Viewer and a ECG Viewer - jnlp</span><br><span class="line">rt-app - Test application which simulates a real-time periodic load</span><br></pre></td></tr></table></figure>

<p>guide 在 <code>rt-app/doc/tutorial.txt</code> 目录下，有几个比较重要的 配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;cpus&quot; : [2,3], &#x2F;*  set cpu affinity*&#x2F;</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>

<p>运行直接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rt-app tmp.json</span><br></pre></td></tr></table></figure>

<p>利用rt-app 可以做很多场景的模拟，doc/example目录中有模拟 mp3 codec的json文件，<br>后续再研究。</p>
<h2 id="cyclictest"><a href="#cyclictest" class="headerlink" title="cyclictest"></a>cyclictest</h2><p>也是 <code>rt-tests</code> 中一个组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:~&#x2F;workspace&#x2F;rt-tests $ .&#x2F;cyclictest --help</span><br><span class="line">cyclictest V 2.30</span><br><span class="line">Usage:</span><br><span class="line">cyclictest &lt;options&gt;</span><br><span class="line"></span><br><span class="line">-a [CPUSET] --affinity     Run thread #N on processor #N, if possible, or if CPUSET</span><br><span class="line">                           given, pin threads to that set of processors in round-</span><br><span class="line">                           robin order.  E.g. -a 2 pins all threads to CPU 2,</span><br><span class="line">                           but -a 3-5,0 -t 5 will run the first and fifth</span><br><span class="line">                           threads on CPU (0),thread #2 on CPU 3, thread #3</span><br><span class="line">                           on CPU 4, and thread #5 on CPU 5.</span><br><span class="line">-A USEC  --aligned&#x3D;USEC    align thread wakeups to a specific offset</span><br><span class="line">-b USEC  --breaktrace&#x3D;USEC send break trace command when latency &gt; USEC</span><br><span class="line">-c CLOCK --clock&#x3D;CLOCK     select clock</span><br><span class="line">                           0 &#x3D; CLOCK_MONOTONIC (default)</span><br><span class="line">                           1 &#x3D; CLOCK_REALTIME</span><br><span class="line">         --default-system  Don&#39;t attempt to tune the system from cyclictest.</span><br><span class="line">                           Power management is not suppressed.</span><br><span class="line">                           This might give poorer results, but will allow you</span><br><span class="line">                           to discover if you need to tune the system</span><br><span class="line">-d DIST  --distance&#x3D;DIST   distance of thread intervals in us, default&#x3D;500</span><br><span class="line">-D       --duration&#x3D;TIME   specify a length for the test run.</span><br><span class="line">                           Append &#39;m&#39;, &#39;h&#39;, or &#39;d&#39; to specify minutes, hours or days.</span><br><span class="line">-F       --fifo&#x3D;&lt;path&gt;     create a named pipe at path and write stats to it</span><br><span class="line">-h       --histogram&#x3D;US    dump a latency histogram to stdout after the run</span><br><span class="line">                           US is the max latency time to be tracked in microseconds</span><br><span class="line">                           This option runs all threads at the same priority.</span><br><span class="line">-H       --histofall&#x3D;US    same as -h except with an additional summary column</span><br><span class="line">         --histfile&#x3D;&lt;path&gt; dump the latency histogram to &lt;path&gt; instead of stdout</span><br><span class="line">-i INTV  --interval&#x3D;INTV   base interval of thread in us default&#x3D;1000</span><br><span class="line">         --json&#x3D;FILENAME   write final results into FILENAME, JSON formatted</span><br><span class="line">         --laptop          Save battery when running cyclictest</span><br><span class="line">                           This will give you poorer realtime results</span><br><span class="line">                           but will not drain your battery so quickly</span><br><span class="line">         --latency&#x3D;PM_QOS  power management latency target value</span><br><span class="line">                           This value is written to &#x2F;dev&#x2F;cpu_dma_latency</span><br><span class="line">                           and affects c-states. The default is 0</span><br><span class="line">-l LOOPS --loops&#x3D;LOOPS     number of loops: default&#x3D;0(endless)</span><br><span class="line">         --mainaffinity&#x3D;CPUSET</span><br><span class="line">                           Run the main thread on CPU #N. This only affects</span><br><span class="line">                           the main thread and not the measurement threads</span><br><span class="line">-m       --mlockall        lock current and future memory allocations</span><br><span class="line">-M       --refresh_on_max  delay updating the screen until a new max</span><br><span class="line">                           latency is hit. Useful for low bandwidth.</span><br><span class="line">-N       --nsecs           print results in ns instead of us (default us)</span><br><span class="line">-o RED   --oscope&#x3D;RED      oscilloscope mode, reduce verbose output by RED</span><br><span class="line">-p PRIO  --priority&#x3D;PRIO   priority of highest prio thread</span><br><span class="line">         --policy&#x3D;NAME     policy of measurement thread, where NAME may be one</span><br><span class="line">                           of: other, normal, batch, idle, fifo or rr.</span><br><span class="line">         --priospread      spread priority levels starting at specified value</span><br><span class="line">-q       --quiet           print a summary only on exit</span><br><span class="line">-r       --relative        use relative timer instead of absolute</span><br><span class="line">-R       --resolution      check clock resolution, calling clock_gettime() many</span><br><span class="line">                           times.  List of clock_gettime() values will be</span><br><span class="line">                           reported with -X</span><br><span class="line">         --secaligned [USEC] align thread wakeups to the next full second</span><br><span class="line">                           and apply the optional offset</span><br><span class="line">-s       --system          use sys_nanosleep and sys_setitimer</span><br><span class="line">-S       --smp             Standard SMP testing: options -a -t and same priority</span><br><span class="line">                           of all threads</span><br><span class="line">        --spike&#x3D;&lt;trigger&gt;  record all spikes &gt; trigger</span><br><span class="line">        --spike-nodes&#x3D;[num of nodes]</span><br><span class="line">                           These are the maximum number of spikes we can record.</span><br><span class="line">                           The default is 1024 if not specified</span><br><span class="line">         --smi             Enable SMI counting</span><br><span class="line">-t       --threads         one thread per available processor</span><br><span class="line">-t [NUM] --threads&#x3D;NUM     number of threads:</span><br><span class="line">                           without NUM, threads &#x3D; max_cpus</span><br><span class="line">                           without -t default &#x3D; 1</span><br><span class="line">         --tracemark       write a trace mark when -b latency is exceeded</span><br><span class="line">-u       --unbuffered      force unbuffered output for live processing</span><br><span class="line">-v       --verbose         output values on stdout for statistics</span><br><span class="line">                           format: n:c:v n&#x3D;tasknum c&#x3D;count v&#x3D;value in us</span><br><span class="line">         --dbg_cyclictest  print info useful for debugging cyclictest</span><br><span class="line">-x       --posix_timers    use POSIX timers instead of clock_nanosleep.</span><br></pre></td></tr></table></figure>

<p>参考<a target="_blank" rel="noopener" href="https://elinux.org/Realtime_Testing_Best_Practices">Realtime Testing Best Practices</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-25T11:00:00.000Z" title="5/25/2021, 7:00:00 PM">2021-05-25</time>发表</span><span class="level-item"><time dateTime="2021-05-26T01:59:02.564Z" title="5/26/2021, 9:59:02 AM">2021-05-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">7 分钟读完 (大约1047个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/25/schedule/sched_features/">sched_features</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p><code>sched features</code> 是 linux scheduler 的一些 feature实现开关，可以在系统运行中动态开关，相关 feature 在 <code>kernel/sched/features.h</code> 有定义。</p>
<h2 id="feature-拆解"><a href="#feature-拆解" class="headerlink" title="feature 拆解"></a>feature 拆解</h2><p>每个 feature 对调度行为都有一定影响或者优化，但是需要根据实际情况来选择是否开启 这个 feature.</p>
<h3 id="GENTLE-FAIR-SLEEPERS"><a href="#GENTLE-FAIR-SLEEPERS" class="headerlink" title="GENTLE_FAIR_SLEEPERS"></a>GENTLE_FAIR_SLEEPERS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Only give sleepers 50% of their service deficit. This allows</span><br><span class="line"> * them to run sooner, but does not allow tons of sleepers to</span><br><span class="line"> * rip the spread apart.</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(GENTLE_FAIR_SLEEPERS, true)</span><br></pre></td></tr></table></figure>
<p><code>GENTLE_FAIR_SLEEPERS</code> 主要是 减少对 sleep task的 vruntime 补偿。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">		 * Halve their sleep time&#39;s effect, to allow</span><br><span class="line">		 * for a gentler effect of sleepers:</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		if (sched_feat(GENTLE_FAIR_SLEEPERS))</span><br><span class="line">			thresh &gt;&gt;&#x3D; 1;</span><br><span class="line"></span><br><span class="line">		vruntime -&#x3D; thresh;</span><br></pre></td></tr></table></figure>
<p>实际 使用时，仅仅是将 补偿时间减少一半。</p>
<h3 id="START-DEBIT"><a href="#START-DEBIT" class="headerlink" title="START_DEBIT"></a>START_DEBIT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Place new tasks ahead so that they do not starve already running</span><br><span class="line"> * tasks</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(START_DEBIT, true)</span><br></pre></td></tr></table></figure>
<p><code>START_DEBIT</code> 主要是 对 initial task 的一种惩罚，对 vruntime 增加，可以让运行时间减少 和 不会立刻运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial)</span><br><span class="line">&#123;</span><br><span class="line">	u64 vruntime &#x3D; cfs_rq-&gt;min_vruntime;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The &#39;current&#39; period is already promised to the current tasks,</span><br><span class="line">	 * however the extra weight of the new task will slow them down a</span><br><span class="line">	 * little, place the new task so that it fits in the slot that</span><br><span class="line">	 * stays open at the end.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (initial &amp;&amp; sched_feat(START_DEBIT))</span><br><span class="line">		vruntime +&#x3D; sched_vslice(cfs_rq, se);</span><br></pre></td></tr></table></figure>

<h3 id="NEXT-BUDDY"><a href="#NEXT-BUDDY" class="headerlink" title="NEXT_BUDDY"></a>NEXT_BUDDY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Prefer to schedule the task we woke last (assuming it failed</span><br><span class="line"> * wakeup-preemption), since its likely going to consume data we</span><br><span class="line"> * touched, increases cache locality.</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(NEXT_BUDDY, false)</span><br></pre></td></tr></table></figure>
<p><code>NEXT_BUDDY</code> 主要是 希望可以 尽快调度到 抢占 <code>curr</code>的 task.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	if (sched_feat(NEXT_BUDDY) &amp;&amp; scale &amp;&amp; !(wake_flags &amp; WF_FORK)) &#123;</span><br><span class="line">		set_next_buddy(pse);</span><br><span class="line">		next_buddy_marked &#x3D; 1;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LAST-BUDDY"><a href="#LAST-BUDDY" class="headerlink" title="LAST_BUDDY"></a>LAST_BUDDY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Prefer to schedule the task that ran last (when we did</span><br><span class="line"> * wake-preempt) as that likely will touch the same data, increases</span><br><span class="line"> * cache locality.</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(LAST_BUDDY, true)</span><br></pre></td></tr></table></figure>
<p><code>LAST_BUDDY</code> 主要是 希望可以尽快调度到上次被 <code>wakeup task</code> <code>preempt</code> 的task。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	if (sched_feat(LAST_BUDDY) &amp;&amp; scale &amp;&amp; entity_is_task(se))</span><br><span class="line">		set_last_buddy(se);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CACHE-HOT-BUDDY"><a href="#CACHE-HOT-BUDDY" class="headerlink" title="CACHE_HOT_BUDDY"></a>CACHE_HOT_BUDDY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Consider buddies to be cache hot, decreases the likeliness of a</span><br><span class="line"> * cache buddy being migrated away, increases cache locality.</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(CACHE_HOT_BUDDY, true)</span><br></pre></td></tr></table></figure>
<p>认为 [last|next]buddies 是 cache hot的，所以不能让他们 migrate away，增加 cache 命中率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Is this task likely cache-hot:</span><br><span class="line"> *&#x2F;</span><br><span class="line">static int task_hot(struct task_struct *p, struct lb_env *env)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Buddy candidates are cache hot:</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (sched_feat(CACHE_HOT_BUDDY) &amp;&amp; env-&gt;dst_rq-&gt;nr_running &amp;&amp;</span><br><span class="line">			(&amp;p-&gt;se &#x3D;&#x3D; cfs_rq_of(&amp;p-&gt;se)-&gt;next ||</span><br><span class="line">			 &amp;p-&gt;se &#x3D;&#x3D; cfs_rq_of(&amp;p-&gt;se)-&gt;last))</span><br><span class="line">		return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WAKEUP-PREEMPTION"><a href="#WAKEUP-PREEMPTION" class="headerlink" title="WAKEUP_PREEMPTION"></a>WAKEUP_PREEMPTION</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Allow wakeup-time preemption of the current task:</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(WAKEUP_PREEMPTION, true)</span><br></pre></td></tr></table></figure>
<p>是否可以唤醒强占， 后续补充</p>
<h3 id="HRTICK-HRTICK-DL-DOUBLE-TICK"><a href="#HRTICK-HRTICK-DL-DOUBLE-TICK" class="headerlink" title="HRTICK HRTICK_DL DOUBLE_TICK"></a>HRTICK HRTICK_DL DOUBLE_TICK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SCHED_FEAT(HRTICK, false)</span><br><span class="line">SCHED_FEAT(HRTICK_DL, false)</span><br><span class="line">SCHED_FEAT(DOUBLE_TICK, false)</span><br></pre></td></tr></table></figure>
<p><code>HRTICK HRTICK_DL DOUBLE_TICK</code> 这三个 feature 主要是利用 <code>rq-&gt;hrtick_timer</code> 优化调度行为的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void __sched notrace __schedule(bool preempt)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	if (sched_feat(HRTICK) || sched_feat(HRTICK_DL))</span><br><span class="line">		hrtick_clear(rq);</span><br></pre></td></tr></table></figure>

<p>主要是 <code>dl task</code> 会使用 这个 hrtimer 在<code>dl-&gt;runtime</code>到期的时候 发生一个 tick，使得任务运行时间更加精准</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void start_hrtick_dl(struct rq *rq, struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	hrtick_start(rq, p-&gt;dl.runtime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void set_next_task_dl(struct rq *rq, struct task_struct *p, bool first)</span><br><span class="line">&#123;</span><br><span class="line">	p-&gt;se.exec_start &#x3D; rq_clock_task(rq);</span><br><span class="line"></span><br><span class="line">	if (hrtick_enabled_dl(rq))</span><br><span class="line">		start_hrtick_dl(rq, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>cfs task</code> 会使用 这个 hrtimer 在<code>delta</code> 期望运行时间 到期的时候 发生一个 tick_fair，使得运行时间更加精准。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void hrtick_start_fair(struct rq *rq, struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_entity *se &#x3D; &amp;p-&gt;se;</span><br><span class="line">	struct cfs_rq *cfs_rq &#x3D; cfs_rq_of(se);</span><br><span class="line"></span><br><span class="line">	SCHED_WARN_ON(task_rq(p) !&#x3D; rq);</span><br><span class="line"></span><br><span class="line">	if (rq-&gt;cfs.h_nr_running &gt; 1) &#123;</span><br><span class="line">		u64 slice &#x3D; sched_slice(cfs_rq, se);</span><br><span class="line">		u64 ran &#x3D; se-&gt;sum_exec_runtime - se-&gt;prev_sum_exec_runtime;</span><br><span class="line">		s64 delta &#x3D; slice - ran;</span><br><span class="line"></span><br><span class="line">		if (delta &lt; 0) &#123;</span><br><span class="line">			if (task_current(rq, p))</span><br><span class="line">				resched_curr(rq);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		hrtick_start(rq, delta);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct task_struct *</span><br><span class="line">pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	if (hrtick_enabled_fair(rq))</span><br><span class="line">		hrtick_start_fair(rq, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="NONTASK-CAPACITY"><a href="#NONTASK-CAPACITY" class="headerlink" title="NONTASK_CAPACITY"></a>NONTASK_CAPACITY</h3><h3 id="TTWU-QUEUE"><a href="#TTWU-QUEUE" class="headerlink" title="TTWU_QUEUE"></a>TTWU_QUEUE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Queue remote wakeups on the target CPU and process them</span><br><span class="line"> * using the scheduler IPI. Reduces rq-&gt;lock contention&#x2F;bounces.</span><br><span class="line"> *&#x2F;</span><br><span class="line">SCHED_FEAT(TTWU_QUEUE, true)</span><br></pre></td></tr></table></figure>
<p><code>TTWU_QUEUE</code> 主要是 使用 <code>IPI</code> 去唤醒 <code>remote queue</code> 上的task，而不是操作<code>rq-&gt;lock</code>，然后操作队列上的 entity，这会减少 <code>rq-&gt;lock</code>的争用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static bool ttwu_queue_wakelist(struct task_struct *p, int cpu, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	if (sched_feat(TTWU_QUEUE) &amp;&amp; ttwu_queue_cond(cpu, wake_flags)) &#123;</span><br><span class="line">		if (WARN_ON_ONCE(cpu &#x3D;&#x3D; smp_processor_id()))</span><br><span class="line">			return false;</span><br><span class="line"></span><br><span class="line">		sched_clock_cpu(cpu); &#x2F;* Sync clocks across CPUs *&#x2F;</span><br><span class="line">		__ttwu_queue_wakelist(p, cpu, wake_flags);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="SIS-PROP"><a href="#SIS-PROP" class="headerlink" title="SIS_PROP"></a>SIS_PROP</h3><h3 id="WARN-DOUBLE-CLOCK"><a href="#WARN-DOUBLE-CLOCK" class="headerlink" title="WARN_DOUBLE_CLOCK"></a>WARN_DOUBLE_CLOCK</h3><h3 id="RT-PUSH-IPI"><a href="#RT-PUSH-IPI" class="headerlink" title="RT_PUSH_IPI"></a>RT_PUSH_IPI</h3><h3 id="RT-RUNTIME-SHARE"><a href="#RT-RUNTIME-SHARE" class="headerlink" title="RT_RUNTIME_SHARE"></a>RT_RUNTIME_SHARE</h3><h3 id="LB-MIN"><a href="#LB-MIN" class="headerlink" title="LB_MIN"></a>LB_MIN</h3><h3 id="ATTACH-AGE-LOAD"><a href="#ATTACH-AGE-LOAD" class="headerlink" title="ATTACH_AGE_LOAD"></a>ATTACH_AGE_LOAD</h3><h3 id="WA-IDLE"><a href="#WA-IDLE" class="headerlink" title="WA_IDLE"></a>WA_IDLE</h3><h3 id="WA-WEIGHT"><a href="#WA-WEIGHT" class="headerlink" title="WA_WEIGHT"></a>WA_WEIGHT</h3><h3 id="WA-BIAS"><a href="#WA-BIAS" class="headerlink" title="WA_BIAS"></a>WA_BIAS</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-19T11:00:00.000Z" title="5/19/2021, 7:00:00 PM">2021-05-19</time>发表</span><span class="level-item"><time dateTime="2021-09-16T07:53:18.392Z" title="9/16/2021, 3:53:18 PM">2021-09-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">5 分钟读完 (大约718个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/19/schedule/stop_task/">stop_task</a></h1><div class="content"><h2 id="stop-task"><a href="#stop-task" class="headerlink" title="stop_task"></a>stop_task</h2><p><code>stop_task</code> 实现在 <code>kernel/sched/stop_task.c</code> 中，在所有调度类中<br><code>stop_sched_class</code>的优先级是最高的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define SCHED_DATA				\</span><br><span class="line">	STRUCT_ALIGN();				\</span><br><span class="line">	__begin_sched_classes &#x3D; .;		\</span><br><span class="line">	*(__idle_sched_class)			\</span><br><span class="line">	*(__fair_sched_class)			\</span><br><span class="line">	*(__rt_sched_class)			\</span><br><span class="line">	*(__dl_sched_class)			\</span><br><span class="line">	*(__stop_sched_class)			\</span><br><span class="line">	__end_sched_classes &#x3D; .;</span><br></pre></td></tr></table></figure>


<p>其实在 linux中一个 per cpu的 rq中，每个rq只会有一个 stop task</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct rq &#123;</span><br><span class="line">	&#x2F;* runqueue lock: *&#x2F;</span><br><span class="line">	raw_spinlock_t		lock;</span><br><span class="line"></span><br><span class="line">	struct task_struct __rcu	*curr;</span><br><span class="line">	struct task_struct	*idle;</span><br><span class="line">	struct task_struct	*stop;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且 <code>stop task</code> never migrates，不会迁移，只会固定在某个 cpu上跑，所以 select_task_rq_stop 实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">select_task_rq_stop(struct task_struct *p, int cpu, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	return task_cpu(p); &#x2F;* stop tasks as never migrate *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且 <code>stop task</code> can not be preempted，不会被抢占，check_preempt_curr_stop 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">check_preempt_curr_stop(struct rq *rq, struct task_struct *p, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;* we&#39;re never preempted *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>stop_task</code>， rq上只有一个stop_sched_class的 task，所以 pick_next_task_stop 实现很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct task_struct *pick_next_task_stop(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	if (!sched_stop_runnable(rq))</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	set_next_task_stop(rq, rq-&gt;stop, true);</span><br><span class="line">	return rq-&gt;stop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="外部模块使用"><a href="#外部模块使用" class="headerlink" title="外部模块使用"></a>外部模块使用</h2><p>在 soft lockup 检测模块中，就利用了stop_class 这个调度类。<br><code>watchdog.c</code> 中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* watchdog kicker functions *&#x2F;</span><br><span class="line">static enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long touch_ts, period_ts, now;</span><br><span class="line">	struct pt_regs *regs &#x3D; get_irq_regs();</span><br><span class="line">	int duration;</span><br><span class="line">	int softlockup_all_cpu_backtrace &#x3D; sysctl_softlockup_all_cpu_backtrace;</span><br><span class="line"></span><br><span class="line">	if (!watchdog_enabled)</span><br><span class="line">		return HRTIMER_NORESTART;</span><br><span class="line"></span><br><span class="line">	&#x2F;* kick the hardlockup detector *&#x2F;</span><br><span class="line">	watchdog_interrupt_count();</span><br><span class="line"></span><br><span class="line">	&#x2F;* kick the softlockup detector *&#x2F;</span><br><span class="line">	if (completion_done(this_cpu_ptr(&amp;softlockup_completion))) &#123;</span><br><span class="line">		reinit_completion(this_cpu_ptr(&amp;softlockup_completion));</span><br><span class="line">		stop_one_cpu_nowait(smp_processor_id(),</span><br><span class="line">				softlockup_fn, NULL,</span><br><span class="line">				this_cpu_ptr(&amp;softlockup_stop_work));</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>stop_one_cpu_nowait</code> 并不直接调用 <code>softlockup_fn</code>函数，只是将他 queue work 而已</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* queue @work to @stopper.  if offline, @work is completed immediately *&#x2F;</span><br><span class="line">static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)</span><br><span class="line">&#123;</span><br><span class="line">	struct cpu_stopper *stopper &#x3D; &amp;per_cpu(cpu_stopper, cpu);</span><br><span class="line">	DEFINE_WAKE_Q(wakeq);</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	bool enabled;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	raw_spin_lock_irqsave(&amp;stopper-&gt;lock, flags);</span><br><span class="line">	enabled &#x3D; stopper-&gt;enabled;</span><br><span class="line">	if (enabled)</span><br><span class="line">		__cpu_stop_queue_work(stopper, work, &amp;wakeq);</span><br><span class="line">	else if (work-&gt;done)</span><br><span class="line">		cpu_stop_signal_done(work-&gt;done);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;stopper-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	wake_up_q(&amp;wakeq);</span><br><span class="line">	preempt_enable();</span><br><span class="line"></span><br><span class="line">	return enabled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,</span><br><span class="line">			struct cpu_stop_work *work_buf)</span><br><span class="line">&#123;</span><br><span class="line">	*work_buf &#x3D; (struct cpu_stop_work)&#123; .fn &#x3D; fn, .arg &#x3D; arg, .caller &#x3D; _RET_IP_, &#125;;</span><br><span class="line">	return cpu_stop_queue_work(cpu, work_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 stopper 是 <code>&amp;per_cpu(cpu_stopper, cpu)</code>, 定义是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct cpu_stopper &#123;</span><br><span class="line">	struct task_struct	*thread;</span><br><span class="line"></span><br><span class="line">	raw_spinlock_t		lock;</span><br><span class="line">	bool			enabled;	&#x2F;* is this stopper enabled? *&#x2F;</span><br><span class="line">	struct list_head	works;		&#x2F;* list of pending works *&#x2F;</span><br><span class="line"></span><br><span class="line">	struct cpu_stop_work	stop_work;	&#x2F;* for stop_cpus *&#x2F;</span><br><span class="line">	unsigned long		caller;</span><br><span class="line">	cpu_stop_fn_t		fn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);</span><br></pre></td></tr></table></figure>

<p>在 每个 CPU 上的 stop_class 进程是 <code>migration/x</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct smp_hotplug_thread cpu_stop_threads &#x3D; &#123;</span><br><span class="line">	.store			&#x3D; &amp;cpu_stopper.thread,</span><br><span class="line">	.thread_should_run	&#x3D; cpu_stop_should_run,</span><br><span class="line">	.thread_fn		&#x3D; cpu_stopper_thread,</span><br><span class="line">	.thread_comm		&#x3D; &quot;migration&#x2F;%u&quot;,</span><br><span class="line">	.create			&#x3D; cpu_stop_create,</span><br><span class="line">	.park			&#x3D; cpu_stop_park,</span><br><span class="line">	.selfparking		&#x3D; true,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>shell 可以看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@zeku_server:~&#x2F;workspace&#x2F;linux $ ps -aux | grep migration</span><br><span class="line">root          14  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;0]</span><br><span class="line">root          19  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;1]</span><br><span class="line">root          25  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;2]</span><br><span class="line">root          31  0.0  0.0      0     0 ?        S    9月03   0:04 [migration&#x2F;3]</span><br><span class="line">root          37  0.0  0.0      0     0 ?        S    9月03   0:04 [migration&#x2F;4]</span><br><span class="line">root          43  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;5]</span><br><span class="line">root          49  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;6]</span><br><span class="line">root          55  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;7]</span><br><span class="line">root          61  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;8]</span><br><span class="line">root          67  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;9]</span><br><span class="line">root          73  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;10]</span><br><span class="line">root          79  0.0  0.0      0     0 ?        S    9月03   0:05 [migration&#x2F;11]</span><br><span class="line">ubuntu     35458  0.0  0.0  12224   836 pts&#x2F;0    S+   15:26   0:00 grep --color&#x3D;auto migration</span><br><span class="line">ubuntu@zeku_server:~&#x2F;workspace&#x2F;linux $</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-01T11:00:00.000Z" title="5/1/2021, 7:00:00 PM">2021-05-01</time>发表</span><span class="level-item"><time dateTime="2022-02-17T07:43:37.494Z" title="2/17/2022, 3:43:37 PM">2022-02-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">9 分钟读完 (大约1391个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/01/schedule/uclamp/">uclamp</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p>uclamp(utilzation clamp) 是说 任务 cpu使用率夹钳，主要是 userspace 对 scheduler的一些hint。</p>
<ol>
<li>比如某个 task 对用户体验有直接的影响，此 task至少需要 20%cpu，那么计算 cpu使用率，select_rq的时候，必须考虑此task的 minimum “requested”，然后选择 <code>rq</code> 和 <code>freq</code>。</li>
<li>比如某个低优先级的 task 对用户体验没有影响，此 task最多需要 60%cpu（60% &lt; 1024），那么计算 cpu使用率，select_rq的时候，必须考虑此task的 maximum “requested”，然后选择 <code>rq</code> 和<code>freq</code>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sched&#x2F;cpufreq, sched&#x2F;uclamp: Add clamps for FAIR and RT tasks</span><br><span class="line"></span><br><span class="line">    Each time a frequency update is required via schedutil, a frequency is</span><br><span class="line">    selected to (possibly) satisfy the utilization reported by each</span><br><span class="line">    scheduling class and irqs. However, when utilization clamping is in use,</span><br><span class="line">    the frequency selection should consider userspace utilization clamping</span><br><span class="line">    hints.  This will allow, for example, to:</span><br><span class="line"></span><br><span class="line">     - boost tasks which are directly affecting the user experience</span><br><span class="line">       by running them at least at a minimum &quot;requested&quot; frequency</span><br><span class="line"></span><br><span class="line">     - cap low priority tasks not directly affecting the user experience</span><br><span class="line">       by running them only up to a maximum &quot;allowed&quot; frequency</span><br></pre></td></tr></table></figure>

<p>在uapi 的头文件<code>include/uapi/linux/sched/types.h</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> @sched_util_min	represents the minimum utilization</span><br><span class="line"> @sched_util_max	represents the maximum utilization</span><br><span class="line"></span><br><span class="line">Utilization is a value in the range [0..SCHED_CAPACITY_SCALE]. It</span><br><span class="line">represents the percentage of CPU time used by a task when running at the</span><br><span class="line">maximum frequency on the highest capacity CPU of the system. For example, a</span><br><span class="line">20% utilization task is a task running for 2ms every 10ms at maximum</span><br><span class="line">frequency.</span><br><span class="line"></span><br><span class="line">A task with a min utilization value bigger than 0 is more likely scheduled</span><br><span class="line">on a CPU with a capacity big enough to fit the specified value.</span><br><span class="line">A task with a max utilization value smaller than 1024 is more likely</span><br><span class="line">scheduled on a CPU with no more capacity than the specified value.</span><br></pre></td></tr></table></figure>

<p>uclamp 的min..max 指的都是最大 freq下 的cpu使用率， 20%使用率 说的是在最大频率下，task 每10ms需要运行2ms。</p>
<h2 id="data-structure"><a href="#data-structure" class="headerlink" title="data structure"></a>data structure</h2><p>uclamp 分为<code>per sched_entity</code> 和 <code>per rq</code> 两种，分别使用 <code>struct uclamp_se</code>  <code>struct uclamp_rq</code>来描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct uclamp_se &#123;</span><br><span class="line">	unsigned int value		: bits_per(SCHED_CAPACITY_SCALE);</span><br><span class="line">	unsigned int bucket_id		: bits_per(UCLAMP_BUCKETS);</span><br><span class="line">	unsigned int active		: 1;</span><br><span class="line">	unsigned int user_defined	: 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct uclamp_rq &#123;</span><br><span class="line">	unsigned int value;</span><br><span class="line">	struct uclamp_bucket bucket[UCLAMP_BUCKETS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct rq &#123;</span><br><span class="line">	&#x2F;* runqueue lock: *&#x2F;</span><br><span class="line">	raw_spinlock_t		lock;</span><br><span class="line">#ifdef CONFIG_UCLAMP_TASK</span><br><span class="line">	&#x2F;* Utilization clamp values based on CPU&#39;s RUNNABLE tasks *&#x2F;</span><br><span class="line">	struct uclamp_rq	uclamp[UCLAMP_CNT] ____cacheline_aligned;</span><br><span class="line">	unsigned int		uclamp_flags;</span><br><span class="line">#define UCLAMP_FLAG_IDLE 0x01</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>per sched entity</code> 又分为两种，一种是 <code>per task</code>，一种是 <code>per task group</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">        ......</span><br><span class="line">#ifdef CONFIG_UCLAMP_TASK</span><br><span class="line">	&#x2F;* Clamp values requested for a scheduling entity *&#x2F;</span><br><span class="line">	struct uclamp_se		uclamp_req[UCLAMP_CNT];</span><br><span class="line">	&#x2F;* Effective clamp values used for a scheduling entity *&#x2F;</span><br><span class="line">	struct uclamp_se		uclamp[UCLAMP_CNT];</span><br><span class="line">#endif</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct task_group &#123;</span><br><span class="line">	struct cgroup_subsys_state css;</span><br><span class="line">#ifdef CONFIG_UCLAMP_TASK_GROUP</span><br><span class="line">	&#x2F;* The two decimal precision [%] value requested from user-space *&#x2F;</span><br><span class="line">	unsigned int		uclamp_pct[UCLAMP_CNT];</span><br><span class="line">	&#x2F;* Clamp values requested for a task group *&#x2F;</span><br><span class="line">	struct uclamp_se	uclamp_req[UCLAMP_CNT];</span><br><span class="line">	&#x2F;* Effective clamp values used for a task group *&#x2F;</span><br><span class="line">	struct uclamp_se	uclamp[UCLAMP_CNT];</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void __init init_uclamp(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct uclamp_se uc_max &#x3D; &#123;&#125;;</span><br><span class="line">	enum uclamp_id clamp_id;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;uclamp_mutex);</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(cpu)</span><br><span class="line">		init_uclamp_rq(cpu_rq(cpu));</span><br><span class="line"></span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		uclamp_se_set(&amp;init_task.uclamp_req[clamp_id],</span><br><span class="line">			      uclamp_none(clamp_id), false);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* System defaults allow max clamp values for both indexes *&#x2F;</span><br><span class="line">	uclamp_se_set(&amp;uc_max, uclamp_none(UCLAMP_MAX), false);</span><br><span class="line">	for_each_clamp_id(clamp_id) &#123;</span><br><span class="line">		uclamp_default[clamp_id] &#x3D; uc_max;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="kernel-api"><a href="#kernel-api" class="headerlink" title="kernel api"></a>kernel api</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static inline void uclamp_rq_inc(struct rq *rq, struct task_struct *p) &#123; &#125;</span><br><span class="line">static inline void uclamp_rq_dec(struct rq *rq, struct task_struct *p) &#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	if (!(flags &amp; ENQUEUE_NOCLOCK))</span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	if (!(flags &amp; ENQUEUE_RESTORE)) &#123;</span><br><span class="line">		sched_info_queued(rq, p);</span><br><span class="line">		psi_enqueue(p, flags &amp; ENQUEUE_WAKEUP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uclamp_rq_inc(rq, p);</span><br><span class="line">	p-&gt;sched_class-&gt;enqueue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	if (!(flags &amp; DEQUEUE_NOCLOCK))</span><br><span class="line">		update_rq_clock(rq);</span><br><span class="line"></span><br><span class="line">	if (!(flags &amp; DEQUEUE_SAVE)) &#123;</span><br><span class="line">		sched_info_dequeued(rq, p);</span><br><span class="line">		psi_dequeue(p, flags &amp; DEQUEUE_SLEEP);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	uclamp_rq_dec(rq, p);</span><br><span class="line">	p-&gt;sched_class-&gt;dequeue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>enqueue_task</code> <code>dequeue_task</code> 中会 根据 此task是否 开启 uclamp来更改 <code>rq</code>的统计的<code>uclamp_rq</code> 数据。</p>
<p><img src="/images/image.jpg"></p>
<h3 id="user-api"><a href="#user-api" class="headerlink" title="user api"></a>user api</h3><p>uclamp 在 <code>userspace</code> 提供了三类接口</p>
<ul>
<li>全局uclamp接口 <code>/proc/sys/kernel/sched_util_clamp_min</code> <code>/proc/sys/kernel/sched_util_clamp_max</code></li>
<li>cgroup based API <code>cpu.uclamp.max</code> <code>cpu.uclamp.min</code></li>
<li>per-task API</li>
</ul>
<p>一般全局uclamp接口都是设置为 min-1024 max-1024。<br>cgroup 接口一般只会限制最大使用率<br>per-task的情况较为复杂，以pixel6为例：</p>
<p>在pixel6搭载的Android 12中，google去除了<code>schedtue</code> <code>sched boost</code>等机制，pixel6 且采用了双X1架构的芯片，没有使用walt算法。为了尽量提升用户流畅性体验，所以对uclamp较为依赖。</p>
<p>kernel space对外提供的接口是 <code>sched_setattr</code>, android 框架层对他做了封装<a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:hardware/google/pixel/power-libperfmgr/aidl/PowerHintSession.cpp;bpv=1;bpt=1;l=181?q=sched_setattr">setUclamp</a></p>
<p>在 <code>pixel6</code> 中使用 uclamp的场景大概分为以下几类:</p>
<ul>
<li>应用启动</li>
<li>滑动boost</li>
<li>top-app</li>
</ul>
<p>首先是应用启动，应用启动往往需要创建多个线程，读取很多资源。所以在应用冷启动时刻，除了将所有cpu的频率固定在最高频之外，还将应用的 <code>UI_thread</code> <code>Render_thread</code> <code>hwui_task0</code> <code>hwui_task1</code> uclamp直接设置为 512，这样会使得这几个重载线程在启动时刻就跑在超大核心上，减少应用冷启动时间。</p>
<p>滑动场景，由于滑动场景有较多复杂的动画，<code>UI_thread</code> <code>Render_thread</code> <code>hwui_task0</code> <code>hwui_task1</code>的负载较重，如果不及时上超大核，有丢帧的风险，所以滑动场景也是将这几个task的uclamp_min 设置为 512，来保证可以上超大核。</p>
<p>游戏场景，由于游戏等前台应用对响应时间较为敏感，pixel6 上android的框架层直接将 <code>ta_uclamp_min</code> 设置为 185或者更多，这样游戏进程主线程或者其他前台进程主线程就无法泡在小核心上，至少是大核起步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">raven:&#x2F;sys&#x2F;kernel&#x2F;vendor_sched # cat ta_uclamp_min</span><br><span class="line">185</span><br><span class="line">raven:&#x2F;sys&#x2F;kernel&#x2F;vendor_sched #</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-30T11:00:00.000Z" title="4/30/2021, 7:00:00 PM">2021-04-30</time>发表</span><span class="level-item"><time dateTime="2021-05-18T09:28:05.668Z" title="5/18/2021, 5:28:05 PM">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">1 分钟读完 (大约204个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/30/schedule/fair/">fair</a></h1><div class="content"><h2 id="reweight-entity"><a href="#reweight-entity" class="headerlink" title="reweight_entity"></a>reweight_entity</h2><p>sched_init()-&gt;|<br>              |-&gt;set_load_weight(p, false)<br>sched_fork()-&gt;|</p>
<p>set_user_nice()———&gt;|<br>                         |-&gt;set_load_weight(p, true)-&gt;reweight_task()-&gt;reweight_entity()<br>__setscheduler_params()-&gt;|</p>
<p>只会在 cfs task改变 task nice值 或者 改变调度参数的时候会 调用到 <code>reweight_entity()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se,</span><br><span class="line">			    unsigned long weight, unsigned long runnable)</span><br><span class="line">&#123;</span><br><span class="line">	if (se-&gt;on_rq) &#123;</span><br><span class="line">		&#x2F;* commit outstanding execution time *&#x2F;</span><br><span class="line">		if (cfs_rq-&gt;curr &#x3D;&#x3D; se)</span><br><span class="line">			update_curr(cfs_rq);</span><br><span class="line">		account_entity_dequeue(cfs_rq, se);</span><br><span class="line">		dequeue_runnable_load_avg(cfs_rq, se);</span><br><span class="line">	&#125;</span><br><span class="line">	dequeue_load_avg(cfs_rq, se);</span><br><span class="line"></span><br><span class="line">	se-&gt;runnable_weight &#x3D; runnable;</span><br><span class="line">	update_load_set(&amp;se-&gt;load, weight);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	do &#123;</span><br><span class="line">		u32 divider &#x3D; LOAD_AVG_MAX - 1024 + se-&gt;avg.period_contrib;</span><br><span class="line"></span><br><span class="line">		se-&gt;avg.load_avg &#x3D; div_u64(se_weight(se) * se-&gt;avg.load_sum, divider);</span><br><span class="line">		se-&gt;avg.runnable_load_avg &#x3D;</span><br><span class="line">			div_u64(se_runnable(se) * se-&gt;avg.runnable_load_sum, divider);</span><br><span class="line">	&#125; while (0);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	enqueue_load_avg(cfs_rq, se);</span><br><span class="line">	if (se-&gt;on_rq) &#123;</span><br><span class="line">		account_entity_enqueue(cfs_rq, se);</span><br><span class="line">		enqueue_runnable_load_avg(cfs_rq, se);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于重新计算 load_weight，所以需要 xx_dequeue() and xx_enqueue()。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-30T11:00:00.000Z" title="4/30/2021, 7:00:00 PM">2021-04-30</time>发表</span><span class="level-item"><time dateTime="2021-05-19T08:41:21.380Z" title="5/19/2021, 4:41:21 PM">2021-05-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">11 分钟读完 (大约1612个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/30/schedule/util_est/">util_est</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p><code>struct util_est - Estimation utilization of FAIR tasks</code><br>这是一个评估 <code>fair</code> task的 utilization的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">It&#39;s worth noting that the estimated utilization is tracked only for</span><br><span class="line"> objects of interests, specifically:</span><br><span class="line"></span><br><span class="line">  - Tasks: to better support tasks placement decisions</span><br><span class="line">  - root cfs_rqs: to better support both tasks placement decisions as</span><br><span class="line">                  well as frequencies selection</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Moreover, the PELT utilization of a task can be updated every [ms], thus</span><br><span class="line"> making it a continuously changing value for certain longer running</span><br><span class="line"> tasks. This means that the instantaneous PELT utilization of a RUNNING</span><br><span class="line"> task is not really meaningful to properly support scheduler decisions.</span><br><span class="line"></span><br><span class="line"> For all these reasons, a more stable signal can do a better job of</span><br><span class="line"> representing the expected&#x2F;estimated utilization of a task&#x2F;cfs_rq.</span><br><span class="line"> Such a signal can be easily created on top of PELT by still using it as</span><br><span class="line"> an estimator which produces values to be aggregated on meaningful</span><br><span class="line"> events.</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct util_est - Estimation utilization of FAIR tasks</span><br><span class="line"> * @enqueued: instantaneous estimated utilization of a task&#x2F;cpu -- task的 瞬时的 util</span><br><span class="line"> * @ewma:     the Exponential Weighted Moving Average (EWMA)</span><br><span class="line"> *            utilization of a task                             -- task的 EWMA（移动加权平均） 的 util</span><br><span class="line"> *</span><br><span class="line"> * Support data structure to track an Exponential Weighted Moving Average</span><br><span class="line"> * (EWMA) of a FAIR task&#39;s utilization. New samples are added to the moving</span><br><span class="line"> * average each time a task completes an activation. Sample&#39;s weight is chosen</span><br><span class="line"> * so that the EWMA will be relatively insensitive to transient changes to the</span><br><span class="line"> * task&#39;s workload.</span><br><span class="line"> *</span><br><span class="line"> * The enqueued attribute has a slightly different meaning for tasks and cpus:</span><br><span class="line"> * - task:   the task&#39;s util_avg at last task dequeue time</span><br><span class="line"> * - cfs_rq: the sum of util_est.enqueued for each RUNNABLE task on that CPU</span><br><span class="line"> * Thus, the util_est.enqueued of a task represents the contribution on the</span><br><span class="line"> * estimated utilization of the CPU where that task is currently enqueued.</span><br><span class="line"> *</span><br><span class="line"> * Only for tasks we track a moving average of the past instantaneous</span><br><span class="line"> * estimated utilization. This allows to absorb sporadic drops in utilization</span><br><span class="line"> * of an otherwise almost periodic task.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct util_est &#123;</span><br><span class="line">	unsigned int			enqueued;</span><br><span class="line">	unsigned int			ewma;</span><br><span class="line">#define UTIL_EST_WEIGHT_SHIFT		2</span><br><span class="line">&#125; __attribute__((__aligned__(sizeof(u64))));</span><br></pre></td></tr></table></figure>

<p>当一个 <code>task</code> 完成一次激活（？？enqueue?）的时候，最新的采样会被 加权之后添加到 EWMA中；因为会对 <code>sample</code> 做一个加权，所以 <code>EWMA</code> 对 <code>task workload</code>的瞬时量不会态敏感。</p>
<p><code>.enqueue</code> 这个含义对 <code>task</code> 与 <code>cpu</code> 有些不一样:<br><code>task</code>: 在上次 dequeue时刻，task的 util_avg<br><code>cfs_rq</code>: 在 这个cpu上 所有 <code>RUNNABLE task</code>的 <code>util_est.enqueued</code>之和</p>
<p>我们只对 <code>tasks</code> 跟踪 过去瞬时的 util，不会对 <code>cpu</code>跟踪这个。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><code>util_est</code> 对外部只提供了四个API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline void util_est_enqueue(struct cfs_rq *cfs_rq,</span><br><span class="line">				    struct task_struct *p);</span><br><span class="line"></span><br><span class="line">static inline void util_est_dequeue(struct cfs_rq *cfs_rq,</span><br><span class="line">				    struct task_struct *p);</span><br><span class="line"></span><br><span class="line">static inline void util_est_update(struct cfs_rq *cfs_rq,</span><br><span class="line">				   struct task_struct *p,</span><br><span class="line">				   bool task_sleep);</span><br><span class="line"></span><br><span class="line">static inline void cfs_se_util_change(struct sched_avg *avg);</span><br></pre></td></tr></table></figure>


<p><code>util_est_enqueue</code> <code>util_est_dequeue</code> 都是只在 <code>enqueue_task_fair</code> <code>dequeue_task_fair</code> 中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">enqueue_task_fair(struct rq *rq, struct task_struct *p, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct cfs_rq *cfs_rq;</span><br><span class="line">	struct sched_entity *se &#x3D; &amp;p-&gt;se;</span><br><span class="line">	int idle_h_nr_running &#x3D; task_has_idle_policy(p);</span><br><span class="line">	int task_new &#x3D; !(flags &amp; ENQUEUE_WAKEUP);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The code below (indirectly) updates schedutil which looks at</span><br><span class="line">	 * the cfs_rq utilization to select a frequency.</span><br><span class="line">	 * Let&#39;s add the task&#39;s estimated utilization to the cfs_rq&#39;s</span><br><span class="line">	 * estimated utilization, before we update schedutil.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	util_est_enqueue(&amp;rq-&gt;cfs, p);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct cfs_rq *cfs_rq;</span><br><span class="line">	struct sched_entity *se &#x3D; &amp;p-&gt;se;</span><br><span class="line">	int task_sleep &#x3D; flags &amp; DEQUEUE_SLEEP;</span><br><span class="line">	int idle_h_nr_running &#x3D; task_has_idle_policy(p);</span><br><span class="line">	bool was_sched_idle &#x3D; sched_idle_rq(rq);</span><br><span class="line"></span><br><span class="line">	util_est_dequeue(&amp;rq-&gt;cfs, p);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">dequeue_throttle:</span><br><span class="line">	util_est_update(&amp;rq-&gt;cfs, p, task_sleep);</span><br><span class="line">	hrtick_update(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>enqueue_task_fair</code> 中调用 <code>util_est_enqueue</code> 时，此时 task-&gt;entity 还未 入队<br><code>dequeue_task_fair</code> 中调用 <code>util_est_dequeue</code> 时，此时 task-&gt;entity 还未 出队</p>
<p>在 <code>enqueue_task_fair</code> <code>dequeue_task_fair</code> 中，会对 <code>entity</code> 进行 <code>enqueue_entity</code> 和 <code>dequeue_entity</code>，两个过程都需要 <code>update_load_avg</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static inline void cfs_se_util_change(struct sched_avg *avg)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int enqueued;</span><br><span class="line"></span><br><span class="line">	if (!sched_feat(UTIL_EST))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Avoid store if the flag has been already set *&#x2F;</span><br><span class="line">	enqueued &#x3D; avg-&gt;util_est.enqueued;</span><br><span class="line">	if (!(enqueued &amp; UTIL_AVG_UNCHANGED))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Reset flag to report util_avg has been updated *&#x2F;</span><br><span class="line">	enqueued &amp;&#x3D; ~UTIL_AVG_UNCHANGED;</span><br><span class="line">	WRITE_ONCE(avg-&gt;util_est.enqueued, enqueued);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __update_load_avg_se(u64 now, struct cfs_rq *cfs_rq, struct sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">	if (___update_load_sum(now, &amp;se-&gt;avg, !!se-&gt;on_rq, se_runnable(se),</span><br><span class="line">				cfs_rq-&gt;curr &#x3D;&#x3D; se)) &#123;</span><br><span class="line"></span><br><span class="line">		___update_load_avg(&amp;se-&gt;avg, se_weight(se));</span><br><span class="line">		cfs_se_util_change(&amp;se-&gt;avg);</span><br><span class="line">		trace_pelt_se_tp(se);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void update_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	u64 now &#x3D; cfs_rq_clock_pelt(cfs_rq);</span><br><span class="line">	int decayed;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Track task load average for carrying it to new CPU after migrated, and</span><br><span class="line">	 * track group sched_entity load average for task_h_load calc in migration</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (se-&gt;avg.last_update_time &amp;&amp; !(flags &amp; SKIP_AGE_LOAD))</span><br><span class="line">		__update_load_avg_se(now, cfs_rq, se);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以一个 task <code>enqueue</code> <code>dequeue</code> 两个过程 和 util_est相关的流程是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">enqueue_task_fair</span><br><span class="line">    |</span><br><span class="line">    util_est_enqueue</span><br><span class="line">    |</span><br><span class="line">    enqueue_entity</span><br><span class="line">        |</span><br><span class="line">        update_load_avg</span><br><span class="line">            |</span><br><span class="line">            __update_load_avg_se</span><br><span class="line">                |</span><br><span class="line">                cfs_se_util_change</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">dequeue_task_fair</span><br><span class="line">    |</span><br><span class="line">    util_est_dequeue</span><br><span class="line">    |</span><br><span class="line">    enqueue_entity</span><br><span class="line">        |</span><br><span class="line">        update_load_avg</span><br><span class="line">            |</span><br><span class="line">            __update_load_avg_se</span><br><span class="line">                |</span><br><span class="line">                cfs_se_util_change</span><br><span class="line">    |</span><br><span class="line">    util_est_update</span><br></pre></td></tr></table></figure>

<p>都是先要经过 <code>cfs_se_util_change</code> 然后再经过 <code>dequeue_task_fair</code> 中的<code>util_est_update</code> ，在 <code>util_est_update</code> 中更新 EWMA的值。</p>
<p>内部实现使用了 <code>UTIL_AVG_UNCHANGED</code> 这个变量来同步这两个过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * When a task is dequeued, its estimated utilization should not be update if</span><br><span class="line"> * its util_avg has not been updated at least once.</span><br><span class="line"> * This flag is used to synchronize util_avg updates with util_est updates.</span><br><span class="line"> * We map this information into the LSB bit of the utilization saved at</span><br><span class="line"> * dequeue time (i.e. util_est.dequeued).</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="EWMA是啥？"><a href="#EWMA是啥？" class="headerlink" title="EWMA是啥？"></a>EWMA是啥？</h2><p>参考<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/EWMA">EWMA</a></p>
<p>EWMA - Exponential Weighted Moving Average 指数加权移动平均。</p>
<p>ewma(t) = w *  task_util(p) + (1-w) * ewma(t-1)<br>        = w *  task_util(p) +         ewma(t-1)  - w * ewma(t-1)<br>        = w * (task_util(p) -         ewma(t-1)) +     ewma(t-1)<br>        = w * (      last_ewma_diff            ) +     ewma(t-1)<br>        = w * (last_ewma_diff  +  ewma(t-1) / w)</p>
<p>其中 w = 0.25 = 1 / 4</p>
<p>ewma(t) = (last_ewma_diff + ewma(t-1) &lt;&lt; 2)   &gt;&gt; 2<br>        = (last_ewma_diff + ewma(t-1) &lt;&lt; UTIL_EST_WEIGHT_SHIFT)   &gt;&gt; UTIL_EST_WEIGHT_SHIFT</p>
<p>当前 采样周期只占用到了 (1 / 4) 权重</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>为了更快追踪负载的变化，util_est 作者引入了另一个 feature <code>UTIL_EST_FASTUP</code>, 用来加速 util上升</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sched&#x2F;fair&#x2F;util_est: Implement faster ramp-up EWMA on utilization increases</span><br><span class="line"></span><br><span class="line">The estimated utilization for a task:</span><br><span class="line"></span><br><span class="line">   util_est &#x3D; max(util_avg, est.enqueue, est.ewma)</span><br><span class="line"></span><br><span class="line">is defined based on:</span><br><span class="line"></span><br><span class="line"> - util_avg: the PELT defined utilization</span><br><span class="line"> - est.enqueued: the util_avg at the end of the last activation</span><br><span class="line"> - est.ewma:     a exponential moving average on the est.enqueued samples</span><br><span class="line"></span><br><span class="line">According to this definition, when a task suddenly changes its bandwidth</span><br><span class="line">requirements from small to big, the EWMA will need to collect multiple</span><br><span class="line">samples before converging up to track the new big utilization.</span><br><span class="line"></span><br><span class="line">This slow convergence towards bigger utilization values is not</span><br><span class="line">aligned to the default scheduler behavior, which is to optimize for</span><br><span class="line">performance. Moreover, the est.ewma component fails to compensate for</span><br><span class="line">temporarely utilization drops which spans just few est.enqueued samples.</span><br><span class="line"></span><br><span class="line">To let util_est do a better job in the scenario depicted above, change</span><br><span class="line">its definition by making util_est directly follow upward motion and</span><br><span class="line">only decay the est.ewma on downward.</span><br></pre></td></tr></table></figure>

<p>主要改动是这里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--- a&#x2F;kernel&#x2F;sched&#x2F;fair.c</span><br><span class="line">+++ b&#x2F;kernel&#x2F;sched&#x2F;fair.c</span><br><span class="line">@@ -3768,11 +3768,22 @@ util_est_dequeue(struct cfs_rq *cfs_rq, struct task_struct *p, bool task_sleep)</span><br><span class="line">        if (ue.enqueued &amp; UTIL_AVG_UNCHANGED)</span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">+       &#x2F;*</span><br><span class="line">+        * Reset EWMA on utilization increases, the moving average is used only</span><br><span class="line">+        * to smooth utilization decreases.</span><br><span class="line">+        *&#x2F;</span><br><span class="line">+       ue.enqueued &#x3D; (task_util(p) | UTIL_AVG_UNCHANGED);</span><br><span class="line">+       if (sched_feat(UTIL_EST_FASTUP)) &#123;</span><br><span class="line">+               if (ue.ewma &lt; ue.enqueued) &#123;</span><br><span class="line">+                       ue.ewma &#x3D; ue.enqueued;</span><br><span class="line">+                       goto done;</span><br><span class="line">+               &#125;</span><br><span class="line">+       &#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>
<p>开启 <code>UTIL_EST_FASTUP</code> 之后， 如果检测到 ewma(t-1) &lt; .enqueued 直接用当前的 负载util 替换掉<br>历史负载 ewma.</p>
<p>这样task 在 <code>small_to_big</code> 的时候可以更快的跟踪负载，从而更好地 调频与 升核。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-21T11:00:00.000Z" title="4/21/2021, 7:00:00 PM">2021-04-21</time>发表</span><span class="level-item"><time dateTime="2021-04-21T06:12:55.960Z" title="4/21/2021, 2:12:55 PM">2021-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">10 分钟读完 (大约1461个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/21/schedule/ipi_sched/">ipi_sched</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p>IPI 中断 (Inter-Processor Interrupts) ，核间中断可以通过向这个寄存器写入需要的值来产生。若硬件线程 A 想要发送一个核间中断给硬件线程 B，它只需要向寄存器 IPIBase 中写入 B<br>的 Thread ID、中断向量、中断类型等值就可以了，PIC 会通知 B 所在的核挂起它当前的执行序列，并根据中断向量跳转到中断服务例程 ISR 的入口</p>
<h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW?"></a>HOW?</h2><p>linux上将 IPI 中断分为以下几类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum ipi_msg_type &#123;</span><br><span class="line">	IPI_RESCHEDULE,</span><br><span class="line">	IPI_CALL_FUNC,</span><br><span class="line">	IPI_CPU_STOP,</span><br><span class="line">	IPI_CPU_CRASH_STOP,</span><br><span class="line">	IPI_TIMER,</span><br><span class="line">	IPI_IRQ_WORK,</span><br><span class="line">	IPI_WAKEUP</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>通过接口 <code>smp_cross_call</code> 调用，For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void smp_send_reschedule(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	smp_cross_call(cpumask_of(cpu), IPI_RESCHEDULE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>CPUa 给 CPUb 发送一个 <code>IPI_RESCHEDULE</code> 信号，然后 CPUb执行相关函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Main handler for inter-processor interrupts</span><br><span class="line"> *&#x2F;</span><br><span class="line">void handle_IPI(int ipinr, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int cpu &#x3D; smp_processor_id();</span><br><span class="line">	struct pt_regs *old_regs &#x3D; set_irq_regs(regs);</span><br><span class="line"></span><br><span class="line">	switch (ipinr) &#123;</span><br><span class="line">	case IPI_RESCHEDULE:</span><br><span class="line">		scheduler_ipi();</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case IPI_CALL_FUNC:</span><br><span class="line">		irq_enter();</span><br><span class="line">		generic_smp_call_function_interrupt();</span><br><span class="line">		irq_exit();</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">	set_irq_regs(old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="scheduler-ipi-主要工作？"><a href="#scheduler-ipi-主要工作？" class="headerlink" title="scheduler_ipi 主要工作？"></a>scheduler_ipi 主要工作？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void scheduler_ipi(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting</span><br><span class="line">	 * TIF_NEED_RESCHED remotely (for the first time) will also send</span><br><span class="line">	 * this IPI.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	preempt_fold_need_resched();</span><br><span class="line"></span><br><span class="line">	if (llist_empty(&amp;this_rq()-&gt;wake_list) &amp;&amp; !got_nohz_idle_kick())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Not all reschedule IPI handlers call irq_enter&#x2F;irq_exit, since</span><br><span class="line">	 * traditionally all their work was done from the interrupt return</span><br><span class="line">	 * path. Now that we actually do some work, we need to make sure</span><br><span class="line">	 * we do call them.</span><br><span class="line">	 *</span><br><span class="line">	 * Some archs already do call them, luckily irq_enter&#x2F;exit nest</span><br><span class="line">	 * properly.</span><br><span class="line">	 *</span><br><span class="line">	 * Arguably we should visit all archs and update all handlers,</span><br><span class="line">	 * however a fair share of IPIs are still resched only so this would</span><br><span class="line">	 * somewhat pessimize the simple resched case.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	irq_enter();</span><br><span class="line">	sched_ttwu_pending();</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Check if someone kicked us for doing the nohz idle load balance.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (unlikely(got_nohz_idle_kick())) &#123;</span><br><span class="line">		this_rq()-&gt;idle_balance &#x3D; 1;</span><br><span class="line">		raise_softirq_irqoff(SCHED_SOFTIRQ);</span><br><span class="line">	&#125;</span><br><span class="line">	irq_exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>llist_empty(&amp;this_rq()-&gt;wake_list)</code> 成立，意味着rq上没有需要wake_up的thread，且同时 <code>!got_nohz_idle_kick()</code>也成立的话，就直接返回了，这个 IPI就是无效的。</p>
<p>正常都会继续往下继续走，重点是 <code>sched_ttwu_pending</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void sched_ttwu_pending(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; this_rq();</span><br><span class="line">	struct llist_node *llist &#x3D; llist_del_all(&amp;rq-&gt;wake_list);</span><br><span class="line">	struct task_struct *p, *t;</span><br><span class="line">	struct rq_flags rf;</span><br><span class="line"></span><br><span class="line">	if (!llist)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">        &#x2F;&#x2F; 一次性唤醒所有 &#96;wake_list&#96; 上的task。</span><br><span class="line">	llist_for_each_entry_safe(p, t, llist, wake_entry)</span><br><span class="line">		ttwu_do_activate(rq, p, p-&gt;sched_remote_wakeup ? WF_MIGRATED : 0, &amp;rf);</span><br><span class="line"></span><br><span class="line">	rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后查看是否需要做 <code>load_balance</code></p>
<h2 id="什么情况下会发送-IPI-RESCHEDULE？"><a href="#什么情况下会发送-IPI-RESCHEDULE？" class="headerlink" title="什么情况下会发送 IPI_RESCHEDULE？"></a>什么情况下会发送 IPI_RESCHEDULE？</h2><ol>
<li>resched_curr()<br>如果cpu == smp_processor_id()，(这里分为俩种情况，1. UP架构只有一个CPU 2. SMP架构上恰好resched_curr()的是本cpu)<br>那仅仅是设置 当前 curr的thread_info的 need_resched标志位。<br>如果是需要其他cpu执行 resched_curr()，就需要 <code>smp_send_reschedule(cpu)</code> 来发送 <code>IPI_RESCHEDULE</code>了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * resched_curr - mark rq&#39;s current task &#39;to be rescheduled now&#39;.</span><br><span class="line"> *</span><br><span class="line"> * On UP this means the setting of the need_resched flag, on SMP it</span><br><span class="line"> * might also involve a cross-CPU call to trigger the scheduler on</span><br><span class="line"> * the target CPU.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void resched_curr(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *curr &#x3D; rq-&gt;curr;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	if (test_tsk_need_resched(curr))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	cpu &#x3D; cpu_of(rq);</span><br><span class="line"></span><br><span class="line">	if (cpu &#x3D;&#x3D; smp_processor_id()) &#123;</span><br><span class="line">		set_tsk_need_resched(curr);</span><br><span class="line">		set_preempt_need_resched();</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (set_nr_and_not_polling(curr))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	else</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li>wake_up_idle_cpu()</li>
</ol>
<p>在唤醒一个 idle的cpu时，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void wake_up_idle_cpu(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	if (cpu &#x3D;&#x3D; smp_processor_id())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (set_nr_and_not_polling(rq-&gt;idle))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	else</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>kick_process()</li>
</ol>
<p>让一个 task立刻进入 kernel mode（without any delay），从而来处理 signal信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> * kick_process - kick a running thread to enter&#x2F;exit the kernel</span><br><span class="line"> * @p: the to-be-kicked thread</span><br><span class="line"> *</span><br><span class="line"> * Cause a process which is running on another CPU to enter</span><br><span class="line"> * kernel-mode, without any delay. (to get signals handled.)</span><br><span class="line"> *</span><br><span class="line"> * NOTE: this function doesn&#39;t have to take the runqueue lock,</span><br><span class="line"> * because all it wants to ensure is that the remote task enters</span><br><span class="line"> * the kernel. If the IPI races and the task has been migrated</span><br><span class="line"> * to another CPU then no harm is done and the purpose has been</span><br><span class="line"> * achieved as well.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void kick_process(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu &#x3D; task_cpu(p);</span><br><span class="line">	if ((cpu !&#x3D; smp_processor_id()) &amp;&amp; task_curr(p))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(kick_process);</span><br><span class="line"></span><br><span class="line">void signal_wake_up_state(struct task_struct *t, unsigned int state)</span><br><span class="line">&#123;</span><br><span class="line">	set_tsk_thread_flag(t, TIF_SIGPENDING);</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * TASK_WAKEKILL also means wake it up in the stopped&#x2F;traced&#x2F;killable</span><br><span class="line">	 * case. We don&#39;t check t-&gt;state here because there is a race with it</span><br><span class="line">	 * executing another processor and just now entering stopped state.</span><br><span class="line">	 * By using wake_up_state, we ensure the process will wake up and</span><br><span class="line">	 * handle its death signal.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!wake_up_state(t, state | TASK_INTERRUPTIBLE))</span><br><span class="line">		kick_process(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>ttwu_queue_remote()</li>
</ol>
<p>try_to_wake_up() 一个thread之后，需要将 这个task入队<br>a. 如果是 task不是在 <code>本cpu</code> 唤醒的，那就需要IPI中断<code>smp_send_reschedule</code>来搞了<br>b. 如果是在 <code>本地cpu</code> 唤醒的，就直接 lock_rq() 之后进行 <code>ttwu_do_activate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static void ttwu_queue_remote(struct task_struct *p, int cpu, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	p-&gt;sched_remote_wakeup &#x3D; !!(wake_flags &amp; WF_MIGRATED);</span><br><span class="line"></span><br><span class="line">	if (llist_add(&amp;p-&gt;wake_entry, &amp;cpu_rq(cpu)-&gt;wake_list)) &#123;</span><br><span class="line">		if (!set_nr_if_polling(rq-&gt;idle))</span><br><span class="line">			smp_send_reschedule(cpu);</span><br><span class="line">		else</span><br><span class="line">			trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void ttwu_queue(struct task_struct *p, int cpu, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line">	struct rq_flags rf;</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_SMP)</span><br><span class="line">	if (sched_feat(TTWU_QUEUE) &amp;&amp; !cpus_share_cache(smp_processor_id(), cpu)) &#123;</span><br><span class="line">		sched_clock_cpu(cpu); &#x2F;* Sync clocks across CPUs *&#x2F;</span><br><span class="line">		ttwu_queue_remote(p, cpu, wake_flags);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	ttwu_do_activate(rq, p, wake_flags, &amp;rf);</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>wake_up_if_idle()<br><code>wake_up_if_idle()</code> 只有在 <code>wake_up_all_idle_cpus()</code> 中被调用，主要是看此 cpu 是否idle空闲，就是看他 <code>is_idle_task(cpu_rq(cpu)-&gt;curr)</code> 是否成立，成立的话就需要 IPI中断去唤醒。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void wake_up_if_idle(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line">	struct rq_flags rf;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	if (!is_idle_task(rcu_dereference(rq-&gt;curr)))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	if (set_nr_if_polling(rq-&gt;idle)) &#123;</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">		if (is_idle_task(rq-&gt;curr))</span><br><span class="line">			smp_send_reschedule(cpu);</span><br><span class="line">		&#x2F;* Else CPU is not idle, do nothing here: *&#x2F;</span><br><span class="line">		rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void wake_up_all_idle_cpus(void)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	for_each_online_cpu(cpu) &#123;</span><br><span class="line">		if (cpu &#x3D;&#x3D; smp_processor_id())</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		wake_up_if_idle(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>參考linux-5.4.61代码</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-15T11:00:00.000Z" title="4/15/2021, 7:00:00 PM">2021-04-15</time>发表</span><span class="level-item"><time dateTime="2021-04-15T02:37:17.900Z" title="4/15/2021, 10:37:17 AM">2021-04-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/frequency-governer/">frequency governer</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/frequency-governer/schedule-util/">schedule util</a></span><span class="level-item">几秒读完 (大约12个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/15/schedule/freq%20governer/">freq governer</a></h1><div class="content"><p>参考<a href="Documentation/admin-guide/pm/cpufreq.rst">内核文档</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/linux-kernel/linux-schedule/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/linux-kernel/linux-schedule/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/linux-kernel/linux-schedule/">1</a></li><li><a class="pagination-link" href="/categories/linux-kernel/linux-schedule/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Hui Su"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Hui Su</p><p class="is-size-6 is-block">liulangren bolg</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">115</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">143</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liulangrenaaa" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liulangrenaaa"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.google.com.hk/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Google</span></span><span class="level-right"><span class="level-item tag">www.google.com.hk</span></span></a></li><li><a class="level is-mobile" href="https://lkml.org/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">LKML</span></span><span class="level-right"><span class="level-item tag">lkml.org</span></span></a></li><li><a class="level is-mobile" href="https://mail.google.com/mail" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gmail</span></span><span class="level-right"><span class="level-item tag">mail.google.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhihu.com/explore" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/contest/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 剑指offer</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 周赛</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://tongji.baidu.com/web/32051076/overview/index?siteId=16230094" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">百度分析</span></span><span class="level-right"><span class="level-item tag">tongji.baidu.com</span></span></a></li><li><a class="level is-mobile" href="https://analytics.google.com/analytics/web/#/a187909645p259761261/admin/streams/table/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">google分析</span></span><span class="level-right"><span class="level-item tag">analytics.google.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BRK/"><span class="tag">BRK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HW/"><span class="tag">HW</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KASAN/"><span class="tag">KASAN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OOM/"><span class="tag">OOM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QCOM/"><span class="tag">QCOM</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aarch64/"><span class="tag">aarch64</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/acl/"><span class="tag">acl</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android-framework/"><span class="tag">android framework</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android12-gdb64%E8%B0%83%E8%AF%95%E8%BF%9B%E7%A8%8B/"><span class="tag">android12 gdb64调试进程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpf/"><span class="tag">bpf</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpftrace/"><span class="tag">bpftrace</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup/"><span class="tag">cgroup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v1/"><span class="tag">cgroup v1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v2/"><span class="tag">cgroup v2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpu%E8%B0%83%E9%A2%91/"><span class="tag">cpu调频</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/crash/"><span class="tag">crash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dd/"><span class="tag">dd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/deadlock/"><span class="tag">deadlock</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debugfs/"><span class="tag">debugfs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/double-free/"><span class="tag">double free</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/drop-caches/"><span class="tag">drop_caches</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dumpe2fs/"><span class="tag">dumpe2fs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/eas/"><span class="tag">eas</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/event-trace/"><span class="tag">event trace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ext2/"><span class="tag">ext2</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-attr/"><span class="tag">file attr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-hole/"><span class="tag">file hole</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/filesystem/"><span class="tag">filesystem</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fsck/"><span class="tag">fsck</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ftrace/"><span class="tag">ftrace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gdb/"><span class="tag">gdb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hardlockup/"><span class="tag">hardlockup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hrtimer/"><span class="tag">hrtimer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hugepage/"><span class="tag">hugepage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hungtask/"><span class="tag">hungtask</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/interrupt/"><span class="tag">interrupt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt/"><span class="tag">intrrrupt</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt-storm/"><span class="tag">intrrrupt storm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/irq/"><span class="tag">irq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kallsyms/"><span class="tag">kallsyms</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kdump/"><span class="tag">kdump</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kernel-patch/"><span class="tag">kernel patch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kfence/"><span class="tag">kfence</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kmemleak/"><span class="tag">kmemleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kprobes/"><span class="tag">kprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kretprobes/"><span class="tag">kretprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ksoftirqd/"><span class="tag">ksoftirqd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kthread/"><span class="tag">kthread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvm/"><span class="tag">kvm</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvmtool/"><span class="tag">kvmtool</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/launch-json/"><span class="tag">launch.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-kernel/"><span class="tag">linux kernel</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-native-aio/"><span class="tag">linux native aio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lock-stat/"><span class="tag">lock_stat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lockdep/"><span class="tag">lockdep</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/makedumpfile/"><span class="tag">makedumpfile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memleak/"><span class="tag">memleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory/"><span class="tag">memory</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory-direct-reclaim/"><span class="tag">memory direct reclaim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mount/"><span class="tag">mount</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/namespace/"><span class="tag">namespace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oom/"><span class="tag">oom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oops/"><span class="tag">oops</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-cache/"><span class="tag">page_cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-owner/"><span class="tag">page_owner</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pagecache/"><span class="tag">pagecache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pagemap/"><span class="tag">pagemap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/panic/"><span class="tag">panic</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/per-cpu/"><span class="tag">per-cpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/perf/"><span class="tag">perf</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/perf-c2c/"><span class="tag">perf c2c</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pid-namespace/"><span class="tag">pid namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preempt-count/"><span class="tag">preempt_count</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preemption/"><span class="tag">preemption</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pressure/"><span class="tag">pressure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/process-madvise/"><span class="tag">process_madvise</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psi/"><span class="tag">psi</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psoix-aio/"><span class="tag">psoix aio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/randomize-va-space/"><span class="tag">randomize_va_space</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rcu/"><span class="tag">rcu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/read-code/"><span class="tag">read code</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sched-latency/"><span class="tag">sched latency</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/schedule/"><span class="tag">schedule</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slab/"><span class="tag">slab</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub/"><span class="tag">slub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub-debug/"><span class="tag">slub_debug</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/softlockup/"><span class="tag">softlockup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stack-overflow/"><span class="tag">stack_overflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-key/"><span class="tag">static_key</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sync/"><span class="tag">sync</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systemTap/"><span class="tag">systemTap</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systrace/"><span class="tag">systrace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-json/"><span class="tag">task.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-struct/"><span class="tag">task_struct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tasklet/"><span class="tag">tasklet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thread-info/"><span class="tag">thread_info</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tracepoint/"><span class="tag">tracepoint</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ubuntu/"><span class="tag">ubuntu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/use-after-free/"><span class="tag">use after free</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uts-namespace/"><span class="tag">uts namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/valgrind/"><span class="tag">valgrind</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vdso/"><span class="tag">vdso</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmstat/"><span class="tag">vmstat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmtouch/"><span class="tag">vmtouch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vscode/"><span class="tag">vscode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/x86/"><span class="tag">x86</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xattr/"><span class="tag">xattr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zone/"><span class="tag">zone</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%B6%8A%E7%95%8C/"><span class="tag">内存泄漏越界</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"><span class="tag">内存泄露</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内核内存泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C/"><span class="tag">内核内存越界</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"><span class="tag">内核同步</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0/"><span class="tag">内核抢占</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%A0%88%E6%BA%A2%E5%87%BA/"><span class="tag">内核栈溢出</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E7%AE%A1%E7%AE%A1%E7%90%86/"><span class="tag">内管管理</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"><span class="tag">函数调用</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E9%9A%8F%E6%9C%BA%E5%8C%96/"><span class="tag">地址空间布局随机化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/"><span class="tag">性能稳定性</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B3%84%E6%BC%8F/"><span class="tag">文件描述符泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><span class="tag">文件系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E9%A1%B9/"><span class="tag">杂项</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%88/"><span class="tag">栈</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/"><span class="tag">死锁检测</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="tag">生活感悟</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%A8%E6%88%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">用户内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A9%BA%E6%8C%87%E9%92%88/"><span class="tag">空指针</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F/"><span class="tag">虚拟地址空间泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F/"><span class="tag">资源泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%B8%AD%E6%96%AD/"><span class="tag">软中断</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"><span class="tag">进程调度</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/"><span class="tag">通用寄存器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81%E7%B2%92%E5%BA%A6/"><span class="tag">锁粒度</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E7%B3%BB%E7%BB%9F/"><span class="tag">问题系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/QCOM/"><span class="level-start"><span class="level-item">QCOM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/cgroup-v1/"><span class="level-start"><span class="level-item">cgroup v1</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/cgroup-v1/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/kernel-debug/"><span class="level-start"><span class="level-item">kernel debug</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/kernel-debug/cache-false-sharing/"><span class="level-start"><span class="level-item">cache false sharing</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/linux-kernel/"><span class="level-start"><span class="level-item">linux kernel</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/"><span class="level-start"><span class="level-item">linux schedule</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/deadline-schedule/"><span class="level-start"><span class="level-item">deadline schedule</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/"><span class="level-start"><span class="level-item">frequency governer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/schedule-util/"><span class="level-start"><span class="level-item">schedule util</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/idle/"><span class="level-start"><span class="level-item">idle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/linux%E5%86%85%E6%A0%B8/"><span class="level-start"><span class="level-item">linux内核</span></span><span class="level-end"><span class="level-item tag">68</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/"><span class="level-start"><span class="level-item">namespace</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/namespace/pid-namespace/"><span class="level-start"><span class="level-item">pid namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/uts-namespace/"><span class="level-start"><span class="level-item">uts namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/qemu/"><span class="level-start"><span class="level-item">qemu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/schedule/"><span class="level-start"><span class="level-item">schedule</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/server/"><span class="level-start"><span class="level-item">server</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/shell%E8%84%9A%E6%9C%AC/"><span class="level-start"><span class="level-item">shell脚本</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="level-start"><span class="level-item">生活感悟</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-24T11:00:00.000Z">2022-01-24</time></p><p class="title"><a href="/2022/01/24/schedule/cpu%E8%B0%83%E9%A2%91/">cpu调频</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-20T08:42:37.115Z">2022-01-20</time></p><p class="title"><a href="/2022/01/20/schedule/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-05T11:00:00.000Z">2022-01-05</time></p><p class="title"><a href="/2022/01/05/schedule/eas/">eas</a></p><p class="categories"><a href="/categories/linux-kernel/">linux kernel</a> / <a href="/categories/linux-kernel/linux-schedule/">linux schedule</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-03T11:00:00.000Z">2021-11-03</time></p><p class="title"><a href="/2021/11/03/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/perf%E7%9B%B8%E5%85%B3/perf%20c2c/">perf c2c</a></p><p class="categories"><a href="/categories/kernel-debug/">kernel debug</a> / <a href="/categories/kernel-debug/cache-false-sharing/">cache false sharing</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-23T11:00:00.000Z">2021-09-23</time></p><p class="title"><a href="/2021/09/23/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/android12%20gdb64%E8%B0%83%E8%AF%95%E8%BF%9B%E7%A8%8B/">android12 gdb64调试进程</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Su Hui</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>