<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>标签: schedule - liulangren Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="liulangren blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="liulangren blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="liulangren Blog"><meta property="og:url" content="https://liulangrenaaa.github.io/"><meta property="og:site_name" content="liulangren Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liulangrenaaa.github.io/img/og_image.png"><meta property="article:author" content="Su Hui"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liulangrenaaa.github.io"},"headline":"liulangren Blog","image":["https://liulangrenaaa.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Su Hui"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cabdc5b9b70bb83fa919a6ebeb439f93";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=PTKX6HMR55" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'PTKX6HMR55');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.1.1"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">schedule</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-15T11:00:00.000Z" title="6/15/2021, 7:00:00 PM">2021-06-15</time>发表</span><span class="level-item"><time dateTime="2021-06-15T08:20:49.884Z" title="6/15/2021, 4:20:49 PM">2021-06-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/idle/">idle</a></span><span class="level-item">3 分钟读完 (大约375个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/15/schedule/idle%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%B1%E6%9D%A5/">idle 进程的由来</a></h1><div class="content"><h2 id="idle-线程"><a href="#idle-线程" class="headerlink" title="idle 线程"></a>idle 线程</h2><p>linux 中给 per cpu都安排了一个结构<code>runqueue</code>，只要此 runqueue中有 runnable的thread,<br>scheduler 就不会进入 idle状态；相反，只要没有runnable的task，scheduler就会执行 <code>idle task</code>，使得cpu进入 idle模式。</p>
<h2 id="idle-线程如何产生的？"><a href="#idle-线程如何产生的？" class="headerlink" title="idle 线程如何产生的？"></a>idle 线程如何产生的？</h2><h3 id="单cpu-core架构中"><a href="#单cpu-core架构中" class="headerlink" title="单cpu core架构中"></a>单cpu core架构中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void cpu_startup_entry(enum cpuhp_state state)</span><br><span class="line">&#123;</span><br><span class="line">	arch_cpu_idle_prepare();</span><br><span class="line">	cpuhp_online_idle(state);</span><br><span class="line">	while (1)</span><br><span class="line">		do_idle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline void __ref rest_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">	cpu_startup_entry(CPUHP_ONLINE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __init __weak arch_call_rest_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	rest_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asmlinkage __visible void __init __no_sanitize_address start_kernel(void)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">      	arch_call_rest_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="smp架构中"><a href="#smp架构中" class="headerlink" title="smp架构中"></a>smp架构中</h3><p>smp 架构在boot的时候也是单cpu 先boot,然后结果smp_init()，将系统中其他cpu boot起来。<br>所以在 boot cpu中，idle线程还是通过 <code>rest_init()</code> 产生的。</p>
<p>非 <code>boot cpu</code> 的情况下，idle 线程是通过<code>idle_threads_init()</code> 产生的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static inline void idle_init(unsigned int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *tsk &#x3D; per_cpu(idle_threads, cpu);</span><br><span class="line"></span><br><span class="line">	if (!tsk) &#123;</span><br><span class="line">		tsk &#x3D; fork_idle(cpu);</span><br><span class="line">		if (IS_ERR(tsk))</span><br><span class="line">			pr_err(&quot;SMP: fork_idle() failed for CPU %u\n&quot;, cpu);</span><br><span class="line">		else</span><br><span class="line">			per_cpu(idle_threads, cpu) &#x3D; tsk;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * idle_threads_init - Initialize idle threads for all cpus</span><br><span class="line"> *&#x2F;</span><br><span class="line">void __init idle_threads_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int cpu, boot_cpu;</span><br><span class="line"></span><br><span class="line">	boot_cpu &#x3D; smp_processor_id();</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		if (cpu !&#x3D; boot_cpu)</span><br><span class="line">			idle_init(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Called by boot processor to activate the rest. *&#x2F;</span><br><span class="line">void __init smp_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">	idle_threads_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static noinline void __init kernel_init_freeable(void)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">	smp_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int __ref kernel_init(void *unused)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	kernel_init_freeable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline void __ref rest_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        ......</span><br><span class="line">	pid &#x3D; kernel_thread(kernel_init, NULL, CLONE_FS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rest_init<br>  – kernel_init<br>    – kernel_init_freeable<br>      – smp_init<br>        – idle_threads_init<br>          – idle_init</p>
<h2 id="idle-线程干了啥？"><a href="#idle-线程干了啥？" class="headerlink" title="idle 线程干了啥？"></a>idle 线程干了啥？</h2><p>后续熟悉 arm cpu指令再补充..</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-30T11:00:00.000Z" title="4/30/2021, 7:00:00 PM">2021-04-30</time>发表</span><span class="level-item"><time dateTime="2021-11-16T02:55:19.584Z" title="11/16/2021, 10:55:19 AM">2021-11-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/schedule/">schedule</a></span><span class="level-item">5 分钟读完 (大约729个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/30/schedule/HW/vip_thread/">vip_thread</a></h1><div class="content"><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在手机场景中，总有些进程对用户体验是相对其他进程来说高很多的，比如UI线程等，一旦调度不及时，就会给用户造成手机很卡的感觉，所以我们必须识别处这样的vip进程，然后给予更高的待遇，这是几种可行方案：</p>
<ul>
<li>识别出 vip thread，然后来设置为 rt调度策略</li>
<li>识别出 vip thread, 动态给予很小的nice值，使得运行更多</li>
<li>识别出 vip thread, 修改 vruntime 的值，使得运行更多</li>
<li>识别出 vip thread, 给 cfs 中也添加 类似 rt的硬优先级</li>
</ul>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>识别出 vip thread，然后来设置为 rt调度策略<br>优点：可以快速得到运行<br>缺点：可能会抢占系统中本身的rt进程；但是rt的 thread可以抢占，会导致后面加入的进程反而会强占之前的进程</p>
<h3 id="方案二和三"><a href="#方案二和三" class="headerlink" title="方案二和三"></a>方案二和三</h3><p>识别出 vip thread, 动态给予很小的nice值 or 修改 vruntime的值，使得运行更多<br>优点：可以使得vip thread 运行的更久一点<br>缺点：但是可能延迟较大，不能立刻投入运行</p>
<h3 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h3><p>识别出 vip thread, 给 cfs 中也添加 类似 rt的硬优先级<br>优点：相对于方案一来说，不会抢占系统中原油的 rt 进程；相对于方案二来说，实时性会大大提高<br>缺点：需要自己扩展 cfs调度类</p>
<h2 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h2><p>vip_thread 方案主要分为 <code>识别vip_thread</code> <code>vip_thread 数据结构怎么组织</code> <code>vip_thread怎么调度</code> <code>vip_thread 对资源的依赖</code></p>
<h3 id="识别-vip-thread"><a href="#识别-vip-thread" class="headerlink" title="识别 vip_thread"></a>识别 vip_thread</h3><p>如何识别 <code>vip_thread</code> 是一切的开始，vip_thread 定义是和用户体验及其相关的进程，主要是UI线程，<code>kernel</code> 自身很难感知到，但是 <code>framework</code>层是可以感知到的，直接提供<code>proc</code> 节点出去给framework 来帮助识别 vip_thread</p>
<h3 id="vip-thread-数据结构怎么组织"><a href="#vip-thread-数据结构怎么组织" class="headerlink" title="vip_thread 数据结构怎么组织"></a>vip_thread 数据结构怎么组织</h3><p>被识别成为<code>vip_thread</code> 的进程主要是 ui进程，在安卓中的调度策略都是cfs，所以将 <code>vip_thread</code> 的相关数据结构添加到 <code>cfs_rq</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_HW_VIP_THREAD</span><br><span class="line">	&#x2F;*task list for vip thread*&#x2F;</span><br><span class="line">	struct list_head vip_thread_list;</span><br><span class="line">	int active_vip_balance;</span><br><span class="line">	struct cpu_stop_work vip_balance_work;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>当前为了实现简单，将 vip_thread 以 链表数据结构链接到 <code>vip_thread_list</code> 中，<br><code>active_vip_balance</code> 表明此 rq 是否正在做 vip_thread 的 <code>load_balance</code>，<br><code>vip_balance_work</code> 是 load_balance 的 work结构。</p>
<p>还需要在 <code>struct task_struct</code> 中添加如下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_HW_VIP_THREAD</span><br><span class="line">	int static_vip;</span><br><span class="line">	int vip_depth;</span><br><span class="line">	atomic64_t dynamic_vip;</span><br><span class="line">	struct list_head vip_entry;</span><br><span class="line">	u64 enqueue_time;</span><br><span class="line">	u64 dynamic_vip_start;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>




<h3 id="vip-thread-怎么调度"><a href="#vip-thread-怎么调度" class="headerlink" title="vip_thread 怎么调度"></a>vip_thread 怎么调度</h3><p>参考<a target="_blank" rel="noopener" href="https://consumer.huawei.com/en/opensource/detail/?siteCode=worldwidw?productCode=Smartphones&fileType=openSourceSoftware&pageSize=10">HW_P50_888_Code</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-21T11:00:00.000Z" title="4/21/2021, 7:00:00 PM">2021-04-21</time>发表</span><span class="level-item"><time dateTime="2021-04-21T06:12:55.960Z" title="4/21/2021, 2:12:55 PM">2021-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">10 分钟读完 (大约1461个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/21/schedule/ipi_sched/">ipi_sched</a></h1><div class="content"><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><p>IPI 中断 (Inter-Processor Interrupts) ，核间中断可以通过向这个寄存器写入需要的值来产生。若硬件线程 A 想要发送一个核间中断给硬件线程 B，它只需要向寄存器 IPIBase 中写入 B<br>的 Thread ID、中断向量、中断类型等值就可以了，PIC 会通知 B 所在的核挂起它当前的执行序列，并根据中断向量跳转到中断服务例程 ISR 的入口</p>
<h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW?"></a>HOW?</h2><p>linux上将 IPI 中断分为以下几类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum ipi_msg_type &#123;</span><br><span class="line">	IPI_RESCHEDULE,</span><br><span class="line">	IPI_CALL_FUNC,</span><br><span class="line">	IPI_CPU_STOP,</span><br><span class="line">	IPI_CPU_CRASH_STOP,</span><br><span class="line">	IPI_TIMER,</span><br><span class="line">	IPI_IRQ_WORK,</span><br><span class="line">	IPI_WAKEUP</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>通过接口 <code>smp_cross_call</code> 调用，For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void smp_send_reschedule(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	smp_cross_call(cpumask_of(cpu), IPI_RESCHEDULE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>CPUa 给 CPUb 发送一个 <code>IPI_RESCHEDULE</code> 信号，然后 CPUb执行相关函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Main handler for inter-processor interrupts</span><br><span class="line"> *&#x2F;</span><br><span class="line">void handle_IPI(int ipinr, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int cpu &#x3D; smp_processor_id();</span><br><span class="line">	struct pt_regs *old_regs &#x3D; set_irq_regs(regs);</span><br><span class="line"></span><br><span class="line">	switch (ipinr) &#123;</span><br><span class="line">	case IPI_RESCHEDULE:</span><br><span class="line">		scheduler_ipi();</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	case IPI_CALL_FUNC:</span><br><span class="line">		irq_enter();</span><br><span class="line">		generic_smp_call_function_interrupt();</span><br><span class="line">		irq_exit();</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">	set_irq_regs(old_regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="scheduler-ipi-主要工作？"><a href="#scheduler-ipi-主要工作？" class="headerlink" title="scheduler_ipi 主要工作？"></a>scheduler_ipi 主要工作？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void scheduler_ipi(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Fold TIF_NEED_RESCHED into the preempt_count; anybody setting</span><br><span class="line">	 * TIF_NEED_RESCHED remotely (for the first time) will also send</span><br><span class="line">	 * this IPI.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	preempt_fold_need_resched();</span><br><span class="line"></span><br><span class="line">	if (llist_empty(&amp;this_rq()-&gt;wake_list) &amp;&amp; !got_nohz_idle_kick())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Not all reschedule IPI handlers call irq_enter&#x2F;irq_exit, since</span><br><span class="line">	 * traditionally all their work was done from the interrupt return</span><br><span class="line">	 * path. Now that we actually do some work, we need to make sure</span><br><span class="line">	 * we do call them.</span><br><span class="line">	 *</span><br><span class="line">	 * Some archs already do call them, luckily irq_enter&#x2F;exit nest</span><br><span class="line">	 * properly.</span><br><span class="line">	 *</span><br><span class="line">	 * Arguably we should visit all archs and update all handlers,</span><br><span class="line">	 * however a fair share of IPIs are still resched only so this would</span><br><span class="line">	 * somewhat pessimize the simple resched case.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	irq_enter();</span><br><span class="line">	sched_ttwu_pending();</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Check if someone kicked us for doing the nohz idle load balance.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (unlikely(got_nohz_idle_kick())) &#123;</span><br><span class="line">		this_rq()-&gt;idle_balance &#x3D; 1;</span><br><span class="line">		raise_softirq_irqoff(SCHED_SOFTIRQ);</span><br><span class="line">	&#125;</span><br><span class="line">	irq_exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>llist_empty(&amp;this_rq()-&gt;wake_list)</code> 成立，意味着rq上没有需要wake_up的thread，且同时 <code>!got_nohz_idle_kick()</code>也成立的话，就直接返回了，这个 IPI就是无效的。</p>
<p>正常都会继续往下继续走，重点是 <code>sched_ttwu_pending</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void sched_ttwu_pending(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; this_rq();</span><br><span class="line">	struct llist_node *llist &#x3D; llist_del_all(&amp;rq-&gt;wake_list);</span><br><span class="line">	struct task_struct *p, *t;</span><br><span class="line">	struct rq_flags rf;</span><br><span class="line"></span><br><span class="line">	if (!llist)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">        &#x2F;&#x2F; 一次性唤醒所有 &#96;wake_list&#96; 上的task。</span><br><span class="line">	llist_for_each_entry_safe(p, t, llist, wake_entry)</span><br><span class="line">		ttwu_do_activate(rq, p, p-&gt;sched_remote_wakeup ? WF_MIGRATED : 0, &amp;rf);</span><br><span class="line"></span><br><span class="line">	rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后查看是否需要做 <code>load_balance</code></p>
<h2 id="什么情况下会发送-IPI-RESCHEDULE？"><a href="#什么情况下会发送-IPI-RESCHEDULE？" class="headerlink" title="什么情况下会发送 IPI_RESCHEDULE？"></a>什么情况下会发送 IPI_RESCHEDULE？</h2><ol>
<li>resched_curr()<br>如果cpu == smp_processor_id()，(这里分为俩种情况，1. UP架构只有一个CPU 2. SMP架构上恰好resched_curr()的是本cpu)<br>那仅仅是设置 当前 curr的thread_info的 need_resched标志位。<br>如果是需要其他cpu执行 resched_curr()，就需要 <code>smp_send_reschedule(cpu)</code> 来发送 <code>IPI_RESCHEDULE</code>了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * resched_curr - mark rq&#39;s current task &#39;to be rescheduled now&#39;.</span><br><span class="line"> *</span><br><span class="line"> * On UP this means the setting of the need_resched flag, on SMP it</span><br><span class="line"> * might also involve a cross-CPU call to trigger the scheduler on</span><br><span class="line"> * the target CPU.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void resched_curr(struct rq *rq)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *curr &#x3D; rq-&gt;curr;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;rq-&gt;lock);</span><br><span class="line"></span><br><span class="line">	if (test_tsk_need_resched(curr))</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	cpu &#x3D; cpu_of(rq);</span><br><span class="line"></span><br><span class="line">	if (cpu &#x3D;&#x3D; smp_processor_id()) &#123;</span><br><span class="line">		set_tsk_need_resched(curr);</span><br><span class="line">		set_preempt_need_resched();</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (set_nr_and_not_polling(curr))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	else</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li>wake_up_idle_cpu()</li>
</ol>
<p>在唤醒一个 idle的cpu时，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void wake_up_idle_cpu(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	if (cpu &#x3D;&#x3D; smp_processor_id())</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	if (set_nr_and_not_polling(rq-&gt;idle))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	else</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>kick_process()</li>
</ol>
<p>让一个 task立刻进入 kernel mode（without any delay），从而来处理 signal信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***</span><br><span class="line"> * kick_process - kick a running thread to enter&#x2F;exit the kernel</span><br><span class="line"> * @p: the to-be-kicked thread</span><br><span class="line"> *</span><br><span class="line"> * Cause a process which is running on another CPU to enter</span><br><span class="line"> * kernel-mode, without any delay. (to get signals handled.)</span><br><span class="line"> *</span><br><span class="line"> * NOTE: this function doesn&#39;t have to take the runqueue lock,</span><br><span class="line"> * because all it wants to ensure is that the remote task enters</span><br><span class="line"> * the kernel. If the IPI races and the task has been migrated</span><br><span class="line"> * to another CPU then no harm is done and the purpose has been</span><br><span class="line"> * achieved as well.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void kick_process(struct task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	cpu &#x3D; task_cpu(p);</span><br><span class="line">	if ((cpu !&#x3D; smp_processor_id()) &amp;&amp; task_curr(p))</span><br><span class="line">		smp_send_reschedule(cpu);</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(kick_process);</span><br><span class="line"></span><br><span class="line">void signal_wake_up_state(struct task_struct *t, unsigned int state)</span><br><span class="line">&#123;</span><br><span class="line">	set_tsk_thread_flag(t, TIF_SIGPENDING);</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * TASK_WAKEKILL also means wake it up in the stopped&#x2F;traced&#x2F;killable</span><br><span class="line">	 * case. We don&#39;t check t-&gt;state here because there is a race with it</span><br><span class="line">	 * executing another processor and just now entering stopped state.</span><br><span class="line">	 * By using wake_up_state, we ensure the process will wake up and</span><br><span class="line">	 * handle its death signal.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (!wake_up_state(t, state | TASK_INTERRUPTIBLE))</span><br><span class="line">		kick_process(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>ttwu_queue_remote()</li>
</ol>
<p>try_to_wake_up() 一个thread之后，需要将 这个task入队<br>a. 如果是 task不是在 <code>本cpu</code> 唤醒的，那就需要IPI中断<code>smp_send_reschedule</code>来搞了<br>b. 如果是在 <code>本地cpu</code> 唤醒的，就直接 lock_rq() 之后进行 <code>ttwu_do_activate</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static void ttwu_queue_remote(struct task_struct *p, int cpu, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line"></span><br><span class="line">	p-&gt;sched_remote_wakeup &#x3D; !!(wake_flags &amp; WF_MIGRATED);</span><br><span class="line"></span><br><span class="line">	if (llist_add(&amp;p-&gt;wake_entry, &amp;cpu_rq(cpu)-&gt;wake_list)) &#123;</span><br><span class="line">		if (!set_nr_if_polling(rq-&gt;idle))</span><br><span class="line">			smp_send_reschedule(cpu);</span><br><span class="line">		else</span><br><span class="line">			trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void ttwu_queue(struct task_struct *p, int cpu, int wake_flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line">	struct rq_flags rf;</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_SMP)</span><br><span class="line">	if (sched_feat(TTWU_QUEUE) &amp;&amp; !cpus_share_cache(smp_processor_id(), cpu)) &#123;</span><br><span class="line">		sched_clock_cpu(cpu); &#x2F;* Sync clocks across CPUs *&#x2F;</span><br><span class="line">		ttwu_queue_remote(p, cpu, wake_flags);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	update_rq_clock(rq);</span><br><span class="line">	ttwu_do_activate(rq, p, wake_flags, &amp;rf);</span><br><span class="line">	rq_unlock(rq, &amp;rf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>wake_up_if_idle()<br><code>wake_up_if_idle()</code> 只有在 <code>wake_up_all_idle_cpus()</code> 中被调用，主要是看此 cpu 是否idle空闲，就是看他 <code>is_idle_task(cpu_rq(cpu)-&gt;curr)</code> 是否成立，成立的话就需要 IPI中断去唤醒。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void wake_up_if_idle(int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	struct rq *rq &#x3D; cpu_rq(cpu);</span><br><span class="line">	struct rq_flags rf;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line"></span><br><span class="line">	if (!is_idle_task(rcu_dereference(rq-&gt;curr)))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	if (set_nr_if_polling(rq-&gt;idle)) &#123;</span><br><span class="line">		trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		rq_lock_irqsave(rq, &amp;rf);</span><br><span class="line">		if (is_idle_task(rq-&gt;curr))</span><br><span class="line">			smp_send_reschedule(cpu);</span><br><span class="line">		&#x2F;* Else CPU is not idle, do nothing here: *&#x2F;</span><br><span class="line">		rq_unlock_irqrestore(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void wake_up_all_idle_cpus(void)</span><br><span class="line">&#123;</span><br><span class="line">	int cpu;</span><br><span class="line"></span><br><span class="line">	preempt_disable();</span><br><span class="line">	for_each_online_cpu(cpu) &#123;</span><br><span class="line">		if (cpu &#x3D;&#x3D; smp_processor_id())</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		wake_up_if_idle(cpu);</span><br><span class="line">	&#125;</span><br><span class="line">	preempt_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>參考linux-5.4.61代码</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-15T11:00:00.000Z" title="4/15/2021, 7:00:00 PM">2021-04-15</time>发表</span><span class="level-item"><time dateTime="2021-04-15T02:37:17.900Z" title="4/15/2021, 10:37:17 AM">2021-04-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/frequency-governer/">frequency governer</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/frequency-governer/schedule-util/">schedule util</a></span><span class="level-item">几秒读完 (大约12个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/15/schedule/freq%20governer/">freq governer</a></h1><div class="content"><p>参考<a href="Documentation/admin-guide/pm/cpufreq.rst">内核文档</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-12T11:00:00.000Z" title="4/12/2021, 7:00:00 PM">2021-04-12</time>发表</span><span class="level-item"><time dateTime="2021-04-02T09:36:11.503Z" title="4/2/2021, 5:36:11 PM">2021-04-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">6 分钟读完 (大约844个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/12/schedule/sched%20concepts/">sched concepts</a></h1><div class="content"><h2 id="EAS"><a href="#EAS" class="headerlink" title="EAS"></a>EAS</h2><p>what?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This patch series introduces Energy Aware Scheduling (EAS) for CFS tasks</span><br><span class="line">on platforms with asymmetric CPU topologies (e.g. Arm big.LITTLE).</span><br></pre></td></tr></table></figure>
<p>参考 <a target="_blank" rel="noopener" href="https://lore.kernel.org/lkml/20181016101513.26919-1-quentin.perret@arm.com/">lkml EAS cover letter</a><br>参考 <a target="_blank" rel="noopener" href="https://marc.info/?l=linux-kernel&m=153243513908731&w=2">lkml EAS overall design V5</a></p>
<h2 id="misfit"><a href="#misfit" class="headerlink" title="misfit"></a>misfit</h2><p>应该是指 task运行位置不合适：<br>运行 此 task需要的算力 比 当前 CPU or rq的最大算力还要高，实际代码里面使用的是<br>task需求算力  &lt;  （CPU 最大算力 * 1.2）？</p>
<p>task需求算力如何计算：<br>uclamp_task_util(p)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * The margin used when comparing utilization with CPU capacity.</span><br><span class="line"> *</span><br><span class="line"> * (default: ~20%)</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define fits_capacity(cap, max)	((cap) * 1280 &lt; (max) * 1024)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static inline int task_fits_capacity(struct task_struct *p, long capacity)</span><br><span class="line">&#123;</span><br><span class="line">	return fits_capacity(uclamp_task_util(p), capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if (task_fits_capacity(p, capacity_of(cpu_of(rq)))) &#123;</span><br><span class="line">		rq-&gt;misfit_task_load &#x3D; 0;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>




<h2 id="utilization-clamping"><a href="#utilization-clamping" class="headerlink" title="utilization clamping"></a>utilization clamping</h2><p>The main use-cases for utilization clamping are:</p>
<ul>
<li><p>boosting: better interactive response for small tasks which<br>are affecting the user experience.</p>
<p>Consider for example the case of a small control thread for an external<br>accelerator (e.g. GPU, DSP, other devices). Here, from the task utilization<br>the scheduler does not have a complete view of what the task’s requirements<br>are and, if it’s a small utilization task, it keeps selecting a more energy<br>efficient CPU, with smaller capacity and lower frequency, thus negatively<br>impacting the overall time required to complete task activations.</p>
</li>
<li><p>capping: increase energy efficiency for background tasks not affecting the<br>user experience.</p>
<p>Since running on a lower capacity CPU at a lower frequency is more energy<br>efficient, when the completion time is not a main goal, then capping the<br>utilization considered for certain (maybe big) tasks can have positive<br>effects, both on energy consumption and thermal headroom.<br>This feature allows also to make RT tasks more energy friendly on mobile<br>systems where running them on high capacity CPUs and at the maximum<br>frequency is not required.</p>
</li>
</ul>
<p>参考 <a target="_blank" rel="noopener" href="https://lwn.net/Articles/791682/">LWN 文章-Add utilization clamping support</a></p>
<h2 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h2><p>WHY?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dedicating a CPU to a specific performance-critical process&#x2F;task is desired.</span><br></pre></td></tr></table></figure>
<p>需要将某些CPU 专用于 特定的性能关键的进程/任务。</p>
<p>HOW?<br>需要在boot的时候设置启动参数。<br>四核SMP系统上，加入需要 isolate CPU 0,1,2,3 中的 CPU2 与 CPU3，可以配置 kernel的启动参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isolcpus&#x3D;2,3</span><br></pre></td></tr></table></figure>

<p>完整启动参数是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   sudo qemu-system-x86_64 \</span><br><span class="line">-kernel &#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share&#x2F;stable&#x2F;bzImage \</span><br><span class="line">-hda &#x2F;home&#x2F;ubuntu&#x2F;myspace&#x2F;qemu_build&#x2F;stable_ubuntu.img \</span><br><span class="line">-append &quot;root&#x3D;&#x2F;dev&#x2F;sda5 console&#x3D;ttyS0 crashkernel&#x3D;256M isolcpus&#x3D;2,3&quot; \</span><br><span class="line">-smp 4 \</span><br><span class="line">-m 4096 \</span><br><span class="line">--enable-kvm \</span><br><span class="line">-net nic \</span><br><span class="line">-net user,hostfwd&#x3D;tcp::2222-:22 \</span><br><span class="line">--nographic \</span><br><span class="line">-fsdev local,id&#x3D;fs1,path&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;share,security_model&#x3D;none \</span><br><span class="line">-device virtio-9p-pci,fsdev&#x3D;fs1,mount_tag&#x3D;host_share</span><br></pre></td></tr></table></figure>

<p>一旦系统用这个参数启动，进程/任务将不会被分配给或从指定的CPU，除非通过taskset或cset命令分配进程到 isolate的CPU。<br>在Linux上，可以使用taskset命令设置进程的CPU亲和度，使用cset命令设置进程的CPU亲和度。</p>
<p>可以使用 taskset 设置task的 cpu 亲和性<br>查看某个进程的亲和性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@wsl:~&#x2F;workspace&#x2F;linux-stable $ ps -aux | grep sleep</span><br><span class="line">ubuntu    4445  0.0  0.0  15276   824 tty2     S    11:19   0:00 sleep 1000</span><br><span class="line">ubuntu    4448  0.0  0.0  16208  1284 pts&#x2F;0    S    11:19   0:00 grep --color&#x3D;auto sleep</span><br><span class="line">ubuntu@wsl:~&#x2F;workspace&#x2F;linux-stable $ taskset -c -p 4445</span><br><span class="line">pid 4445&#39;s current affinity list: 0-11</span><br></pre></td></tr></table></figure>

<p>设置某个进程的亲和性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@wsl:~&#x2F;workspace&#x2F;linux-stable $ taskset -cp 1 4445</span><br><span class="line">pid 4445&#39;s current affinity list: 0-11</span><br><span class="line">pid 4445&#39;s new affinity list: 1</span><br><span class="line">ubuntu@wsl:~&#x2F;workspace&#x2F;linux-stable $ taskset -c -p 4445</span><br><span class="line">pid 4445&#39;s current affinity list: 1</span><br><span class="line">ubuntu@wsl:~&#x2F;workspace&#x2F;linux-stable $</span><br></pre></td></tr></table></figure>

<p>在server上实际测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试环境：0-3共有四核 CPU，启动时 isolate出2-3俩核心。</span><br><span class="line">1. 开机之后，0-1核 有正常task在跑，2-3核无任何 task。（此时task的 allow_cpumask都是 0-1）</span><br><span class="line">2. userspace &amp; kernelspace 的 cfs可以正常绑定到2-3核心，且可以正常跑</span><br><span class="line">3. userspace 与 kernelspace 的rt 进程均可绑定到2-3核心，且可以正常跑</span><br><span class="line">4. usespace 的 cfs绑定到0-3核心，可以跑到2-3核心上。</span><br></pre></td></tr></table></figure>
<p>参考 <a target="_blank" rel="noopener" href="https://www.suse.com/support/kb/doc/?id=000017747">Suse 的官方文档</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-12T11:00:00.000Z" title="4/12/2021, 7:00:00 PM">2021-04-12</time>发表</span><span class="level-item"><time dateTime="2021-04-13T07:07:27.891Z" title="4/13/2021, 3:07:27 PM">2021-04-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/deadline-schedule/">deadline schedule</a></span><span class="level-item">6 分钟读完 (大约948个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/12/schedule/%E7%BF%BB%E8%AF%91/Capacity%20awareness%20for%20the%20deadline%20scheduler/">Capacity awareness for the deadline scheduler</a></h1><div class="content"><h2 id="What-is-CPU-Capacity"><a href="#What-is-CPU-Capacity" class="headerlink" title="What is CPU Capacity?"></a>What is CPU Capacity?</h2><h2 id="What-is-Capacity-awareness"><a href="#What-is-Capacity-awareness" class="headerlink" title="What is Capacity awareness"></a>What is Capacity awareness</h2><p>Capacity Awareness refers to the fact that on heterogeneous systems<br>(like Arm big.LITTLE), the capacity of the CPUs is not uniform, hence<br>when placing tasks we need to be aware of this difference of CPU<br>capacities.<br>容量意识是指在异构系统上（例如Arm big.LITTLE），CPU的容量不一致，因此<br>在放置任务时，我们需要意识到CPU的这种差异能力。</p>
<h2 id="RT-scheduler-遇到的问题"><a href="#RT-scheduler-遇到的问题" class="headerlink" title="RT scheduler 遇到的问题"></a>RT scheduler 遇到的问题</h2><p>参考<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=804d402fb6f6">sched/rt: Make RT capacity-aware</a></p>
<p>在ARM big.LITTLE情况下，我们要确保所选的CPU有足够的Capacity，满足运行任务运行的要求，可以理解为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capacity_orig_of（cpu）&gt; &#x3D; task.requirement。</span><br></pre></td></tr></table></figure>
<ol>
<li><p>对于CFS来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capacity_orig_of(cpu) &gt;&#x3D; cfs_task.util</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于 deadline来说：(虽然还没有这个机制，但是可以使用bandwidth<br>reservation实现)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capacity_orig_of(cpu)&#x2F;SCHED_CAPACITY &gt;&#x3D; dl_deadline&#x2F;dl_runtime</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于RT，我们没有跟踪Per-task的CPU利用率，并且我们没有任何需求 去跟踪 RT-task对性能的要求。 但是随着uclamp的引入，RT任务现在可以控制通过设置uclamp_min来保证最低性能点。</p>
</li>
</ol>
<h2 id="Deadline-scheduler-遇到的问题"><a href="#Deadline-scheduler-遇到的问题" class="headerlink" title="Deadline scheduler 遇到的问题"></a>Deadline scheduler 遇到的问题</h2><p>参考<a target="_blank" rel="noopener" href="https://lwn.net/Articles/821578/">LWN文章</a><br>linux deadline scheduler 将cpu分配给deadline 调度类的task，确保每个task不会逾期，这在SMP系统上很容易办到，但是在arm的 big.LITTLE系统中这变得很复杂，因为一个task假设在big core上需要运行50ms，在LITTLE core上可能需要运行100ms。在scheduler 不能感知到这些 big.LITTLE core的算力差异的时候，deadline的选核操作就有很大问题，会导致一些task被调度到小核上去，task由于小核算力不足导致最后逾期。</p>
<p>deadline schedule中缺少的信息是对CPU容量（CPU Capacity）的了解-在给定时间内可以执行的指令数。CPU capacity已经在 load balancing和其他场景中使用了。</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. [Telling the scheduler about thermal pressure](https:&#x2F;&#x2F;lwn.net&#x2F;Articles&#x2F;788380&#x2F;)</span><br><span class="line"></span><br><span class="line">2. [CPU capacity Usage in rt scheduler](https:&#x2F;&#x2F;git.kernel.org&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git&#x2F;commit&#x2F;?id&#x3D;804d402fb6f6)</span><br></pre></td></tr></table></figure>

<p>Eggemann’s的工作主要是让 task placement 算法 考虑了不通CPU的 Capacity的差异，加上他的patch之后，deadline scheduler不管是选择到了big core还是 LITTLE core，都会满足 task的算力要求。</p>
<h2 id="具体改了啥？"><a href="#具体改了啥？" class="headerlink" title="具体改了啥？"></a>具体改了啥？</h2><p>admission-control 主要是基于系统中CPU总算力决定的。</p>
<ol>
<li>在SMP系统中，单个CPU 容量是c, 系统中有x个cpu，系统总算力C = x * c。</li>
<li>AMP系统中，x个big core，单个容量是c1，y个LITTLE core，单个容量是c2，系统总算力C = x * c1 + y * c2。</li>
</ol>
<p>deadline scheduler的task-placement 还必须更好地了解系统的CPU拓扑。 在将任务移至新CPU之前，调度程序需要确保新CPU可以处理该任务。 在AMP中，需要有新的方法检查从一个cpu a迁移出的task到 cpu b，b的CPU Capacity满足task的要求，使用以下公式执行 fitness check：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(CPU capacity) &#x2F; 1024 &gt;&#x3D; (task runtime) &#x2F; (task deadline)</span><br><span class="line">                    |</span><br><span class="line"></span><br><span class="line">cap            &gt;&gt; 10  &gt;&#x3D; (p-&gt;dl.dl_runtime) &#x2F; (p-&gt;dl.dl_deadline)</span><br><span class="line">                    |</span><br><span class="line"></span><br><span class="line">(cap &gt;&gt; 10) * p-&gt;dl.dl_deadline  &gt;&#x3D;  p-&gt;dl.dl_runtime</span><br><span class="line">                    |</span><br><span class="line"></span><br><span class="line">(cap * p-&gt;dl.dl_deadline)  &gt;&gt; 10  &gt;&#x3D;  p-&gt;dl.dl_runtime</span><br><span class="line">                    |</span><br><span class="line"></span><br><span class="line">cap_scale(p-&gt;dl.dl_deadline, cap) &gt;&#x3D; p-&gt;dl.dl_runtime;</span><br></pre></td></tr></table></figure>

<p>对应<code>kernel/sched/sched.h</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define cap_scale(v, s) ((v)*(s) &gt;&gt; SCHED_CAPACITY_SHIFT)</span><br><span class="line"></span><br><span class="line">static inline bool dl_task_fits_capacity(struct task_struct *p, int cpu)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long cap &#x3D; arch_scale_cpu_capacity(cpu);</span><br><span class="line"></span><br><span class="line">	return cap_scale(p-&gt;dl.dl_deadline, cap) &gt;&#x3D; p-&gt;dl.dl_runtime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="这个改动会影响啥"><a href="#这个改动会影响啥" class="headerlink" title="这个改动会影响啥"></a>这个改动会影响啥</h2><ol>
<li>waking up a deadline task</li>
<li>moving a deadline task to a different CPU</li>
<li>migrating a task out of a CPU that is going offline</li>
</ol>
<p>都会检查 target cpu的 Capacity 是否满足task 的deadline条件。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-12T11:00:00.000Z" title="4/12/2021, 7:00:00 PM">2021-04-12</time>发表</span><span class="level-item"><time dateTime="2021-04-21T08:09:37.140Z" title="4/21/2021, 4:09:37 PM">2021-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/linux-kernel/">linux kernel</a><span> / </span><a class="link-muted" href="/categories/linux-kernel/linux-schedule/">linux schedule</a></span><span class="level-item">6 分钟读完 (大约886个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/12/schedule/sched_domain%20and%20root_domain/">sched_domain and root_domain</a></h1><div class="content"><h2 id="root-domain"><a href="#root-domain" class="headerlink" title="root_domain"></a>root_domain</h2><p><code>root_domain</code> 相对于 <code>sched_domain</code> 来说简单很多， 这是描述一个cpu集合的 数据结构。<br>每个 <code>cpuset</code> 都会拥有一个 <code>root_domain</code>，无论何时何地 <code>cpuset</code>被创建，同时会创建 并 attach 一个 root_domain结构。<br>一个  <code>root_domain</code> 可能包含多个cpu，且这些cpu的能效不一定是一致的，所以内嵌了<code>perf_domain</code> 结构来描述这种差异。</p>
<p><code>perf_domain</code> 的<code>next</code> 指针 就这样将这个<code>root_domain</code> 中的<code>perf_domain</code> 连接起来了。<br>具有同一能效模型的俩cpu(在同一cluster上)，共享一个 <code>em_perf_domain</code> 能效模型结构，但是 <code>perf_domain</code>可能是分开的，因为这俩cpu可能是属于不同<code>root_domain</code>的。</p>
<p>参考 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/scheduler/sched-energy.html">kernel 文档</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">The lists are attached to the root domains in order to cope with exclusive cpuset configurations. Since the boundaries of exclusive cpusets do not necessarily match those of performance domains, the lists of different root domains can contain duplicate elements.</span><br><span class="line"></span><br><span class="line">Example 1.</span><br><span class="line">Let us consider a platform with 12 CPUs, split in 3 performance domains (pd0, pd4 and pd8), organized as follows:</span><br><span class="line"></span><br><span class="line">CPUs:   0 1 2 3 4 5 6 7 8 9 10 11</span><br><span class="line">PDs:   |--pd0--|--pd4--|---pd8---|</span><br><span class="line">RDs:   |----rd1----|-----rd2-----|</span><br><span class="line">Now, consider that userspace decided to split the system with two exclusive cpusets, hence creating two independent root domains, each containing 6 CPUs. The two root domains are denoted rd1 and rd2 in the above figure. Since pd4 intersects with both rd1 and rd2, it will be present in the linked list ‘-&gt;pd’ attached to each of them:</span><br><span class="line">rd1-&gt;pd: pd0 -&gt; pd4</span><br><span class="line">rd2-&gt;pd: pd4 -&gt; pd8</span><br><span class="line"></span><br><span class="line">Please note that the scheduler will create two duplicate list nodes for pd4 (one for each list). However, both just hold a pointer to the same shared data structure of the EM framework.</span><br><span class="line"></span><br><span class="line">Since the access to these lists can happen concurrently with hotplug and other things, they are protected by RCU, like the rest of topology structures manipulated by the scheduler.</span><br><span class="line"></span><br><span class="line">EAS also maintains a static key (sched_energy_present) which is enabled when at least one root domain meets all conditions for EAS to start. Those conditions are summarized in Section 6.</span><br></pre></td></tr></table></figure>

<p>这是 <code>root_domain</code> 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">struct perf_domain &#123;</span><br><span class="line">	struct em_perf_domain *em_pd;</span><br><span class="line">	struct perf_domain *next;</span><br><span class="line">	struct rcu_head rcu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * We add the notion of a root-domain which will be used to define per-domain</span><br><span class="line"> * variables. Each exclusive cpuset essentially defines an island domain by</span><br><span class="line"> * fully partitioning the member CPUs from any other cpuset. Whenever a new</span><br><span class="line"> * exclusive cpuset is created, we also create and attach a new root-domain</span><br><span class="line"> * object.</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct root_domain &#123;</span><br><span class="line">	atomic_t		refcount;</span><br><span class="line">	atomic_t		rto_count;</span><br><span class="line">	struct rcu_head		rcu;</span><br><span class="line">	cpumask_var_t		span;</span><br><span class="line">	cpumask_var_t		online;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Indicate pullable load on at least one CPU, e.g:</span><br><span class="line">	 * - More than one runnable task</span><br><span class="line">	 * - Running task is misfit</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	int			overload;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Indicate one or more cpus over-utilized (tipping point) *&#x2F;</span><br><span class="line">	int			overutilized;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The bit corresponding to a CPU gets set here if such CPU has more</span><br><span class="line">	 * than one runnable -deadline task (as it is below for RT tasks).</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	cpumask_var_t		dlo_mask;</span><br><span class="line">	atomic_t		dlo_count;</span><br><span class="line">	struct dl_bw		dl_bw;</span><br><span class="line">	struct cpudl		cpudl;</span><br><span class="line"></span><br><span class="line">#ifdef HAVE_RT_PUSH_IPI</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * For IPI pull requests, loop across the rto_mask.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct irq_work		rto_push_work;</span><br><span class="line">	raw_spinlock_t		rto_lock;</span><br><span class="line">	&#x2F;* These are only updated and read within rto_lock *&#x2F;</span><br><span class="line">	int			rto_loop;</span><br><span class="line">	int			rto_cpu;</span><br><span class="line">	&#x2F;* These atomics are updated outside of a lock *&#x2F;</span><br><span class="line">	atomic_t		rto_loop_next;</span><br><span class="line">	atomic_t		rto_loop_start;</span><br><span class="line">#endif</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The &quot;RT overload&quot; flag: it gets set if a CPU has more than</span><br><span class="line">	 * one runnable RT task.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	cpumask_var_t		rto_mask;</span><br><span class="line">	struct cpupri		cpupri;</span><br><span class="line"></span><br><span class="line">	unsigned long		max_cpu_capacity;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * NULL-terminated list of performance domains intersecting with the</span><br><span class="line">	 * CPUs of the rd. Protected by RCU.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	struct perf_domain __rcu *pd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="sched-domain-WHAT"><a href="#sched-domain-WHAT" class="headerlink" title="sched domain: WHAT?"></a>sched domain: WHAT?</h2><h2 id="sched-domain-如何标识？"><a href="#sched-domain-如何标识？" class="headerlink" title="sched domain: 如何标识？"></a>sched domain: 如何标识？</h2><p><code>include/linux/sched/sd_flags.h</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SDF_SHARED_CHILD       0x1</span><br><span class="line">#define SDF_SHARED_PARENT      0x2</span><br><span class="line">#define SDF_NEEDS_GROUPS       0x4</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SD_FLAG(SD_BALANCE_NEWIDLE, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_BALANCE_EXEC, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_BALANCE_FORK, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_BALANCE_WAKE, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_WAKE_AFFINE, SDF_SHARED_CHILD)</span><br><span class="line">SD_FLAG(SD_ASYM_CPUCAPACITY, SDF_SHARED_PARENT | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_SHARE_CPUCAPACITY, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_SHARE_PKG_RESOURCES, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_SERIALIZE, SDF_SHARED_PARENT | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_ASYM_PACKING, SDF_SHARED_CHILD | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_PREFER_SIBLING, SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_OVERLAP, SDF_SHARED_PARENT | SDF_NEEDS_GROUPS)</span><br><span class="line">SD_FLAG(SD_NUMA, SDF_SHARED_PARENT | SDF_NEEDS_GROUPS)</span><br></pre></td></tr></table></figure>


</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Hui Su"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Hui Su</p><p class="is-size-6 is-block">liulangren bolg</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">115</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">143</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/liulangrenaaa" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/liulangrenaaa"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.google.com.hk/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Google</span></span><span class="level-right"><span class="level-item tag">www.google.com.hk</span></span></a></li><li><a class="level is-mobile" href="https://lkml.org/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">LKML</span></span><span class="level-right"><span class="level-item tag">lkml.org</span></span></a></li><li><a class="level is-mobile" href="https://mail.google.com/mail" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gmail</span></span><span class="level-right"><span class="level-item tag">mail.google.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Gitee</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhihu.com/explore" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/contest/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 剑指offer</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Leetcode 周赛</span></span><span class="level-right"><span class="level-item tag">leetcode-cn.com</span></span></a></li><li><a class="level is-mobile" href="https://tongji.baidu.com/web/32051076/overview/index?siteId=16230094" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">百度分析</span></span><span class="level-right"><span class="level-item tag">tongji.baidu.com</span></span></a></li><li><a class="level is-mobile" href="https://analytics.google.com/analytics/web/#/a187909645p259761261/admin/streams/table/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">google分析</span></span><span class="level-right"><span class="level-item tag">analytics.google.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/BRK/"><span class="tag">BRK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HW/"><span class="tag">HW</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KASAN/"><span class="tag">KASAN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OOM/"><span class="tag">OOM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/QCOM/"><span class="tag">QCOM</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aarch64/"><span class="tag">aarch64</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/acl/"><span class="tag">acl</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android-framework/"><span class="tag">android framework</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android12-gdb64%E8%B0%83%E8%AF%95%E8%BF%9B%E7%A8%8B/"><span class="tag">android12 gdb64调试进程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpf/"><span class="tag">bpf</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bpftrace/"><span class="tag">bpftrace</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup/"><span class="tag">cgroup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v1/"><span class="tag">cgroup v1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroup-v2/"><span class="tag">cgroup v2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpu%E8%B0%83%E9%A2%91/"><span class="tag">cpu调频</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/crash/"><span class="tag">crash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dd/"><span class="tag">dd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/deadlock/"><span class="tag">deadlock</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debugfs/"><span class="tag">debugfs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/double-free/"><span class="tag">double free</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/drop-caches/"><span class="tag">drop_caches</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dumpe2fs/"><span class="tag">dumpe2fs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/eas/"><span class="tag">eas</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/event-trace/"><span class="tag">event trace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ext2/"><span class="tag">ext2</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-attr/"><span class="tag">file attr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/file-hole/"><span class="tag">file hole</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/filesystem/"><span class="tag">filesystem</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fsck/"><span class="tag">fsck</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ftrace/"><span class="tag">ftrace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gdb/"><span class="tag">gdb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hardlockup/"><span class="tag">hardlockup</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hrtimer/"><span class="tag">hrtimer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hugepage/"><span class="tag">hugepage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hungtask/"><span class="tag">hungtask</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/interrupt/"><span class="tag">interrupt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt/"><span class="tag">intrrrupt</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intrrrupt-storm/"><span class="tag">intrrrupt storm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/irq/"><span class="tag">irq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kallsyms/"><span class="tag">kallsyms</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kdump/"><span class="tag">kdump</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kernel-patch/"><span class="tag">kernel patch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kfence/"><span class="tag">kfence</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kmemleak/"><span class="tag">kmemleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kprobes/"><span class="tag">kprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kretprobes/"><span class="tag">kretprobes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ksoftirqd/"><span class="tag">ksoftirqd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kthread/"><span class="tag">kthread</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvm/"><span class="tag">kvm</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kvmtool/"><span class="tag">kvmtool</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/launch-json/"><span class="tag">launch.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-kernel/"><span class="tag">linux kernel</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux-native-aio/"><span class="tag">linux native aio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lock-stat/"><span class="tag">lock_stat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lockdep/"><span class="tag">lockdep</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/makedumpfile/"><span class="tag">makedumpfile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memleak/"><span class="tag">memleak</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory/"><span class="tag">memory</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/memory-direct-reclaim/"><span class="tag">memory direct reclaim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mount/"><span class="tag">mount</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/namespace/"><span class="tag">namespace</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node/"><span class="tag">node</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oom/"><span class="tag">oom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/oops/"><span class="tag">oops</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-cache/"><span class="tag">page_cache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/page-owner/"><span class="tag">page_owner</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pagecache/"><span class="tag">pagecache</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pagemap/"><span class="tag">pagemap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/panic/"><span class="tag">panic</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/per-cpu/"><span class="tag">per-cpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/perf/"><span class="tag">perf</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/perf-c2c/"><span class="tag">perf c2c</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pid-namespace/"><span class="tag">pid namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preempt-count/"><span class="tag">preempt_count</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/preemption/"><span class="tag">preemption</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pressure/"><span class="tag">pressure</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/process-madvise/"><span class="tag">process_madvise</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psi/"><span class="tag">psi</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/psoix-aio/"><span class="tag">psoix aio</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/randomize-va-space/"><span class="tag">randomize_va_space</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rcu/"><span class="tag">rcu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/read-code/"><span class="tag">read code</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sched-latency/"><span class="tag">sched latency</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/schedule/"><span class="tag">schedule</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/shell/"><span class="tag">shell</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slab/"><span class="tag">slab</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub/"><span class="tag">slub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/slub-debug/"><span class="tag">slub_debug</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/softlockup/"><span class="tag">softlockup</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stack-overflow/"><span class="tag">stack_overflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-key/"><span class="tag">static_key</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sync/"><span class="tag">sync</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systemTap/"><span class="tag">systemTap</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/systrace/"><span class="tag">systrace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-json/"><span class="tag">task.json</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/task-struct/"><span class="tag">task_struct</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tasklet/"><span class="tag">tasklet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/thread-info/"><span class="tag">thread_info</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tracepoint/"><span class="tag">tracepoint</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ubuntu/"><span class="tag">ubuntu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/use-after-free/"><span class="tag">use after free</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uts-namespace/"><span class="tag">uts namespace</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/valgrind/"><span class="tag">valgrind</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vdso/"><span class="tag">vdso</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmstat/"><span class="tag">vmstat</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vmtouch/"><span class="tag">vmtouch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vscode/"><span class="tag">vscode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/x86/"><span class="tag">x86</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xattr/"><span class="tag">xattr</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zone/"><span class="tag">zone</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内存泄漏</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%B6%8A%E7%95%8C/"><span class="tag">内存泄漏越界</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"><span class="tag">内存泄露</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">内核内存泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C/"><span class="tag">内核内存越界</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"><span class="tag">内核同步</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0/"><span class="tag">内核抢占</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E6%A0%B8%E6%A0%88%E6%BA%A2%E5%87%BA/"><span class="tag">内核栈溢出</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E7%AE%A1%E7%AE%A1%E7%90%86/"><span class="tag">内管管理</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"><span class="tag">函数调用</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E9%9A%8F%E6%9C%BA%E5%8C%96/"><span class="tag">地址空间布局随机化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E7%A8%B3%E5%AE%9A%E6%80%A7/"><span class="tag">性能稳定性</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B3%84%E6%BC%8F/"><span class="tag">文件描述符泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><span class="tag">文件系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="tag">服务器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E9%A1%B9/"><span class="tag">杂项</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%88/"><span class="tag">栈</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/"><span class="tag">死锁检测</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="tag">生活感悟</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%A8%E6%88%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"><span class="tag">用户内存泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A9%BA%E6%8C%87%E9%92%88/"><span class="tag">空指针</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F/"><span class="tag">虚拟地址空间泄漏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F/"><span class="tag">资源泄漏</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%B8%AD%E6%96%AD/"><span class="tag">软中断</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"><span class="tag">进程调度</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/"><span class="tag">通用寄存器</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%81%E7%B2%92%E5%BA%A6/"><span class="tag">锁粒度</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E7%B3%BB%E7%BB%9F/"><span class="tag">问题系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/QCOM/"><span class="level-start"><span class="level-item">QCOM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/cgroup-v1/"><span class="level-start"><span class="level-item">cgroup v1</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/cgroup-v1/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/cgroup-v2/"><span class="level-start"><span class="level-item">cgroup v2</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/kernel-debug/"><span class="level-start"><span class="level-item">kernel debug</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/kernel-debug/cache-false-sharing/"><span class="level-start"><span class="level-item">cache false sharing</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/linux-kernel/"><span class="level-start"><span class="level-item">linux kernel</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/"><span class="level-start"><span class="level-item">linux schedule</span></span><span class="level-end"><span class="level-item tag">13</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/deadline-schedule/"><span class="level-start"><span class="level-item">deadline schedule</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/"><span class="level-start"><span class="level-item">frequency governer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/frequency-governer/schedule-util/"><span class="level-start"><span class="level-item">schedule util</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/linux-kernel/linux-schedule/idle/"><span class="level-start"><span class="level-item">idle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/linux%E5%86%85%E6%A0%B8/"><span class="level-start"><span class="level-item">linux内核</span></span><span class="level-end"><span class="level-item tag">68</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/"><span class="level-start"><span class="level-item">namespace</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/namespace/pid-namespace/"><span class="level-start"><span class="level-item">pid namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/namespace/uts-namespace/"><span class="level-start"><span class="level-item">uts namespace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/qemu/"><span class="level-start"><span class="level-item">qemu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/schedule/"><span class="level-start"><span class="level-item">schedule</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/server/"><span class="level-start"><span class="level-item">server</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/shell%E8%84%9A%E6%9C%AC/"><span class="level-start"><span class="level-item">shell脚本</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"><span class="level-start"><span class="level-item">生活感悟</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-24T11:00:00.000Z">2022-01-24</time></p><p class="title"><a href="/2022/01/24/schedule/cpu%E8%B0%83%E9%A2%91/">cpu调频</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-20T08:42:37.115Z">2022-01-20</time></p><p class="title"><a href="/2022/01/20/schedule/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-01-05T11:00:00.000Z">2022-01-05</time></p><p class="title"><a href="/2022/01/05/schedule/eas/">eas</a></p><p class="categories"><a href="/categories/linux-kernel/">linux kernel</a> / <a href="/categories/linux-kernel/linux-schedule/">linux schedule</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-03T11:00:00.000Z">2021-11-03</time></p><p class="title"><a href="/2021/11/03/%E5%86%85%E6%A0%B8%E8%A7%82%E6%B5%8B/perf%E7%9B%B8%E5%85%B3/perf%20c2c/">perf c2c</a></p><p class="categories"><a href="/categories/kernel-debug/">kernel debug</a> / <a href="/categories/kernel-debug/cache-false-sharing/">cache false sharing</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-23T11:00:00.000Z">2021-09-23</time></p><p class="title"><a href="/2021/09/23/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/android12%20gdb64%E8%B0%83%E8%AF%95%E8%BF%9B%E7%A8%8B/">android12 gdb64调试进程</a></p><p class="categories"><a href="/categories/linux%E5%86%85%E6%A0%B8/">linux内核</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="liulangren Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Su Hui</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>